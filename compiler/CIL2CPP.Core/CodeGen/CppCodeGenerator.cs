using System.Text;
using CIL2CPP.Core.IR;

namespace CIL2CPP.Core.CodeGen;

/// <summary>
/// Generates C++ source code from IR module.
/// </summary>
public partial class CppCodeGenerator
{
    /// <summary>
    /// BCL fallback vtable entries for System.Object virtual methods.
    /// Used when a VTable slot has no user override (Method == null).
    /// </summary>
    private static readonly Dictionary<string, string> ObjectMethodFallbacks = new()
    {
        ["ToString"] = "(void*)cil2cpp::object_to_string",
        ["Equals"] = "(void*)cil2cpp::object_equals",
        ["GetHashCode"] = "(void*)cil2cpp::object_get_hash_code",
    };

    /// <summary>
    /// Unresolved generic parameter names that indicate an open generic type
    /// leaked through reachability analysis. These types cannot be compiled to C++.
    /// </summary>
    private static readonly string[] OpenGenericParamNames =
    [
        "TResult", "TKey", "TValue", "TSource", "TElement", "TOutput",
        "TAntecedentResult", "TContinuationResult", "TNewResult",
    ];

    /// <summary>
    /// Check if a type has unresolved generic parameters in its C++ name.
    /// Such types are open generics that leaked through and should be skipped.
    /// </summary>
    private static bool HasUnresolvedGenericParams(IRType type)
    {
        var name = type.CppName;
        foreach (var param in OpenGenericParamNames)
        {
            // Check if the param name appears as a word boundary in the C++ name
            var idx = name.IndexOf(param, StringComparison.Ordinal);
            if (idx >= 0)
            {
                // Verify it's not a substring of a longer word (e.g., "ResultHandler")
                var afterIdx = idx + param.Length;
                if (afterIdx >= name.Length || !char.IsLetterOrDigit(name[afterIdx]))
                    return true;
            }
        }

        // Also check for [] in CppName (invalid C++ identifier)
        if (name.Contains("[]"))
            return true;

        return false;
    }

    /// <summary>
    /// Check if a name is a valid C++ identifier (no brackets, ampersands, parens, etc.).
    /// Used to filter out mangled names from IL types that contain array/ref/pointer syntax.
    /// </summary>
    private static bool IsValidCppIdentifier(string name)
    {
        if (string.IsNullOrEmpty(name)) return false;
        // C++ identifiers can only contain letters, digits, underscores
        // Also allow :: for namespace-qualified names
        foreach (var ch in name)
        {
            if (char.IsLetterOrDigit(ch) || ch == '_' || ch == ':')
                continue;
            return false;
        }
        return true;
    }

    private readonly IRModule _module;
    private readonly BuildConfiguration _config;

    public CppCodeGenerator(IRModule module, BuildConfiguration? config = null)
    {
        _module = module;
        _config = config ?? BuildConfiguration.Release;
    }

    /// <summary>
    /// Generate all C++ files for the module.
    /// </summary>
    public GeneratedOutput Generate()
    {
        var output = new GeneratedOutput();

        // Generate header file with all type declarations
        output.HeaderFile = GenerateHeader();

        // Generate source file with all implementations
        output.SourceFile = GenerateSource();

        // Generate main entry point only for executable projects (with entry point)
        if (_module.EntryPoint != null)
        {
            output.MainFile = GenerateMain();
        }

        // Generate CMakeLists.txt
        output.CMakeFile = GenerateCMakeLists();

        return output;
    }

    private GeneratedFile GenerateMain()
    {
        var sb = new StringBuilder();

        sb.AppendLine("// Generated by CIL2CPP - DO NOT EDIT");
        sb.AppendLine($"// Entry point for {_module.Name}");
        sb.AppendLine();
        sb.AppendLine($"#include \"{_module.Name}.h\"");
        sb.AppendLine();
        sb.AppendLine("int main(int argc, char* argv[]) {");
        sb.AppendLine("    cil2cpp::runtime_init();");
        sb.AppendLine();

        // Initialize string literals
        if (_module.StringLiterals.Count > 0)
        {
            sb.AppendLine("    __init_string_literals();");
            sb.AppendLine();
        }

        // Call entry point
        if (_module.EntryPoint != null)
        {
            sb.AppendLine($"    // Call {_module.EntryPoint.DeclaringType?.ILFullName}::{_module.EntryPoint.Name}");
            sb.AppendLine($"    {_module.EntryPoint.CppName}();");
        }
        else
        {
            sb.AppendLine("    // WARNING: No entry point found");
        }

        sb.AppendLine();
        sb.AppendLine("    cil2cpp::runtime_shutdown();");
        sb.AppendLine("    return 0;");
        sb.AppendLine("}");

        return new GeneratedFile
        {
            FileName = "main.cpp",
            Content = sb.ToString()
        };
    }

    private GeneratedFile GenerateCMakeLists()
    {
        var sb = new StringBuilder();
        var projectName = _module.Name;
        bool isExe = _module.EntryPoint != null;
        var linkVisibility = isExe ? "PRIVATE" : "PUBLIC";

        sb.AppendLine("# Generated by CIL2CPP - DO NOT EDIT");
        sb.AppendLine("cmake_minimum_required(VERSION 3.20)");
        sb.AppendLine($"project({projectName} CXX)");
        sb.AppendLine();
        sb.AppendLine("set(CMAKE_CXX_STANDARD 20)");
        sb.AppendLine("set(CMAKE_CXX_STANDARD_REQUIRED ON)");
        sb.AppendLine();

        // Default build type
        sb.AppendLine("if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)");
        sb.AppendLine($"    set(CMAKE_BUILD_TYPE \"{_config.ConfigurationName}\" CACHE STRING \"Build type\" FORCE)");
        sb.AppendLine("    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS \"Debug\" \"Release\")");
        sb.AppendLine("endif()");
        sb.AppendLine();

        // Target: executable or static library
        if (isExe)
        {
            sb.AppendLine($"add_executable({projectName}");
            sb.AppendLine("    main.cpp");
            sb.AppendLine($"    {projectName}.cpp");
            sb.AppendLine(")");
        }
        else
        {
            sb.AppendLine($"add_library({projectName} STATIC");
            sb.AppendLine($"    {projectName}.cpp");
            sb.AppendLine(")");
            sb.AppendLine();
            sb.AppendLine($"target_include_directories({projectName} PUBLIC");
            sb.AppendLine("    $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}>");
            sb.AppendLine(")");
        }
        sb.AppendLine();

        // CIL2CPP Runtime via find_package
        sb.AppendLine("find_package(cil2cpp REQUIRED)");
        sb.AppendLine($"target_link_libraries({projectName} {linkVisibility} cil2cpp::runtime)");
        sb.AppendLine();

        // P/Invoke native library linking (filter out .NET internal modules)
        var internalPInvokeModules = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
            { "QCall", "QCall.dll", "libSystem.Native", "libSystem.Globalization.Native" };
        var pinvokeModules = _module.Types
            .SelectMany(t => t.Methods)
            .Where(m => m.IsPInvoke && !string.IsNullOrEmpty(m.PInvokeModule))
            .Select(m => m.PInvokeModule!)
            .Where(m => !internalPInvokeModules.Contains(m))
            .Distinct()
            .ToList();
        if (pinvokeModules.Count > 0)
        {
            sb.AppendLine("# P/Invoke native libraries");
            foreach (var mod in pinvokeModules)
            {
                // Strip .dll/.so extension for CMake library name
                var libName = mod;
                if (libName.EndsWith(".dll", StringComparison.OrdinalIgnoreCase))
                    libName = libName[..^4];
                else if (libName.EndsWith(".so", StringComparison.OrdinalIgnoreCase))
                    libName = libName[..^3];
                sb.AppendLine($"target_link_libraries({projectName} PRIVATE {libName})");
            }
            sb.AppendLine();
        }

        // Debug/Release settings for generated code
        sb.AppendLine($"target_compile_definitions({projectName} {linkVisibility}");
        sb.AppendLine("    $<$<CONFIG:Debug>:CIL2CPP_DEBUG>)");
        sb.AppendLine();

        sb.AppendLine("if(MSVC)");
        sb.AppendLine($"    target_compile_options({projectName} PRIVATE");
        sb.AppendLine("        $<$<CONFIG:Debug>:/Zi /Od /RTC1>");
        sb.AppendLine("        $<$<CONFIG:Release>:/O2 /DNDEBUG>");
        sb.AppendLine("    )");
        if (isExe)
        {
            sb.AppendLine($"    target_link_options({projectName} PRIVATE");
            sb.AppendLine("        $<$<CONFIG:Debug>:/DEBUG>)");
        }
        sb.AppendLine("else()");
        sb.AppendLine($"    target_compile_options({projectName} PRIVATE");
        sb.AppendLine("        $<$<CONFIG:Debug>:-g -O0>");
        sb.AppendLine("        $<$<CONFIG:Release>:-O2 -DNDEBUG>");
        sb.AppendLine("    )");
        sb.AppendLine("endif()");

        return new GeneratedFile
        {
            FileName = "CMakeLists.txt",
            Content = sb.ToString()
        };
    }

    private static string EscapeString(string s)
    {
        var sb = new StringBuilder(s.Length);
        foreach (var ch in s)
        {
            switch (ch)
            {
                case '\\': sb.Append("\\\\"); break;
                case '"':  sb.Append("\\\""); break;
                case '\n': sb.Append("\\n"); break;
                case '\r': sb.Append("\\r"); break;
                case '\t': sb.Append("\\t"); break;
                case '\0': sb.Append("\\0"); break;
                default:
                    if (ch > 127)
                    {
                        // Escape non-ASCII as universal character names for MSVC compatibility
                        sb.Append($"\\u{(int)ch:X4}");
                    }
                    else
                    {
                        sb.Append(ch);
                    }
                    break;
            }
        }
        return sb.ToString();
    }
}

public class GeneratedOutput
{
    public GeneratedFile HeaderFile { get; set; } = new();
    public GeneratedFile SourceFile { get; set; } = new();
    public GeneratedFile? MainFile { get; set; }
    public GeneratedFile? CMakeFile { get; set; }

    /// <summary>
    /// Write all generated files to a directory.
    /// </summary>
    public void WriteToDirectory(string outputDir)
    {
        Directory.CreateDirectory(outputDir);
        File.WriteAllText(Path.Combine(outputDir, HeaderFile.FileName), HeaderFile.Content);
        File.WriteAllText(Path.Combine(outputDir, SourceFile.FileName), SourceFile.Content);
        if (MainFile != null)
        {
            File.WriteAllText(Path.Combine(outputDir, MainFile.FileName), MainFile.Content);
        }
        if (CMakeFile != null)
        {
            File.WriteAllText(Path.Combine(outputDir, CMakeFile.FileName), CMakeFile.Content);
        }
    }
}

public class GeneratedFile
{
    public string FileName { get; set; } = "";
    public string Content { get; set; } = "";
}
