using System.Text;
using CIL2CPP.Core.IR;

namespace CIL2CPP.Core.CodeGen;

public partial class CppCodeGenerator
{
    private GeneratedFile GenerateHeader()
    {
        var sb = new StringBuilder();

        sb.AppendLine("// Generated by CIL2CPP - DO NOT EDIT");
        sb.AppendLine($"// Source assembly: {_module.Name}");
        sb.AppendLine();
        sb.AppendLine("#pragma once");
        sb.AppendLine();
        sb.AppendLine("#include <cil2cpp/cil2cpp.h>");
        sb.AppendLine();

        // Filter out compiler-generated types and open generic types with unresolved params
        var userTypes = _module.Types
            .Where(t => !CppNameMapper.IsCompilerGeneratedType(t.ILFullName))
            .Where(t => !HasUnresolvedGenericParams(t))
            .ToList();

        // Forward declarations — all types except enums, delegates, runtime-provided, and cil2cpp:: types
        sb.AppendLine("// ===== Forward Declarations =====");
        var forwardDeclared = new HashSet<string>();
        // Build set of types that will become using aliases (not struct forward-decls).
        // This includes delegates and core runtime types with using aliases.
        var aliasedTypes = new HashSet<string>();
        foreach (var type in _module.Types)
        {
            if (type.IsDelegate)
                aliasedTypes.Add(type.CppName);
        }
        // Core runtime types that get using aliases (Object, String, Array, etc.)
        foreach (var ilName in IRBuilder.RuntimeProvidedTypes)
            aliasedTypes.Add(CppNameMapper.MangleTypeName(ilName));
        foreach (var (mangled, _) in GetRuntimeProvidedTypeAliases())
            aliasedTypes.Add(mangled);
        // Primitive types that get using aliases (System_Byte = uint8_t, etc.)
        foreach (var (mangled, _) in GetPrimitiveTypeAliases())
            aliasedTypes.Add(mangled);
        // Types already aliased in runtime headers — skip struct definitions
        foreach (var mangled in RuntimeHeaderAliasedTypes)
            aliasedTypes.Add(mangled);
        foreach (var type in userTypes)
        {
            if (type.IsEnum || type.IsDelegate) continue;
            // Skip types that have using aliases (they're resolved via alias, not forward-decl)
            if (aliasedTypes.Contains(type.CppName)) continue;
            if (!IsValidCppIdentifier(type.CppName)) continue;
            sb.AppendLine($"struct {type.CppName};");
            forwardDeclared.Add(type.CppName);
        }
        // Collect enum type names — can't be forward-declared as struct
        var enumTypes = new HashSet<string>();
        foreach (var type in userTypes)
        {
            if (type.IsEnum)
                enumTypes.Add(type.CppName);
        }
        // Include external enum types (BCL enums not in the IR module)
        foreach (var (mangledName, _) in _module.ExternalEnumTypes)
            enumTypes.Add(mangledName);
        // Also forward-declare types referenced by method parameters, return types, and field types.
        // Scan ALL types (not just non-runtime-provided) to ensure complete forward declarations.
        foreach (var type in userTypes)
        {
            if (type.IsDelegate) continue;
            // Collect type names from method signatures
            foreach (var method in type.Methods)
            {
                var sigTypes = new List<string>();
                foreach (var param in method.Parameters)
                    sigTypes.Add(param.CppTypeName);
                if (!string.IsNullOrEmpty(method.ReturnTypeCpp) && method.ReturnTypeCpp != "void")
                    sigTypes.Add(method.ReturnTypeCpp);

                foreach (var typeName in sigTypes)
                    TryForwardDeclare(sb, typeName, forwardDeclared, aliasedTypes, enumTypes);
            }
            // Collect type names from local variables (pointer locals need forward decl)
            foreach (var method in type.Methods)
            {
                foreach (var local in method.Locals)
                {
                    if (local.CppTypeName.EndsWith("*"))
                        TryForwardDeclare(sb, local.CppTypeName, forwardDeclared, aliasedTypes, enumTypes);
                }
            }
            // Collect type names from field types (for pointer fields that aren't sanitized to void*)
            foreach (var field in type.Fields)
                TryForwardDeclare(sb, CppNameMapper.GetCppTypeForDecl(field.FieldTypeName), forwardDeclared, aliasedTypes, enumTypes);
            foreach (var field in type.StaticFields)
                TryForwardDeclare(sb, CppNameMapper.GetCppTypeForDecl(field.FieldTypeName), forwardDeclared, aliasedTypes, enumTypes);
        }
        // Using aliases for runtime-provided types (mangled name → cil2cpp:: struct)
        // These types are provided by the runtime but their mangled names may appear
        // as generic type arguments or cast targets in generated code.
        foreach (var (mangled, cppAlias) in GetRuntimeProvidedTypeAliases())
        {
            if (!forwardDeclared.Contains(mangled))
                sb.AppendLine($"using {mangled} = {cppAlias};");
        }
        // Using aliases for primitive types (System_Byte = uint8_t, etc.)
        // Primitive types map to C++ built-in types. Methods are compiled from BCL IL
        // but the struct definition is not emitted — the using alias provides the type.
        foreach (var (mangled, cppAlias) in GetPrimitiveTypeAliases())
        {
            if (!forwardDeclared.Contains(mangled))
                sb.AppendLine($"using {mangled} = {cppAlias};");
        }
        sb.AppendLine();

        // Type info declarations (skip runtime-provided types — declared in runtime headers)
        sb.AppendLine("// ===== Type Info Declarations =====");
        // Collect types whose TypeInfo is already declared elsewhere (exception aliases or primitive section)
        var runtimeDeclaredTypeInfos = new HashSet<string>();
        foreach (var (mangledName, _) in GetExceptionTypeInfoAliases())
            runtimeDeclaredTypeInfos.Add(mangledName);
        // Skip System.Object/System.String from main loop when declared in primitive type section
        foreach (var entry in _module.PrimitiveTypeInfos.Values)
        {
            if (GetRuntimeTypeInfoAlias(entry.ILFullName) != null)
                runtimeDeclaredTypeInfos.Add(entry.CppMangledName);
        }
        foreach (var type in userTypes)
        {
            // Skip types whose TypeInfo is already declared in runtime headers
            if (runtimeDeclaredTypeInfos.Contains(type.CppName)) continue;
            if (!IsValidCppIdentifier(type.CppName)) continue;
            // Types with a runtime TypeInfo alias (Object, String) are defined as
            // TypeInfo& references in the source — header must match
            if (GetRuntimeTypeInfoAlias(type.ILFullName) != null)
                sb.AppendLine($"extern cil2cpp::TypeInfo& {type.CppName}_TypeInfo;");
            else
                sb.AppendLine($"extern cil2cpp::TypeInfo {type.CppName}_TypeInfo;");
        }
        // Primitive type TypeInfo declarations (for array element types)
        foreach (var entry in _module.PrimitiveTypeInfos.Values)
        {
            // Runtime-provided reference types: declared as TypeInfo& reference to runtime's TypeInfo
            var runtimeAlias = GetRuntimeTypeInfoAlias(entry.ILFullName);
            if (runtimeAlias != null)
                sb.AppendLine($"extern cil2cpp::TypeInfo& {entry.CppMangledName}_TypeInfo;");
            else
                sb.AppendLine($"extern cil2cpp::TypeInfo {entry.CppMangledName}_TypeInfo;");
        }
        // Exception TypeInfo reference aliases — maps mangled names to runtime-declared TypeInfos
        // (e.g., System_Exception_TypeInfo → cil2cpp::Exception_TypeInfo)
        foreach (var (mangledName, runtimeTypeInfoName) in GetExceptionTypeInfoAliases())
        {
            sb.AppendLine($"extern cil2cpp::TypeInfo& {mangledName}_TypeInfo;");
        }
        sb.AppendLine();

        // Build set of all types that will be defined (for field type sanitization)
        var definedTypeNames = new HashSet<string>();
        foreach (var type in userTypes)
            definedTypeNames.Add(type.CppName);
        // Also include aliased types (they exist as cil2cpp:: types)
        foreach (var name in aliasedTypes)
            definedTypeNames.Add(name);
        foreach (var name in enumTypes)
            definedTypeNames.Add(name);

        // Type Definitions — ordering: enums first, then delegates, then structs (topologically sorted).
        sb.AppendLine("// ===== Type Definitions =====");
        var emittedStructs = new HashSet<string>();
        // Phase 1: Enums (must come first — used as value-type fields in structs)
        foreach (var type in userTypes)
        {
            if (!type.IsEnum || type.IsRuntimeProvided) continue;
            if (!IsValidCppIdentifier(type.CppName)) continue;
            GenerateEnumDefinition(sb, type);
            emittedStructs.Add(type.CppName);
        }
        // Phase 1.5: External enum aliases (BCL enums referenced in method signatures but not in IR module)
        // Use using = type (not enum) since generated code passes integers directly.
        // Method overloading conflicts are handled by DisambiguateOverloadedMethods.
        foreach (var (mangledName, underlyingType) in _module.ExternalEnumTypes)
        {
            if (emittedStructs.Contains(mangledName)) continue;
            sb.AppendLine($"using {mangledName} = {underlyingType};");
            emittedStructs.Add(mangledName);
            definedTypeNames.Add(mangledName);
        }
        // Phase 2: Delegate aliases
        foreach (var type in userTypes)
        {
            if (!type.IsDelegate || type.IsRuntimeProvided) continue;
            if (!IsValidCppIdentifier(type.CppName)) continue;
            sb.AppendLine($"using {type.CppName} = cil2cpp::Delegate;");
            sb.AppendLine();
            emittedStructs.Add(type.CppName);
        }
        // Phase 3: Emit stub structs for unknown value types referenced as fields or locals
        var unknownValueTypeStubs = new HashSet<string>();
        var opaqueSpanStubs = new List<string>();
        CollectUnknownValueTypeFields(userTypes, definedTypeNames, unknownValueTypeStubs);
        CollectUnknownValueTypeLocals(userTypes, definedTypeNames, unknownValueTypeStubs);
        foreach (var stubName in unknownValueTypeStubs)
        {
            // Span/ReadOnlySpan opaque stubs need f_reference + f_length for field access
            if (stubName.StartsWith("System_Span_1_") || stubName.StartsWith("System_ReadOnlySpan_1_"))
            {
                sb.AppendLine($"struct {stubName} {{ void* f_reference; int32_t f_length; }}; // opaque Span stub");
                opaqueSpanStubs.Add(stubName);
            }
            else
                sb.AppendLine($"struct {stubName} {{ }}; // opaque BCL internal type");
            emittedStructs.Add(stubName);
            definedTypeNames.Add(stubName);
        }
        // Phase 4: All struct types — topologically sorted by value-type field dependencies
        var structTypes = userTypes
            .Where(t => !t.IsEnum && !t.IsDelegate && IsValidCppIdentifier(t.CppName))
            .ToList();
        var sortedStructTypes = TopologicalSortByFieldDeps(structTypes, aliasedTypes);
        foreach (var type in sortedStructTypes)
        {
            if (emittedStructs.Contains(type.CppName)) continue;
            // Skip types with using aliases (their layout is resolved by the alias target)
            if (aliasedTypes.Contains(type.CppName)) continue;
            // Skip runtime-provided types (struct layout comes from runtime headers)
            if (type.IsRuntimeProvided) continue;
            // Skip primitive types (mapped to C++ built-in types via using aliases)
            if (type.IsPrimitiveType) continue;
            if (type.IsInterface) continue;
            GenerateStructDefinition(sb, type, definedTypeNames);
            emittedStructs.Add(type.CppName);
        }

        // Save emitted struct definitions for source generator (stub filtering)
        _emittedStructDefs = new HashSet<string>(emittedStructs);
        // Also include aliased types (they have full definitions via alias)
        foreach (var name in aliasedTypes) _emittedStructDefs.Add(name);
        foreach (var name in enumTypes) _emittedStructDefs.Add(name);
        foreach (var name in unknownValueTypeStubs) _emittedStructDefs.Add(name);

        // Static field storage declarations
        // Note: RuntimeProvided types still need statics (e.g., String.Empty)
        foreach (var type in userTypes)
        {
            if (type.IsEnum || type.IsDelegate) continue;
            if (type.StaticFields.Count > 0)
            {
                sb.AppendLine($"// Static fields for {type.ILFullName}");
                sb.AppendLine($"struct {type.CppName}_Statics {{");
                var emittedStaticFields = new HashSet<string>();
                foreach (var field in type.StaticFields)
                {
                    if (!emittedStaticFields.Add(field.CppName)) continue; // Deduplicate
                    var cppType = SanitizeFieldType(field.FieldTypeName, definedTypeNames);
                    sb.AppendLine($"    {cppType} {field.CppName};");
                }
                sb.AppendLine("};");
                sb.AppendLine($"extern {type.CppName}_Statics {type.CppName}_statics;");
                sb.AppendLine();
            }
        }

        // Build set of all known C++ type names (defined + forward-declared + stubs + all module types).
        // Function calls only need declarations (not struct definitions), so include all types
        // from the IR module — their methods will be declared via GenerateMissingMethodStubs.
        var knownTypeNames = new HashSet<string>(definedTypeNames);
        foreach (var name in forwardDeclared)
            knownTypeNames.Add(name);
        foreach (var name in unknownValueTypeStubs)
            knownTypeNames.Add(name);
        foreach (var type in _module.Types)
            knownTypeNames.Add(type.CppName);

        // Method declarations (skip delegates and InternalCall methods)
        // RuntimeProvided types: only emit methods that have compiled IL bodies
        sb.AppendLine("// ===== Method Declarations =====");
        var emittedMethodDecls = new HashSet<string>();
        foreach (var type in userTypes)
        {
            if (type.IsDelegate) continue;

            // For interfaces, only emit declarations for DIM methods (non-abstract with bodies)
            if (type.IsInterface)
            {
                foreach (var method in type.Methods)
                {
                    if (method.IsAbstract || method.BasicBlocks.Count == 0) continue;
                    if (HasUnknownParameterTypes(method, knownTypeNames)) continue;
                    if (!emittedMethodDecls.Add(method.GetCppSignature())) continue;
                    sb.AppendLine($"{method.GetCppSignature()};");
                }
                continue;
            }

            foreach (var method in type.Methods)
            {
                if (method.IsAbstract || method.IsInternalCall) continue;
                if (method.BasicBlocks.Count == 0 && !method.IsPInvoke) continue;
                // Core runtime types (Object, String, Array, etc.): only emit static methods.
                // Non-core RuntimeProvided types (Task, Thread, CancellationToken) emit all methods.
                if (type.IsRuntimeProvided && !method.IsStatic
                    && IRBuilder.CoreRuntimeTypes.Contains(type.ILFullName)) continue;
                // Skip methods whose parameter/return types reference unknown struct types
                if (HasUnknownParameterTypes(method, knownTypeNames)) continue;
                if (!emittedMethodDecls.Add(method.GetCppSignature())) continue;
                sb.AppendLine($"{method.GetCppSignature()};");
            }
            sb.AppendLine();
        }

        // Generate stub declarations for methods called but not declared.
        // This handles methods on RuntimeProvided types and types not in the module.
        GenerateMissingMethodStubs(sb, emittedMethodDecls, userTypes, knownTypeNames);

        // Generate trivial method declarations for opaque Span/ReadOnlySpan stubs.
        // These types were discovered from BCL code locals/params but aren't full IRType objects.
        // The methods are trivial (get_Length returns f_length, get_IsEmpty returns f_length==0).
        _opaqueSpanStubs = opaqueSpanStubs;
        if (opaqueSpanStubs.Count > 0)
        {
            sb.AppendLine("// ===== Opaque Span Stub Methods =====");
            foreach (var spanType in opaqueSpanStubs)
            {
                var getLenSig = $"int32_t {spanType}_get_Length({spanType}* __this)";
                var isEmptySig = $"bool {spanType}_get_IsEmpty({spanType}* __this)";
                if (emittedMethodDecls.Add(getLenSig))
                    sb.AppendLine($"{getLenSig};");
                if (emittedMethodDecls.Add(isEmptySig))
                    sb.AppendLine($"{isEmptySig};");
            }
            sb.AppendLine();
        }

        // Populate the declared function names and param counts for use by source generation.
        // This allows the source generator to filter out methods that call undeclared functions
        // or methods that call functions with wrong arg counts (overload mismatches).
        _declaredFunctionNames = ExtractFunctionNamesFromSignatures(emittedMethodDecls);
        _declaredFunctionParamCounts = ExtractFunctionParamCounts(emittedMethodDecls);

        // Static constructor guard declarations
        foreach (var type in userTypes)
        {
            if (type.HasCctor)
            {
                sb.AppendLine($"void {type.CppName}_ensure_cctor();");
            }
        }
        if (userTypes.Any(t => t.HasCctor))
            sb.AppendLine();

        // String literal initializer and extern declarations
        if (_module.StringLiterals.Count > 0)
        {
            sb.AppendLine("// String literal initializer");
            sb.AppendLine("void __init_string_literals();");
            sb.AppendLine();

            // Extern declarations for string literal variables (defined in data file)
            sb.AppendLine("// String literal extern declarations");
            foreach (var (_, literal) in _module.StringLiterals)
            {
                sb.AppendLine($"extern cil2cpp::String* {literal.Id};");
            }
            sb.AppendLine();
        }

        // Extern declarations for array initializer data (defined in data file)
        if (_module.ArrayInitDataBlobs.Count > 0)
        {
            sb.AppendLine("// Array initializer data extern declarations");
            foreach (var blob in _module.ArrayInitDataBlobs)
            {
                sb.AppendLine($"extern const unsigned char {blob.Id}[];");
            }
            sb.AppendLine();
        }

        return new GeneratedFile
        {
            FileName = $"{_module.Name}.h",
            Content = sb.ToString()
        };
    }

    private void GenerateStructDefinition(StringBuilder sb, IRType type, HashSet<string>? definedTypes = null)
    {
        sb.AppendLine($"// {type.ILFullName}");

        if (type.IsValueType)
        {
            sb.AppendLine($"struct {type.CppName} {{");
        }
        else
        {
            sb.AppendLine($"struct {type.CppName} {{");
            sb.AppendLine($"    cil2cpp::TypeInfo* __type_info;");
            sb.AppendLine($"    cil2cpp::UInt32 __sync_block;");

            // Base type fields (walk full inheritance chain)
            var inheritedFields = CollectInheritedFields(type);
            // Track inherited field names to avoid duplicate own fields (C2086)
            var inheritedFieldNames = new HashSet<string>();
            if (inheritedFields.Count > 0)
            {
                sb.AppendLine($"    // Inherited fields");
                foreach (var (field, fromType) in inheritedFields)
                {
                    var cppType = SanitizeFieldType(field.FieldTypeName, definedTypes);
                    sb.AppendLine($"    {cppType} {field.CppName}; // from {fromType.ILFullName}");
                    inheritedFieldNames.Add(field.CppName);
                }
            }

            // Own fields (skip fields already emitted as inherited)
            foreach (var field in type.Fields)
            {
                if (inheritedFieldNames.Contains(field.CppName)) continue;
                var cppType = SanitizeFieldType(field.FieldTypeName, definedTypes);
                sb.AppendLine($"    {cppType} {field.CppName};");
            }

            sb.AppendLine("};");
            sb.AppendLine();
            return;
        }

        if (type.ExplicitSize > 0)
        {
            // Types with explicit ClassSize metadata (ECMA-335 II.10.1.2).
            // Three sub-cases:
            //   1. FixedBuffer: single FixedElementField → emit as C array
            //   2. StaticArrayInitTypeSize: no fields → emit raw byte array
            //   3. Other: has fields + explicit size → emit fields + padding

            if (type.Fields.Count == 1 && type.Fields[0].Name == "FixedElementField")
            {
                // Case 1: Fixed-size buffer (C# fixed keyword / [InlineArray])
                var field = type.Fields[0];
                var cppType = SanitizeFieldType(field.FieldTypeName, definedTypes);
                int elemSize = GetPrimitiveSize(cppType);
                if (elemSize > 0)
                {
                    int count = type.ExplicitSize / elemSize;
                    sb.AppendLine($"    {cppType} {field.CppName}[{count}];");
                }
                else
                {
                    // Fallback: emit as raw byte array to guarantee correct sizeof
                    sb.AppendLine($"    uint8_t {field.CppName}[{type.ExplicitSize}]; // FIXME: unknown element type '{cppType}'");
                }
            }
            else if (type.Fields.Count == 0)
            {
                // Case 2: Opaque sized type (e.g., __StaticArrayInitTypeSize=N)
                sb.AppendLine($"    uint8_t __data[{type.ExplicitSize}];");
            }
            else
            {
                // Case 3: Regular struct with explicit size — emit fields + tail padding
                foreach (var field in type.Fields)
                {
                    var cppType = SanitizeFieldType(field.FieldTypeName, definedTypes);
                    sb.AppendLine($"    {cppType} {field.CppName};");
                }
            }
        }
        else
        {
            // Normal value type: emit fields as-is
            foreach (var field in type.Fields)
            {
                var cppType = SanitizeFieldType(field.FieldTypeName, definedTypes);
                sb.AppendLine($"    {cppType} {field.CppName};");
            }
        }

        sb.AppendLine("};");
        sb.AppendLine();
    }

    /// <summary>
    /// Try to forward-declare a type name if it's a pointer type to an unknown struct.
    /// </summary>
    private static void TryForwardDeclare(StringBuilder sb, string cppTypeName,
        HashSet<string> forwardDeclared, HashSet<string> aliasedTypes, HashSet<string> enumTypes)
    {
        var raw = cppTypeName.TrimEnd('*').Trim();
        if (raw.Length == 0 || raw.StartsWith("cil2cpp::") || IsCppPrimitiveType(raw)) return;
        if (aliasedTypes.Contains(raw)) return;
        if (!IsValidCppIdentifier(raw)) return;
        if (enumTypes.Contains(raw)) return;
        if (!forwardDeclared.Contains(raw))
        {
            sb.AppendLine($"struct {raw};");
            forwardDeclared.Add(raw);
        }
    }

    /// <summary>
    /// Sanitize a field type for struct definition.
    /// If the type is a pointer to an unknown type, replace with void*.
    /// If the type is a value type not in the known set, it should have been stubbed.
    /// </summary>
    private static string SanitizeFieldType(string fieldTypeName, HashSet<string>? definedTypes)
    {
        var cppType = CppNameMapper.GetCppTypeForDecl(fieldTypeName);
        if (definedTypes == null) return cppType;

        // Check if the raw type name (without *) is known
        var rawType = cppType.TrimEnd('*').Trim();
        if (rawType.Length == 0 || rawType.StartsWith("cil2cpp::") || IsCppPrimitiveType(rawType))
            return cppType;

        if (!definedTypes.Contains(rawType))
        {
            // Unknown type — replace pointer fields with void*
            if (cppType.EndsWith("*"))
                return "void*";
            // Non-pointer unknown → should have been stubbed, but fallback to void*
            return "void*";
        }

        return cppType;
    }

    /// <summary>
    /// Collect unknown value types used as non-pointer fields in any struct.
    /// These need stub struct definitions to avoid C++ errors.
    /// </summary>
    private static void CollectUnknownValueTypeFields(
        List<IRType> types, HashSet<string> definedTypes, HashSet<string> stubs)
    {
        foreach (var type in types)
        {
            if (type.IsEnum || type.IsDelegate) continue;
            foreach (var field in type.Fields)
            {
                CheckFieldForStub(field.FieldTypeName, definedTypes, stubs);
            }
            // Also check inherited fields for reference types
            if (!type.IsValueType)
            {
                var inherited = CollectInheritedFields(type);
                foreach (var (field, _) in inherited)
                    CheckFieldForStub(field.FieldTypeName, definedTypes, stubs);
            }
            // Check static fields
            foreach (var field in type.StaticFields)
                CheckFieldForStub(field.FieldTypeName, definedTypes, stubs);
        }
    }

    /// <summary>
    /// Scan method locals, parameters, and return types for unknown non-pointer value types
    /// and add opaque stubs. This catches value types like Span&lt;T&gt;, EventData, ListBuilder&lt;T&gt;,
    /// ReadOnlySpan&lt;T&gt; etc. that don't have struct definitions in the IR module.
    /// </summary>
    private static void CollectUnknownValueTypeLocals(
        List<IRType> types, HashSet<string> definedTypes, HashSet<string> stubs)
    {
        foreach (var type in types)
        {
            if (type.IsEnum || type.IsDelegate) continue;
            foreach (var method in type.Methods)
            {
                // Scan locals
                foreach (var local in method.Locals)
                    TryAddValueTypeStub(local.CppTypeName, definedTypes, stubs);

                // Scan parameters (non-pointer value types in method signatures)
                foreach (var param in method.Parameters)
                    TryAddValueTypeStub(param.CppTypeName, definedTypes, stubs);

                // Scan return type
                if (!string.IsNullOrEmpty(method.ReturnTypeCpp))
                    TryAddValueTypeStub(method.ReturnTypeCpp, definedTypes, stubs);
            }
        }
    }

    private static void TryAddValueTypeStub(string cppType, HashSet<string> definedTypes, HashSet<string> stubs)
    {
        if (string.IsNullOrEmpty(cppType)) return;
        if (cppType.EndsWith("*")) return; // pointer types only need forward decl
        var rawType = cppType.Trim();
        if (rawType.Length == 0 || rawType.StartsWith("cil2cpp::") ||
            IsCppPrimitiveType(rawType)) return;
        if (definedTypes.Contains(rawType)) return;
        if (!IsValidCppIdentifier(rawType)) return;
        // Skip unresolved generic params (TChar, T1, etc.) — no underscore
        if (!rawType.Contains('_')) return;
        stubs.Add(rawType);
    }

    private static void CheckFieldForStub(string fieldTypeName, HashSet<string> definedTypes, HashSet<string> stubs)
    {
        var cppType = CppNameMapper.GetCppTypeForDecl(fieldTypeName);
        if (cppType.EndsWith("*")) return; // Pointers will be replaced with void*
        var rawType = cppType.Trim();
        if (rawType.Length == 0 || rawType.StartsWith("cil2cpp::") || IsCppPrimitiveType(rawType)) return;
        if (definedTypes.Contains(rawType)) return;
        if (!IsValidCppIdentifier(rawType)) return;
        stubs.Add(rawType);
    }

    /// <summary>
    /// Topologically sort struct types by value-type field dependencies.
    /// If struct A has a non-pointer field of type B, B must come before A.
    /// </summary>
    private static List<IRType> TopologicalSortByFieldDeps(List<IRType> types, HashSet<string> aliasedTypes)
    {
        var typeMap = new Dictionary<string, IRType>();
        foreach (var t in types)
            typeMap[t.CppName] = t;

        var visited = new HashSet<string>();
        var inStack = new HashSet<string>();
        var result = new List<IRType>();

        foreach (var t in types)
        {
            if (!visited.Contains(t.CppName))
                TopoVisit(t, typeMap, aliasedTypes, visited, inStack, result);
        }

        return result;
    }

    private static void TopoVisit(IRType type, Dictionary<string, IRType> typeMap,
        HashSet<string> aliasedTypes, HashSet<string> visited, HashSet<string> inStack,
        List<IRType> result)
    {
        if (visited.Contains(type.CppName)) return;
        if (inStack.Contains(type.CppName)) return; // Cycle — break it

        inStack.Add(type.CppName);

        // Collect all field types (own + inherited)
        var allFields = new List<string>();
        foreach (var f in type.Fields)
            allFields.Add(f.FieldTypeName);
        if (!type.IsValueType)
        {
            var inherited = CollectInheritedFields(type);
            foreach (var (f, _) in inherited)
                allFields.Add(f.FieldTypeName);
        }
        foreach (var f in type.StaticFields)
            allFields.Add(f.FieldTypeName);

        foreach (var fieldTypeName in allFields)
        {
            var cppType = CppNameMapper.GetCppTypeForDecl(fieldTypeName);
            if (cppType.EndsWith("*")) continue; // Pointers don't need ordering
            var rawType = cppType.Trim();
            if (rawType.StartsWith("cil2cpp::") || IsCppPrimitiveType(rawType)) continue;
            if (aliasedTypes.Contains(rawType)) continue;
            if (typeMap.TryGetValue(rawType, out var dep))
                TopoVisit(dep, typeMap, aliasedTypes, visited, inStack, result);
        }

        inStack.Remove(type.CppName);
        visited.Add(type.CppName);
        result.Add(type);
    }

    private static List<(IRField Field, IRType FromType)> CollectInheritedFields(IRType type)
    {
        var result = new List<(IRField, IRType)>();
        var ancestors = new List<IRType>();
        var current = type.BaseType;
        while (current != null && current.ILFullName != "System.Object")
        {
            ancestors.Add(current);
            current = current.BaseType;
        }
        ancestors.Reverse(); // furthest ancestor first
        foreach (var ancestor in ancestors)
        {
            foreach (var field in ancestor.Fields)
                result.Add((field, ancestor));
        }
        return result;
    }

    /// <summary>
    /// Returns true if any parameter or return type references a non-pointer struct not in the known type set.
    /// This filters out BCL methods that reference types not in the compilation unit (e.g. Func&lt;T&gt;).
    /// Pointer-type parameters only need forward declarations, which are generated automatically.
    /// </summary>
    private static bool HasUnknownParameterTypes(IRMethod method, HashSet<string> knownTypeNames)
    {
        // Check for function pointer types (IL function pointer types have "()" syntax in type names
        // or produce "method" prefix in mangled names)
        foreach (var param in method.Parameters)
        {
            if (param.CppTypeName.Contains("(") || param.CppTypeName.Contains(")")
                || param.CppTypeName.StartsWith("method"))
                return true;
        }
        if (method.ReturnTypeCpp.Contains("(") || method.ReturnTypeCpp.Contains(")")
            || method.ReturnTypeCpp.StartsWith("method"))
            return true;

        // Check return type
        if (!string.IsNullOrEmpty(method.ReturnTypeCpp))
        {
            var retType = method.ReturnTypeCpp;
            if (!IsValidCppIdentifier(retType.TrimEnd('*').Trim()) && !retType.StartsWith("cil2cpp::"))
                return true;
            var retTypeName = retType.TrimEnd('*').Trim();
            if (retTypeName.Length > 0 && !retTypeName.StartsWith("cil2cpp::") && !IsCppPrimitiveType(retTypeName))
            {
                if (IsUnresolvedGenericParam(retTypeName)) return true;
                if (!retType.EndsWith("*") && !knownTypeNames.Contains(retTypeName))
                    return true;
            }
        }
        foreach (var param in method.Parameters)
        {
            var rawType = param.CppTypeName;
            // Filter function pointer types (contain parentheses or "method" prefix)
            if (!IsValidCppIdentifier(rawType.TrimEnd('*').Trim()) && !rawType.StartsWith("cil2cpp::"))
                return true;
            var typeName = rawType.TrimEnd('*').Trim();
            // Skip known runtime types (cil2cpp:: namespace, primitive C++ types)
            if (typeName.StartsWith("cil2cpp::") || IsCppPrimitiveType(typeName)) continue;
            // Unresolved generic param names (TOther, TArg1, TNegator, etc.)
            if (IsUnresolvedGenericParam(typeName)) return true;
            // Pointer-type params: check for bare unresolved generic param names
            if (rawType.EndsWith("*"))
            {
                if (typeName.Length > 0 && !typeName.Contains('_') && !knownTypeNames.Contains(typeName))
                    return true;
                continue;
            }
            // Non-pointer unknown struct: the body would need the full type definition
            if (typeName.Length > 0 && !knownTypeNames.Contains(typeName))
                return true;
        }
        return false;
    }

    /// <summary>
    /// Check if method body references undefined non-pointer value types in locals.
    /// Methods with such references would produce C++ compilation errors (undefined struct).
    /// </summary>
    private static bool HasUnknownBodyReferences(IRMethod method, HashSet<string> knownTypeNames)
    {
        // Check local variables for references to undefined types
        foreach (var local in method.Locals)
        {
            var baseType = local.CppTypeName.TrimEnd('*').Trim();
            if (string.IsNullOrEmpty(baseType)) continue;
            if (baseType.StartsWith("cil2cpp::") || IsCppPrimitiveType(baseType)) continue;
            if (!knownTypeNames.Contains(baseType))
            {
                // For pointer types, only reject unresolved generic params (TChar, T1, TKey, etc.)
                // which are single-word identifiers without namespace underscores.
                // Other pointer locals reference real BCL/user types that may not have struct
                // definitions but only need forward declarations (which are auto-emitted).
                if (local.CppTypeName.EndsWith("*"))
                {
                    if (!baseType.Contains('_'))
                    {
                        return true; // unresolved generic param — reject
                    }
                    continue; // pointer to real type — forward decl or void* suffices
                }
                return true; // non-pointer value type must be fully defined
            }
        }

        // Check body instructions for references to undefined types
        foreach (var block in method.BasicBlocks)
        {
            foreach (var instr in block.Instructions)
            {
                if (HasUnknownInstructionReference(instr, knownTypeNames))
                    return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Check if a single instruction references an undefined type (struct, sizeof, function call).
    /// </summary>
    private static bool HasUnknownInstructionReference(IRInstruction instr, HashSet<string> knownTypeNames)
    {
        // IRNewObj: TypeCppName must be known (generates sizeof(TypeCppName))
        if (instr is IRNewObj newObj)
        {
            if (IsUnknownValueType(newObj.TypeCppName, knownTypeNames))
                return true;
        }

        // IRRawCpp: check for sizeof(TypeName) and TypeName local declarations
        if (instr is IRRawCpp rawCpp)
        {
            var code = rawCpp.Code;
            // Check sizeof(X) patterns
            int idx = 0;
            while ((idx = code.IndexOf("sizeof(", idx)) >= 0)
            {
                var start = idx + 7;
                var end = code.IndexOf(')', start);
                if (end > start)
                {
                    var typeName = code[start..end].Trim();
                    if (IsUnknownValueType(typeName, knownTypeNames))
                        return true;
                }
                idx = start;
            }
            // Check for value-type local declarations
            if (rawCpp.ResultTypeCpp != null && IsUnknownValueType(rawCpp.ResultTypeCpp, knownTypeNames))
                return true;
        }

        // NOTE: IRCall to unknown types is now handled by CallsUndeclaredOrMismatchedFunctions gate
        // (runs after HasUnknownBodyReferences). Checking here was redundant — if the function IS
        // declared in the header, the call compiles fine regardless of whether the declaring type's
        // struct definition exists in knownTypeNames. Free function calls only need the prototype.

        // IRCast: check TargetTypeCpp for unknown types (catches unresolved generic params T1/T2/TKey etc.)
        if (instr is IRCast cast)
        {
            if (IsUnknownTypeReference(cast.TargetTypeCpp, knownTypeNames))
                return true;
        }

        // Catch-all: scan the rendered C++ code for unresolved generic parameter names
        // These are single-word type names (no underscores) used in casts like (T1*), (TChar*), etc.
        var renderedCpp = instr.ToCpp();
        if (HasUnresolvedGenericParamInCode(renderedCpp, knownTypeNames))
            return true;

        // Check for unresolved function pointer types: methodXxx_ptr(...) patterns
        // These are IL delegate/function-pointer types that weren't resolved to proper C++ syntax.
        // Real IL func ptr types look like "methodSystem_Object_ptr(System_Void_ptr)*" —
        // they always have underscores in the type name part after "method".
        // Must NOT match variable names like "methodFlags", "methodHandleValue" (camelCase, no underscore).
        {
            int mIdx = 0;
            while ((mIdx = renderedCpp.IndexOf("method", mIdx)) >= 0)
            {
                var afterMethod = mIdx + 6;
                if (afterMethod < renderedCpp.Length && char.IsUpper(renderedCpp[afterMethod]))
                {
                    // Check that this isn't preceded by alphanumeric/underscore (word boundary)
                    if (mIdx > 0 && (char.IsLetterOrDigit(renderedCpp[mIdx - 1]) || renderedCpp[mIdx - 1] == '_'))
                    {
                        mIdx = afterMethod;
                        continue;
                    }
                    // Extract the token after "method" until non-alphanumeric/underscore
                    var tokenEnd = afterMethod;
                    while (tokenEnd < renderedCpp.Length && (char.IsLetterOrDigit(renderedCpp[tokenEnd]) || renderedCpp[tokenEnd] == '_'))
                        tokenEnd++;
                    var token = renderedCpp[afterMethod..tokenEnd];
                    // Real IL func ptr types always contain underscores (mangled type names)
                    // Variable names like "Flags", "HandleValue", "Context" don't
                    if (token.Contains('_'))
                        return true;
                }
                mIdx = afterMethod;
            }
        }

        return false;
    }

    /// <summary>
    /// Check if a type name references an undefined non-pointer value type.
    /// </summary>
    private static bool IsUnknownValueType(string typeRef, HashSet<string> knownTypeNames)
    {
        if (string.IsNullOrEmpty(typeRef)) return false;
        var typeName = typeRef.TrimEnd('*').Trim();
        if (string.IsNullOrEmpty(typeName)) return false;
        if (typeRef.EndsWith("*")) return false; // pointer types only need forward decl
        if (typeName.StartsWith("cil2cpp::") || IsCppPrimitiveType(typeName)) return false;
        return !knownTypeNames.Contains(typeName);
    }

    /// <summary>
    /// Check if a type reference (including pointer forms) refers to an unknown type.
    /// Unlike IsUnknownValueType, this also catches unresolved generic params in pointer form
    /// (e.g., T1*, TChar**, TKey*) which are single-word names with no namespace mangling.
    /// </summary>
    private static bool IsUnknownTypeReference(string typeRef, HashSet<string> knownTypeNames)
    {
        if (string.IsNullOrEmpty(typeRef)) return false;
        var baseType = typeRef.TrimEnd('*').Trim();
        if (string.IsNullOrEmpty(baseType)) return false;
        if (baseType.StartsWith("cil2cpp::") || IsCppPrimitiveType(baseType)) return false;
        if (knownTypeNames.Contains(baseType)) return false;
        // Unknown base type — could be an unresolved generic param (TChar, T1, TKey, etc.)
        // These are single-word identifiers without namespace underscores.
        // Regular mangled types always have underscores (System_Int32, MyNs_MyType, etc.)
        if (!baseType.Contains('_')) return true;
        // For pointer types, the base type is unknown but looks like a mangled type name
        // — that's OK, it just needs a forward declaration
        if (typeRef.EndsWith("*")) return false;
        // Non-pointer unknown type — must be fully defined
        return true;
    }

    /// <summary>
    /// Scan rendered C++ code for unresolved generic parameter names in cast expressions.
    /// Looks for patterns like (T1*), (TChar*), (TKey*) where the type name is a single word
    /// without underscores (indicating it's a generic param, not a mangled namespace type).
    /// </summary>
    private static bool HasUnresolvedGenericParamInCode(string code, HashSet<string> knownTypeNames)
    {
        // Scan for cast patterns: (TypeName*) or (TypeName)
        int i = 0;
        while (i < code.Length)
        {
            if (code[i] == '(' && i + 1 < code.Length && char.IsUpper(code[i + 1]))
            {
                // Found '(' followed by uppercase — could be a cast
                int start = i + 1;
                int end = start;
                while (end < code.Length && (char.IsLetterOrDigit(code[end]) || code[end] == '_'))
                    end++;
                // Strip trailing * for pointer casts
                int nameEnd = end;
                while (nameEnd < code.Length && code[nameEnd] == '*') nameEnd++;
                if (nameEnd < code.Length && code[nameEnd] == ')')
                {
                    var typeName = code[start..end];
                    // Single-word uppercase name without underscores = likely unresolved generic param
                    if (typeName.Length >= 1 && !typeName.Contains('_')
                        && !IsCppPrimitiveType(typeName) && typeName != "Object"
                        && !knownTypeNames.Contains(typeName))
                        return true;
                }
            }
            i++;
        }
        return false;
    }

    /// <summary>
    /// Check if a function call targets a method on a type not in knownTypeNames.
    /// Function names follow the pattern TypeCppName_MethodName or TypeCppName__MethodName.
    /// </summary>
    private static bool IsCallToUnknownType(string functionName, HashSet<string> knownTypeNames)
    {
        // Try to find the type prefix: scan from right, try each underscore position
        // as a potential type/method separator
        for (int i = functionName.Length - 1; i >= 0; i--)
        {
            if (functionName[i] != '_') continue;
            var prefix = functionName[..i];
            if (string.IsNullOrEmpty(prefix)) continue;
            // Check if this prefix is a known type (with or without trailing underscore).
            // Generic type CppNames end with '_' from '>' mangling (e.g., EqualityComparer_1_System_Int32_),
            // but function name prefixes don't include that trailing '_'.
            if (knownTypeNames.Contains(prefix))
                return false; // found known type — call is valid
            if (prefix.EndsWith("_") && knownTypeNames.Contains(prefix.TrimEnd('_')))
                return false;
            // Also check with trailing underscore added (generic type name mangling)
            if (knownTypeNames.Contains(prefix + "_"))
                return false;
        }
        // No known type prefix found — this targets an unknown type
        return true;
    }

    private static bool IsCppPrimitiveType(string typeName)
    {
        return typeName is "bool" or "int8_t" or "uint8_t" or "int16_t" or "uint16_t"
            or "int32_t" or "uint32_t" or "int64_t" or "uint64_t" or "float" or "double"
            or "char16_t" or "intptr_t" or "uintptr_t" or "void";
    }

    /// <summary>
    /// Get the size in bytes of a C++ primitive type name.
    /// Returns 0 for unknown / non-primitive types.
    /// </summary>
    private static int GetPrimitiveSize(string cppType)
    {
        return cppType switch
        {
            "bool" or "int8_t" or "uint8_t" => 1,
            "int16_t" or "uint16_t" or "char16_t" => 2,
            "int32_t" or "uint32_t" or "float" => 4,
            "int64_t" or "uint64_t" or "double" => 8,
            "intptr_t" or "uintptr_t" => 8, // 64-bit assumption
            _ => 0,
        };
    }

    /// <summary>
    /// Get using aliases for runtime-provided types (mangled name → cil2cpp:: struct).
    /// </summary>
    private static IEnumerable<(string Mangled, string CppAlias)> GetRuntimeProvidedTypeAliases()
    {
        // Core runtime types
        yield return ("System_Object", "cil2cpp::Object");
        yield return ("System_String", "cil2cpp::String");
        yield return ("System_Array", "cil2cpp::Array");
        yield return ("System_Delegate", "cil2cpp::Delegate");
        yield return ("System_MulticastDelegate", "cil2cpp::Delegate");
        yield return ("System_Type", "cil2cpp::Object");  // Type represented as opaque pointer
        yield return ("System_RuntimeType", "cil2cpp::Type");  // Phase I.2: RuntimeType = Type (Unity IL2CPP pattern)
        yield return ("System_Attribute", "cil2cpp::Object");  // Base class for all attributes
        yield return ("System_Enum", "cil2cpp::Object");  // Abstract base for enums — same layout as Object
        yield return ("System_ValueType", "cil2cpp::Object");  // Abstract base for value types — same layout as Object

        // Exception hierarchy — all map to runtime C++ exception types
        yield return ("System_Exception", "cil2cpp::Exception");
        yield return ("System_NullReferenceException", "cil2cpp::NullReferenceException");
        yield return ("System_IndexOutOfRangeException", "cil2cpp::IndexOutOfRangeException");
        yield return ("System_InvalidCastException", "cil2cpp::InvalidCastException");
        yield return ("System_InvalidOperationException", "cil2cpp::InvalidOperationException");
        yield return ("System_ObjectDisposedException", "cil2cpp::ObjectDisposedException");
        yield return ("System_NotSupportedException", "cil2cpp::NotSupportedException");
        yield return ("System_PlatformNotSupportedException", "cil2cpp::PlatformNotSupportedException");
        yield return ("System_NotImplementedException", "cil2cpp::NotImplementedException");
        yield return ("System_ArgumentException", "cil2cpp::ArgumentException");
        yield return ("System_ArgumentNullException", "cil2cpp::ArgumentNullException");
        yield return ("System_ArgumentOutOfRangeException", "cil2cpp::ArgumentOutOfRangeException");
        yield return ("System_ArithmeticException", "cil2cpp::ArithmeticException");
        yield return ("System_OverflowException", "cil2cpp::OverflowException");
        yield return ("System_DivideByZeroException", "cil2cpp::DivideByZeroException");
        yield return ("System_FormatException", "cil2cpp::FormatException");
        yield return ("System_RankException", "cil2cpp::RankException");
        yield return ("System_ArrayTypeMismatchException", "cil2cpp::ArrayTypeMismatchException");
        yield return ("System_TypeInitializationException", "cil2cpp::TypeInitializationException");
        yield return ("System_TimeoutException", "cil2cpp::TimeoutException");
        yield return ("System_AggregateException", "cil2cpp::AggregateException");
        yield return ("System_OperationCanceledException", "cil2cpp::OperationCanceledException");
        yield return ("System_Threading_Tasks_TaskCanceledException", "cil2cpp::TaskCanceledException");
        yield return ("System_Collections_Generic_KeyNotFoundException", "cil2cpp::KeyNotFoundException");

        // Phase II.3: Runtime reflection subtypes → existing runtime structs
        yield return ("System_Reflection_RuntimeMethodInfo", "cil2cpp::ManagedMethodInfo");
        yield return ("System_Reflection_RuntimeFieldInfo", "cil2cpp::ManagedFieldInfo");
        yield return ("System_Reflection_RuntimeConstructorInfo", "cil2cpp::ManagedMethodInfo");
        yield return ("System_Reflection_TypeInfo", "cil2cpp::Type");
        // Phase II.4: New runtime structs for Assembly + PropertyInfo
        yield return ("System_Reflection_RuntimePropertyInfo", "cil2cpp::ManagedPropertyInfo");
        yield return ("System_Reflection_Assembly", "cil2cpp::ManagedAssembly");
        yield return ("System_Reflection_RuntimeAssembly", "cil2cpp::ManagedAssembly");
        // Phase II.5: WaitHandle hierarchy
        yield return ("System_Threading_WaitHandle", "cil2cpp::ManagedWaitHandle");
        yield return ("System_Threading_EventWaitHandle", "cil2cpp::ManagedEventWaitHandle");
        yield return ("System_Threading_ManualResetEvent", "cil2cpp::ManagedEventWaitHandle");
        yield return ("System_Threading_AutoResetEvent", "cil2cpp::ManagedEventWaitHandle");
        yield return ("System_Threading_Mutex", "cil2cpp::ManagedMutex");
        yield return ("System_Threading_Semaphore", "cil2cpp::ManagedSemaphore");
    }

    /// <summary>
    /// Get using aliases for primitive types (mangled name → C++ built-in type).
    /// Primitive types map directly to C++ built-in types; no struct is emitted.
    /// </summary>
    private static IEnumerable<(string Mangled, string CppAlias)> GetPrimitiveTypeAliases()
    {
        yield return ("System_Boolean", "bool");
        yield return ("System_Byte", "uint8_t");
        yield return ("System_SByte", "int8_t");
        yield return ("System_Int16", "int16_t");
        yield return ("System_UInt16", "uint16_t");
        yield return ("System_Int32", "int32_t");
        yield return ("System_UInt32", "uint32_t");
        yield return ("System_Int64", "int64_t");
        yield return ("System_UInt64", "uint64_t");
        yield return ("System_Single", "float");
        yield return ("System_Double", "double");
        yield return ("System_Char", "char16_t");
        yield return ("System_IntPtr", "intptr_t");
        yield return ("System_UIntPtr", "uintptr_t");
    }

    /// <summary>
    /// Types whose "using System_X = cil2cpp::Y;" alias is already defined in runtime headers
    /// (task.h, memberinfo.h, cancellation.h, async_enumerable.h).
    /// The codegen must NOT emit struct definitions OR using aliases for these —
    /// the runtime headers handle both.
    /// </summary>
    private static readonly HashSet<string> RuntimeHeaderAliasedTypes = new()
    {
        // task.h
        "System_Threading_Tasks_Task",
        "System_Runtime_CompilerServices_TaskAwaiter",
        "System_Runtime_CompilerServices_AsyncTaskMethodBuilder",
        "System_Runtime_CompilerServices_IAsyncStateMachine",
        // memberinfo.h
        "System_Reflection_MemberInfo",
        "System_Reflection_MethodBase",
        "System_Reflection_MethodInfo",
        "System_Reflection_FieldInfo",
        "System_Reflection_ParameterInfo",
        // cancellation.h
        "System_Threading_CancellationTokenSource",
        "System_Threading_CancellationToken",
        // async_enumerable.h
        "System_Threading_Tasks_ValueTask",
        "System_Runtime_CompilerServices_ValueTaskAwaiter",
        "System_Runtime_CompilerServices_AsyncIteratorMethodBuilder",
        // threading.h — ManagedThread is in cil2cpp namespace but no using alias;
        // still needs to be skipped since runtime defines the struct
        "System_Threading_Thread",
        // typed_reference.h
        "System_TypedReference",
        "System_ArgIterator",
        // Phase II.3: Runtime reflection subtypes — aliases in memberinfo.h / reflection.h
        "System_Reflection_RuntimeMethodInfo",
        "System_Reflection_RuntimeFieldInfo",
        "System_Reflection_RuntimeConstructorInfo",
        "System_Reflection_TypeInfo",
        // Phase II.4: Assembly + PropertyInfo — aliases in assembly.h
        "System_Reflection_RuntimePropertyInfo",
        "System_Reflection_Assembly",
        "System_Reflection_RuntimeAssembly",
        // Phase II.5: WaitHandle hierarchy — aliases in waithandle.h
        "System_Threading_WaitHandle",
        "System_Threading_EventWaitHandle",
        "System_Threading_ManualResetEvent",
        "System_Threading_AutoResetEvent",
        "System_Threading_Mutex",
        "System_Threading_Semaphore",
    };

    /// <summary>
    /// Get TypeInfo reference aliases for runtime exception types.
    /// Maps mangled IL names (System_Exception) to runtime-declared TypeInfo names (cil2cpp::Exception_TypeInfo).
    /// Used by castclass/isinst/catch to reference exception TypeInfos by their mangled names.
    /// </summary>
    private static IEnumerable<(string MangledName, string RuntimeTypeInfoName)> GetExceptionTypeInfoAliases()
    {
        yield return ("System_Exception", "cil2cpp::Exception_TypeInfo");
        yield return ("System_NullReferenceException", "cil2cpp::NullReferenceException_TypeInfo");
        yield return ("System_IndexOutOfRangeException", "cil2cpp::IndexOutOfRangeException_TypeInfo");
        yield return ("System_InvalidCastException", "cil2cpp::InvalidCastException_TypeInfo");
        yield return ("System_InvalidOperationException", "cil2cpp::InvalidOperationException_TypeInfo");
        yield return ("System_ObjectDisposedException", "cil2cpp::ObjectDisposedException_TypeInfo");
        yield return ("System_NotSupportedException", "cil2cpp::NotSupportedException_TypeInfo");
        yield return ("System_PlatformNotSupportedException", "cil2cpp::PlatformNotSupportedException_TypeInfo");
        yield return ("System_NotImplementedException", "cil2cpp::NotImplementedException_TypeInfo");
        yield return ("System_ArgumentException", "cil2cpp::ArgumentException_TypeInfo");
        yield return ("System_ArgumentNullException", "cil2cpp::ArgumentNullException_TypeInfo");
        yield return ("System_ArgumentOutOfRangeException", "cil2cpp::ArgumentOutOfRangeException_TypeInfo");
        yield return ("System_ArithmeticException", "cil2cpp::ArithmeticException_TypeInfo");
        yield return ("System_OverflowException", "cil2cpp::OverflowException_TypeInfo");
        yield return ("System_DivideByZeroException", "cil2cpp::DivideByZeroException_TypeInfo");
        yield return ("System_FormatException", "cil2cpp::FormatException_TypeInfo");
        yield return ("System_RankException", "cil2cpp::RankException_TypeInfo");
        yield return ("System_ArrayTypeMismatchException", "cil2cpp::ArrayTypeMismatchException_TypeInfo");
        yield return ("System_TypeInitializationException", "cil2cpp::TypeInitializationException_TypeInfo");
        yield return ("System_TimeoutException", "cil2cpp::TimeoutException_TypeInfo");
        yield return ("System_AggregateException", "cil2cpp::AggregateException_TypeInfo");
        yield return ("System_OperationCanceledException", "cil2cpp::OperationCanceledException_TypeInfo");
        yield return ("System_Threading_Tasks_TaskCanceledException", "cil2cpp::TaskCanceledException_TypeInfo");
        yield return ("System_Collections_Generic_KeyNotFoundException", "cil2cpp::KeyNotFoundException_TypeInfo");
    }

    /// <summary>
    /// Runtime-provided base types that need stub TypeInfo definitions in generated code.
    /// These are referenced as .base_type for value types, enums, and delegates.
    /// </summary>
    private static IEnumerable<(string MangledName, string ILFullName)> GetRuntimeBaseTypeInfoStubs()
    {
        yield return ("System_ValueType", "System.ValueType");
        yield return ("System_Enum", "System.Enum");
        yield return ("System_MulticastDelegate", "System.MulticastDelegate");
        yield return ("System_Delegate", "System.Delegate");
    }

    /// <summary>
    /// Scan all method bodies for function calls, and generate stub declarations
    /// for any called function that wasn't declared. This handles methods on
    /// RuntimeProvided types and types not in the IR module.
    /// </summary>
    private void GenerateMissingMethodStubs(StringBuilder sb, HashSet<string> emittedMethodDecls,
        List<IR.IRType> userTypes, HashSet<string> knownTypeNames)
    {
        // Build lookup: method CppName → IRMethod (for finding signatures)
        var methodLookup = new Dictionary<string, IR.IRMethod>();
        foreach (var type in _module.Types)
        {
            foreach (var method in type.Methods)
            {
                methodLookup.TryAdd(method.CppName, method);
            }
        }

        // Collect all called function names from method bodies that WILL be compiled.
        // Only scan methods that pass the same filters as method implementation generation.
        var calledFunctions = new HashSet<string>();
        foreach (var type in userTypes)
        {
            if (type.IsDelegate || type.IsRuntimeProvided) continue;
            foreach (var method in type.Methods)
            {
                if (method.IsAbstract || method.IsInternalCall) continue;
                if (method.BasicBlocks.Count == 0 && !method.IsPInvoke) continue;
                // Only check methods that will actually be emitted
                if (!emittedMethodDecls.Contains(method.GetCppSignature())) continue;

                foreach (var block in method.BasicBlocks)
                {
                    foreach (var instr in block.Instructions)
                    {
                        if (instr is IR.IRCall call && !string.IsNullOrEmpty(call.FunctionName)
                            && !call.FunctionName.StartsWith("cil2cpp::"))
                            calledFunctions.Add(call.FunctionName);
                    }
                }
            }
        }

        // Find called functions that have no declaration
        var declaredNames = new HashSet<string>();
        foreach (var sig in emittedMethodDecls)
        {
            // Extract function name from signature: "retType funcName(..."
            var parenIdx = sig.IndexOf('(');
            if (parenIdx > 0)
            {
                var beforeParen = sig[..parenIdx].TrimEnd();
                var spaceIdx = beforeParen.LastIndexOf(' ');
                if (spaceIdx >= 0)
                    declaredNames.Add(beforeParen[(spaceIdx + 1)..]);
                // Handle pointer return types: "retType* funcName("
                var starIdx = beforeParen.LastIndexOf('*');
                if (starIdx > spaceIdx)
                    declaredNames.Add(beforeParen[(starIdx + 1)..].TrimStart());
            }
        }

        var missingFunctions = new List<(string name, IR.IRMethod? method)>();
        foreach (var funcName in calledFunctions)
        {
            if (declaredNames.Contains(funcName)) continue;
            methodLookup.TryGetValue(funcName, out var irMethod);
            missingFunctions.Add((funcName, irMethod));
        }

        if (missingFunctions.Count == 0) return;

        sb.AppendLine("// ===== Stub Declarations (methods on RuntimeProvided or unreachable types) =====");
        foreach (var (funcName, irMethod) in missingFunctions.OrderBy(m => m.name))
        {
            if (irMethod != null && !HasUnknownParameterTypes(irMethod, knownTypeNames))
            {
                var sig = irMethod.GetCppSignature();
                if (emittedMethodDecls.Add(sig))
                {
                    sb.AppendLine($"{sig};");
                    declaredNames.Add(funcName);
                }
            }
            else
            {
                // Unknown or complex signature — skip, will cause linker error if actually needed.
                // This is better than a compile error that blocks all other compilation.
            }
        }
        sb.AppendLine();
    }

    private void GenerateEnumDefinition(StringBuilder sb, IRType type)
    {
        var underlyingCppType = CppNameMapper.GetCppTypeForDecl(type.EnumUnderlyingType ?? "System.Int32");
        sb.AppendLine($"// {type.ILFullName} (enum)");
        sb.AppendLine($"using {type.CppName} = {underlyingCppType};");

        // Emit named constants
        foreach (var field in type.StaticFields)
        {
            if (field.ConstantValue != null)
            {
                sb.AppendLine($"constexpr {underlyingCppType} {type.CppName}_{field.CppName} = {field.ConstantValue};");
            }
        }
        sb.AppendLine();
    }

    /// <summary>
    /// Extract function names from C++ method signatures.
    /// Signature format: "retType funcName(params)" → extract "funcName".
    /// </summary>
    private static HashSet<string> ExtractFunctionNamesFromSignatures(HashSet<string> signatures)
    {
        var names = new HashSet<string>();
        foreach (var sig in signatures)
        {
            var parenIdx = sig.IndexOf('(');
            if (parenIdx <= 0) continue;

            var beforeParen = sig[..parenIdx].TrimEnd();
            var spaceIdx = beforeParen.LastIndexOf(' ');
            if (spaceIdx >= 0)
            {
                var name = beforeParen[(spaceIdx + 1)..];
                // Handle pointer return types: "retType* funcName"
                if (name.StartsWith("*"))
                    name = name.TrimStart('*');
                if (!string.IsNullOrEmpty(name))
                    names.Add(name);
            }
        }
        return names;
    }

    /// <summary>
    /// Check if a method's body calls functions that are not declared in the output,
    /// or calls functions with wrong number of arguments (overload mismatch).
    /// </summary>
    private bool CallsUndeclaredOrMismatchedFunctions(IR.IRMethod method)
    {
        if (_declaredFunctionNames.Count == 0) return false;

        foreach (var block in method.BasicBlocks)
        {
            foreach (var instr in block.Instructions)
            {
                if (instr is IR.IRCall call && !string.IsNullOrEmpty(call.FunctionName))
                {
                    var funcName = call.FunctionName;
                    if (funcName.StartsWith("cil2cpp::")) continue;
                    if (funcName.EndsWith("_ensure_cctor")) continue;
                    if (!_declaredFunctionNames.Contains(funcName))
                        return true;
                    if (_declaredFunctionParamCounts.TryGetValue(funcName, out var validCounts))
                    {
                        if (!validCounts.Contains(call.Arguments.Count))
                            return true;
                    }
                }
            }
        }
        return false;
    }

    /// <summary>
    /// Check if a method's rendered C++ body contains patterns known to cause MSVC errors.
    /// This is a post-IR check that catches issues not detectable at the IR level.
    /// </summary>
    private bool HasKnownBrokenPatterns(IR.IRMethod method, HashSet<string> knownTypeNames)
    {
        // JIT intrinsics have self-recursive IL bodies — the JIT replaces them with
        // CPU instructions or constants at runtime. AOT: detect and stub them.
        // Covers ALL System.Runtime.Intrinsics types including Vector base types.
        // Vector struct definitions are needed (for knownTypeNames) but their method bodies
        // contain SIMD-specific patterns (void* arithmetic, pointer casts) that can't compile.
        // Call sites are already intercepted in IRBuilder.Emit.cs (IsSupported=0, ops=default).
        if (method.DeclaringType?.ILFullName?.Contains("System.Runtime.Intrinsics") == true)
            return true;
        // SIMD-specific BCL method variants: hardware-accelerated implementations that contain
        // pointer arithmetic, alignment checks, and SIMD operations that can't compile to valid C++.
        // These methods have scalar fallback alternatives that the BCL dispatches to when IsSupported==false.
        if (method.Name.EndsWith("_Sse2") || method.Name.EndsWith("_Sse41") ||
            method.Name.EndsWith("_Sse3") || method.Name.EndsWith("_Avx") ||
            method.Name.EndsWith("_Avx2") || method.Name.EndsWith("_Intrinsified"))
            return true;
        // SIMD-heavy BCL internal types whose methods do pointer-to-integer casts for alignment checks
        if (method.DeclaringType?.ILFullName is "System.Text.Ascii"
                                              or "System.Text.Latin1Utility"
                                              or "System.Text.Utf16Utility"
                                              or "System.Buffers.IndexOfAnyAsciiSearcher")
            return true;
        // NOTE: Self-recursion check removed — it was catching legitimate recursive
        // algorithms (IntroSort, FormatCustomized, String.Concat, etc.), not JIT intrinsics.
        // JIT intrinsics are already caught by System.Runtime.Intrinsics namespace check above.

        // Numerics interface DIM (Default Interface Methods) — struct operator implementations
        // like IBitwiseOperators<byte,byte,byte>.op_BitwiseOr. The actual operators are already
        // inlined by the C# compiler at call sites; these DIM bodies are dead code that references
        // struct members unavailable in flat struct model.
        // REMOVED: Numerics DIM check was too broad — methods now tested through remaining gates
        // if (method.DeclaringType?.IsInterface == true &&
        //     (method.DeclaringType.ILFullName?.StartsWith("System.Numerics.I") == true || ...))
        //     return true;

        // VectorMath — hardware SIMD helper, same as System.Runtime.Intrinsics
        if (method.DeclaringType?.ILFullName == "System.Numerics.VectorMath")
            return true;

        // Methods taking Vector128/256/512 value parameters — their bodies use SIMD operations
        // that require hardware intrinsics. Examples: SpanHelpers.ComputeFirstIndex,
        // PackedSpanHelpers.ComputeFirstIndex, SpanHelpers.UnalignedCountVector128.
        // Only match direct Vector types (not generic types parameterized with Vector).
        foreach (var param in method.Parameters)
        {
            if (param.Name == "__this") continue;
            var pt = param.CppTypeName.TrimEnd('*');
            if (pt.StartsWith("System_Runtime_Intrinsics_Vector128_1_") ||
                pt.StartsWith("System_Runtime_Intrinsics_Vector256_1_") ||
                pt.StartsWith("System_Runtime_Intrinsics_Vector512_1_"))
                return true;
        }

        // MethodBaseInvoker — uses RuntimeMethodHandle.InvokeMethod (CLR JIT infrastructure),
        // InvokerStrategy enum pointers, and boxing patterns that require JIT codegen.
        // All 8+ methods (ctor, InterpretedInvoke_*, InvokeWith*, InvokePropertySetter, InvokeDirectByRef)
        // are fundamentally AOT-incompatible.
        if (method.DeclaringType?.ILFullName == "System.Reflection.MethodBaseInvoker")
            return true;

        // SpanHelpers pointer alignment methods — use bitwise AND on pointers (C2296)
        // and vector/SIMD intrinsics for memory alignment calculations.
        if (method.DeclaringType?.ILFullName == "System.SpanHelpers" &&
            (method.Name == "IndexOfNullByte" || method.Name == "IndexOfNullCharacter" ||
             method.Name == "UnalignedCountVector128"))
            return true;

        // Thread CLR internals — reference f_priority, f_DONT_USE_InternalThread, and other
        // CoreCLR-internal fields not present in our ManagedThread struct.
        if (method.DeclaringType?.ILFullName == "System.Threading.Thread" &&
            method.Name is "StartCore" or "GetNativeHandle" or "ThreadNameChanged")
            return true;

        // RuntimeMethodInfoStub constructors — reference RuntimeMethodHandle fields not in our model
        if (method.DeclaringType?.ILFullName == "System.RuntimeMethodInfoStub" && method.Name == ".ctor")
            return true;

        // ConcurrentQueue.Segment — REMOVED: tested through remaining gates
        // Reflection.Pointer — REMOVED: tested through remaining gates
        // IntPtr/UIntPtr method definitions — REMOVED: tested through remaining gates
        // RuntimeParameterInfo .ctor — REMOVED: tested through remaining gates

        // Encoding GetCharsWithFallback — REMOVED: tested through remaining gates

        // ConditionalWeakTable Container.Finalize/Resize and CWT.ctor — REMOVED: MdArray** field access
        // was flagged as KBP but methods now tested through remaining gates

        // SharedArrayPool.Rent — REMOVED: ConditionalWeakTable + AsyncLocal — now tested through remaining gates

        // Globalization NLS methods — REMOVED: tested through remaining gates
        // CalendarData — REMOVED: tested through remaining gates
        // ResourceReader/RuntimeResourceSet — REMOVED: tested through remaining gates
        // Interop P/Invoke — REMOVED: tested through remaining gates
        // Interop/Kernel32 — REMOVED: tested through remaining gates

        // Globalization CultureData P/Invoke — REMOVED: tested through remaining gates

        // TimeSpanFormat.Format/FormatC/FormatG — REMOVED: these are stubs, calls to them compile fine.
        // The "wrong argument ordering" comment was from a false positive in RenderedLineHasError.

        // Number.FormatFixed/NumberToStringFormat — REMOVED: ValueListBuilder calls compile correctly.
        // Callers already pass correct this pointers; the false positive was from the line-level check.

        // Globalization InvariantModeCasing.ToLower/ToUpper — REMOVED: Span struct ↔ void* conversion
        // was flagged as KBP but methods compile correctly after code gen improvements

        // Globalization TextInfo.ToLowerAsciiInvariant — REMOVED: Span struct conversion
        // was flagged as KBP but method compiles correctly now

        // CancellationTokenSource.ExecuteCallbackHandlers — REMOVED: tested through remaining gates

        // TimeZoneInfo.GetLocalizedNameByMuiNativeResource — REMOVED: tested through remaining gates

        // OperationCanceledException.get_CancellationToken — REMOVED: tested through remaining gates

        // Buffers search methods — REMOVED: tested through remaining gates
        // CultureData.InitIcuCultureDataCore — REMOVED: tested through remaining gates

        // HashCode.GenerateGlobalSeed / Marvin.GenerateSeed → now have ICalls (removed KBP)
        // Marshal.StringToCoTaskMemUni → now has ICall (removed KBP)
        // RuntimeTypeHandle .ctor → now has ICall (removed KBP)

        // NativeLibrary.GetSymbol — REMOVED: tested through remaining gates
        // RandomizedStringEqualityComparer .ctor — REMOVED: tested through remaining gates
        // XoshiroImpl .ctor — REMOVED: tested through remaining gates
        // DateTimeFormatInfoScanner.ArrayElementsHaveSpace — REMOVED: tested through remaining gates

        // ExecutionContext.SetLocalValue — REMOVED: tested through remaining gates

        // IO.UnmanagedMemoryStream.Initialize — fixed: pointer→integer now uses C-style cast
        // Math.CopySign → now has ICall (removed KBP)

        // GuidResult.SetFailure — REMOVED: body-level dot-access check handles any remaining issues.
        // Method-level KBP was overly broad (blocked even after root cause fix).

        // CultureInfo.set_CurrentCulture/CurrentUICulture — REMOVED: tested through remaining gates

        // StringBuilder.set_Length — REMOVED: tested through remaining gates

        // ConstArray.get_Item — REMOVED: tested through remaining gates
        // CustomAttribute.GetPropertyOrFieldData — REMOVED: tested through remaining gates
        // CustomAttributeTypedArgument.CanonicalizeValue — REMOVED: tested through remaining gates
        // MdFieldInfo.Equals/CacheEquals — REMOVED: tested through remaining gates
        // RtFieldInfo.Equals — REMOVED: tested through remaining gates

        // Number.FormatFixed/NumberToStringFormat — REMOVED: ValueListBuilder calls compile correctly
        // (false positive was from the line-level check, callers already pass correct this pointers)

        // MemoryExtensions.Equals/StartsWith — REMOVED: Span struct ↔ void* conversion
        // was flagged as KBP but methods compile correctly now

        // DefaultInterpolatedStringHandler — REMOVED: ExceptionHandlingClauseOptions TypeInfo
        // was undeclared but methods now pass through correctly after gate improvements

        // RuntimeType.SplitName — FIXED: string_length false positive resolved (knownStringTemps now includes param-derived temps)
        // REMOVED KBP check

        // MemberInfoCache<RuntimeType>.AddMethod — REMOVED: tested through remaining gates

        // Span<KeyValuePair<IAsyncLocal,Object>>.ctor — REMOVED: forward-declared type field access
        // was flagged as KBP but methods should pass through correctly now

        // TimeSpan — ALL methods now compile:
        // - void*→intptr_t FIXED by IRConversion SourceCppType (C-style cast)
        // - ldsflda pointer tracking FIXED by StackEntry CppType propagation
        // - TimeSpanFormat_FormatC/FormatG false positive REMOVED from RenderedLineHasError

        foreach (var block in method.BasicBlocks)
        {
            foreach (var instr in block.Instructions)
            {
                if (InstructionHasBrokenPattern(instr, knownTypeNames))
                    return true;
            }
        }
        return false;
    }

    private static bool InstructionHasBrokenPattern(IR.IRInstruction instr, HashSet<string> knownTypeNames)
    {
        var code = instr.ToCpp();

        // Pattern 0: TypeHandle/MethodTable JIT internals — CLR runtime structures with no AOT equivalent.
        // These access CoreCLR-internal fields (m_asTAddr, ComponentSize, BaseSize) or call
        // TypeHandle constructors. Moved from RenderedLineHasError to pre-render gate for
        // accurate classification as KnownBrokenPattern instead of RenderedBodyError.
        if (code.Contains("f_m_asTAddr") || code.Contains("TypeHandle__ctor(") ||
            code.Contains("TypeHandle_TypeHandleOf") ||
            code.Contains("f_ComponentSize") || code.Contains("f_BaseSize") ||
            (code.Contains("f_Flags") && code.Contains("MethodTable")))
            return true;

        // Pattern 1: References to _TypeInfo that are not declared
        if (HasUndeclaredTypeInfoRef(code, knownTypeNames))
            return true;

        // Pattern 2: (uintptr_t) cast followed by struct field access
        if (code.Contains("(uintptr_t)(") && code.Contains(".f_"))
            return true;

        // NOTE: volatile_write((bool*)) check removed — the runtime template volatile_write<T>
        // correctly deduces T=bool from (bool*) parameter. MSVC compiles this fine.

        // Pattern 4: removed — Unsafe specializations now compile as valid C++ functions.
        // Callers of broken Unsafe stubs are caught by stage 3 (CallsUndeclaredOrMismatchedFunctions).

        // Pattern 5: array_get/array_set/array_length called with non-Array argument
        if (code.Contains("array_length(0)"))
            return true;

        // Pattern 6: removed

        // Pattern 7: Invalid stind pattern: &param = &local (address-of on both sides)
        if (code.StartsWith("&") && code.Contains(" = &"))
            return true;

        // NOTE: GCFrameRegistration__ctor check removed — let trial render catch actual errors.
        // GCFrameRegistration is a no-op in BoehmGC AOT, and the struct is opaque.

        // Pattern 8: (uintptr_t) cast ONLY when combined with struct member access
        // Standalone (uintptr_t)(ptr) is valid C++ for pointer→int conversion (e.g., fixed/Span)
        // Pattern 2 already catches (uintptr_t)( + .f_ — this catches additional struct patterns
        if (code.Contains("(uintptr_t)(") && (code.Contains("->f_") || code.Contains("sizeof(")))
            return true;

        // Pattern 9: Unresolved generic type params in interface vtable casts
        if (code.Contains("_1_T*") || code.Contains("_1_T,") || code.Contains("_2_T*")
            || code.Contains("_1_TKey*") || code.Contains("_1_TValue*")
            || code.Contains("_1_TResult*")
            || code.Contains("_1_TFrom") || code.Contains("_1_TTo"))
            return true;

        return false;
    }

    private static bool HasUndeclaredTypeInfoRef(string code, HashSet<string> knownTypeNames)
    {
        var tiIdx = 0;
        while ((tiIdx = code.IndexOf("_TypeInfo", tiIdx)) >= 0)
        {
            // Walk backward to find the type name
            int start = tiIdx - 1;
            while (start >= 0 && (char.IsLetterOrDigit(code[start]) || code[start] == '_'))
                start--;
            start++;
            if (start < tiIdx)
            {
                var typeName = code[start..tiIdx];
                // Skip cil2cpp:: prefixed TypeInfo refs
                if (start >= 2 && code.Length >= start && start >= 2
                    && code[(start - 2)..start] == "::")
                {
                    tiIdx += 9;
                    continue;
                }
                if (!string.IsNullOrEmpty(typeName) && !typeName.StartsWith("cil2cpp")
                    && !knownTypeNames.Contains(typeName))
                {
                    // Handle types whose name ENDS with "TypeInfo" (e.g., System.Reflection.TypeInfo).
                    // The TypeInfo variable would be System_Reflection_TypeInfo_TypeInfo, and we found
                    // the first _TypeInfo (which is part of the type name, not the suffix).
                    // Check if typeName + "_TypeInfo" is a known type — if so, skip this occurrence.
                    if (knownTypeNames.Contains(typeName + "_TypeInfo"))
                    {
                        tiIdx += 9;
                        continue;
                    }
                    return true;
                }
            }
            tiIdx += 9;
        }
        return false;
    }

    /// <summary>
    /// Post-render validation: scan the fully rendered C++ body for patterns
    /// that will cause MSVC compilation errors. Used as a final safety net
    /// after all IR-level checks have passed.
    /// Returns null if no errors, or a reason string describing the detected error.
    /// </summary>
    private string? GetRenderedBodyErrorReason(string rendered, IR.IRMethod method, HashSet<string>? knownTypes = null)
    {
        // Method-level check: __this referenced in static methods
        if (method.IsStatic && rendered.Contains("__this"))
            return "__this in static method";

        // Body-level check: gc_allocate_uninitialized_array returns void*, CompareExchange expects Array*
        if (rendered.Contains("gc_allocate_uninitialized_array") && rendered.Contains("CompareExchange"))
            return "gc_allocate_uninitialized_array + CompareExchange type mismatch";

        // Body-level check: CIL2CPP_FINALLY without CIL2CPP_END_TRY — missing end-of-try-finally
        // causes unclosed braces (C2601 "local function definition is illegal" / C1075 "unmatched {")
        if (rendered.Contains("CIL2CPP_FINALLY") && !rendered.Contains("CIL2CPP_END_TRY"))
            return "CIL2CPP_FINALLY without END_TRY";

        // Body-level check: field access via parameter or ldelema on forward-declared-only types.
        // The ldelema fix (StackEntry type) correctly uses -> for pointer access, but if the
        // element type is only forward-declared, MSVC gives C2027 "undefined type".
        if (knownTypes != null)
        {
            // Check method parameters: if param type is not fully defined but body accesses fields
            foreach (var param in method.Parameters)
            {
                if (param.Name == "__this") continue;
                var paramType = param.CppTypeName.TrimEnd('*').Trim();
                if (paramType.Length == 0 || paramType.StartsWith("cil2cpp::") || knownTypes.Contains(paramType))
                    continue;
                // Only flag if body accesses fields on this specific parameter
                if (rendered.Contains($"{param.Name})->f_") || rendered.Contains($"{param.Name}->f_"))
                    return $"field access on forward-declared param type '{paramType}'";
            }
            // Check ldelema result: auto __tN = (Type*)array_get_element_ptr(...); __tN->f_
            if (rendered.Contains("array_get_element_ptr"))
            {
                var undefinedTemps = new HashSet<string>();
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    if (!s.StartsWith("auto __t") || !s.Contains("*)cil2cpp::array_get_element_ptr("))
                        continue;
                    var castStart = s.IndexOf("= (") + 3;
                    var castEnd = s.IndexOf("*)cil2cpp::array_get_element_ptr(");
                    if (castStart <= 3 || castEnd <= castStart) continue;
                    var castType = s[castStart..castEnd].Trim();
                    if (castType.Length > 0 && !castType.StartsWith("cil2cpp::") && !knownTypes.Contains(castType))
                    {
                        var varEnd = s.IndexOf(' ', 5);
                        if (varEnd > 5) undefinedTemps.Add(s[5..varEnd]);
                    }
                }
                if (undefinedTemps.Count > 0)
                {
                    foreach (var line in rendered.AsSpan().EnumerateLines())
                    {
                        var s = line.ToString().TrimStart();
                        foreach (var t in undefinedTemps)
                        {
                            if (s.Contains($"{t}->f_") || s.Contains($"{t}.f_"))
                                return $"ldelema field access on undefined type via {t}";
                        }
                    }
                }
            }
        }

        // Body-level check: undeclared Action<Object>.Invoke delegate specialization
        if (rendered.Contains("Action_1_System_Object_Invoke"))
            return "undeclared Action<Object>.Invoke delegate specialization";

        // Body-level check: CancellationToken cast to String* in f_message assignment (BCL IL body bug)
        if (rendered.Contains("CancellationToken") && rendered.Contains("->f_message = (cil2cpp::String*)"))
            return "CancellationToken cast to String* in f_message assignment";

        // Body-level check: ReadOnlySpan parameters passed to compareinfo/ordinal ICalls.
        // The ICalls expect cil2cpp::String* but ReadOnlySpan<char> is a struct value.
        // Check if any ReadOnlySpan parameter name appears as an argument to these ICalls.
        if (method.Parameters.Any(p => p.CppTypeName.StartsWith("System_ReadOnlySpan_1_")))
        {
            var spanParamNames = method.Parameters
                .Where(p => p.CppTypeName.StartsWith("System_ReadOnlySpan_1_"))
                .Select(p => p.CppName)
                .ToList();
            foreach (var ln in rendered.AsSpan().EnumerateLines())
            {
                var s = ln.ToString().TrimStart();
                if (s.Contains("compareinfo_") || s.Contains("ordinal_") || s.Contains("casing_"))
                {
                    if (spanParamNames.Any(name => s.Contains(name)))
                        return $"ReadOnlySpan parameter passed to globalization ICall expecting String*";
                }
            }
        }

        // Body-level check: char16_t* pointer division — IL subtracts char16_t* pointers then
        // divides by 2, but in C++ pointer subtraction already gives element count.
        // Only flag when a temp assigned (char16_t*) is directly divided — NOT when
        // the division is on an intptr_t/ptrdiff_t from byte-level subtraction.
        {
            var char16Temps = new HashSet<string>();
            foreach (var ln in rendered.AsSpan().EnumerateLines())
            {
                var s = ln.ToString().TrimStart();
                // auto __tN = (char16_t*)expr;
                if (s.StartsWith("auto ") && s.Contains("= (char16_t*)"))
                {
                    var varEnd = s.IndexOf(' ', 5);
                    if (varEnd > 5) char16Temps.Add(s[5..varEnd]);
                }
            }
            if (char16Temps.Count > 0)
            {
                foreach (var ln in rendered.AsSpan().EnumerateLines())
                {
                    var s = ln.ToString().TrimStart();
                    foreach (var t in char16Temps)
                    {
                        if (s.Contains($"{t} / 2"))
                            return "char16_t* pointer division by 2";
                    }
                }
            }
        }

        // Pre-pass: collect temp vars known to be String* (from explicit casts)
        // Used to avoid false positives in string_length(__tN) check
        var knownStringTemps = new HashSet<string>();
        // Collect param names known to be String*
        var stringParamNames = new HashSet<string>();
        foreach (var p in method.Parameters)
        {
            if (p.CppTypeName == "cil2cpp::String*")
                stringParamNames.Add(p.CppName ?? p.Name);
        }
        foreach (var preLine in rendered.AsSpan().EnumerateLines())
        {
            var ps = preLine.ToString().TrimStart();
            // auto __tN = (cil2cpp::String*)(void*)... or __tN = (cil2cpp::String*)(void*)...
            // Also: auto __tN = *(cil2cpp::String**)... (dereference of String**)
            if ((ps.Contains("(cil2cpp::String*)") || ps.Contains("(cil2cpp::String**)")) && ps.Contains("__t"))
            {
                // Extract variable name: "auto __tN = ..." or "__tN = ..."
                var varStart = ps.IndexOf("__t");
                if (varStart >= 0)
                {
                    var varEnd = varStart;
                    while (varEnd < ps.Length && (char.IsLetterOrDigit(ps[varEnd]) || ps[varEnd] == '_'))
                        varEnd++;
                    var varName = ps[varStart..varEnd];
                    if (varName.Length > 2 && varName.Skip(3).All(char.IsDigit))
                        knownStringTemps.Add(varName);
                }
            }
            // auto __tN = stringParam; — temp assigned from String* parameter
            if (ps.StartsWith("auto __t") && ps.Contains(" = "))
            {
                var eqIdx = ps.IndexOf(" = ");
                var rhs = ps[(eqIdx + 3)..].TrimEnd(';').Trim();
                if (stringParamNames.Contains(rhs) || knownStringTemps.Contains(rhs))
                {
                    var spIdx = ps.IndexOf(' ', 5);
                    if (spIdx > 5)
                        knownStringTemps.Add(ps[5..spIdx]);
                }
            }
        }

        // Reflection aliased type field access — check if accessed through aliased types
        // RuntimeFieldInfo→ManagedFieldInfo, RuntimeMethodInfo→ManagedMethodInfo — these DON'T have the fields.
        // Concrete subtypes (RtFieldInfo, MdFieldInfo, etc.) DO have these fields via struct definitions.
        // The rendered body may cast to aliased types (RuntimeFieldInfo*) and access fields through them,
        // which is invalid. Check each line: only flag when accessed through aliased type, not through __this
        // or through a concrete subtype.
        {
            bool hasReflectionFieldAccess = rendered.Contains("f_m_reflectedTypeCache") || rendered.Contains("f_m_fieldAttributes") ||
                rendered.Contains("f_m_fieldType") || rendered.Contains("f_m_returnType") || rendered.Contains("f_m_parameters") ||
                rendered.Contains("->f_m_declaringType");
            if (hasReflectionFieldAccess)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    // Skip lines accessing through __this (concrete declaring type)
                    if (s.Contains("__this->f_m_") || s.Contains("__this)->f_m_"))
                        continue;
                    // Flag lines that cast to aliased reflection types and access these fields
                    bool hasAliasedCast = s.Contains("RuntimeFieldInfo*)") || s.Contains("RuntimeMethodInfo*)") ||
                                          s.Contains("ManagedFieldInfo*)") || s.Contains("ManagedMethodInfo*)");
                    bool hasFieldAccess = s.Contains("f_m_reflectedTypeCache") || s.Contains("f_m_fieldAttributes") ||
                        s.Contains("f_m_fieldType") || s.Contains("f_m_returnType") || s.Contains("f_m_parameters") ||
                        s.Contains("->f_m_declaringType");
                    if (hasAliasedCast && hasFieldAccess)
                        return "reflection aliased type field access (RuntimeFieldInfo/RuntimeMethodInfo)";
                }
            }
        }

        // Check each line for known error patterns
        foreach (var line in rendered.AsSpan().EnumerateLines())
        {
            var s = line.ToString().TrimStart();
            if (s.Length == 0 || s.StartsWith("//") || s.StartsWith("#")) continue;

            var lineReason = GetRenderedLineErrorReason(s, knownStringTemps);
            if (lineReason != null)
                return lineReason;

            // Check for references to undeclared _statics globals
            var staticsIdx = s.IndexOf("_statics.", StringComparison.Ordinal);
            if (staticsIdx > 0)
            {
                // Extract type name before "_statics." — find the start of the identifier
                var start = staticsIdx - 1;
                while (start > 0 && (char.IsLetterOrDigit(s[start - 1]) || s[start - 1] == '_'))
                    start--;
                var typeName = s[start..staticsIdx];
                if (typeName.Length > 0 && knownTypes != null && !knownTypes.Contains(typeName))
                    return $"undeclared _statics global for type '{typeName}'";
            }
        }

        // Multi-line pattern: Object* variable from byref dereference used where typed ptr expected
        // Detects: __tN = *(cil2cpp::Object**)... then later:
        //   - array_length/__tN), array_get<...>(__tN,...), array_set etc.
        //   - comparisons with typed local variables (locN == __tN)
        //   - string_length(__tN)
        {
            var objectDerefTemps = new HashSet<string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                if (s.StartsWith("auto ") && s.Contains("= *(cil2cpp::Object**)"))
                {
                    var varEnd = s.IndexOf(' ', 5);
                    if (varEnd > 5)
                        objectDerefTemps.Add(s[5..varEnd]);
                }
            }
            if (objectDerefTemps.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    foreach (var temp in objectDerefTemps)
                    {
                        // Array operations (need Array*, get Object*)
                        if (s.Contains($"array_length({temp})") ||
                            s.Contains($"array_get<") && s.Contains($"({temp},") ||
                            s.Contains($"array_set<") && s.Contains($"({temp},") ||
                            s.Contains($"array_get_element_ptr({temp},"))
                            return $"Object* byref deref {temp} used in array operation";
                        // String operations
                        if (s.Contains($"string_length({temp})"))
                            return $"Object* byref deref {temp} used in string_length";
                        // Comparison involving objectDerefTemp (on either side)
                        if (s.Contains($"== {temp}") || s.Contains($"!= {temp}") ||
                            s.Contains($"{temp} ==") || s.Contains($"{temp} !="))
                            return $"Object* byref deref {temp} in typed pointer comparison";
                        // Field access on Object* (C2039 — Object has no user fields)
                        if (s.Contains($"{temp}->f_"))
                            return $"Object* byref deref {temp} field access (C2039)";
                    }
                }
            }
        }

        // Multi-line pattern: MdArray** from array_get_element_ptr used with field access (C2039)
        // Generic specialization maps array elements to MdArray* but actual struct fields don't exist on MdArray.
        {
            var mdArrayTemps = new HashSet<string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                if (s.StartsWith("auto ") && s.Contains("(cil2cpp::MdArray**)cil2cpp::array_get_element_ptr("))
                {
                    var varEnd = s.IndexOf(' ', 5);
                    if (varEnd > 5)
                        mdArrayTemps.Add(s[5..varEnd]);
                }
            }
            if (mdArrayTemps.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    foreach (var temp in mdArrayTemps)
                    {
                        if (s.Contains($"{temp}->f_") || s.Contains($"{temp}.f_"))
                            return $"MdArray** temp {temp} field access (C2039)";
                    }
                }
            }
        }

        // Multi-line pattern: MdArray* passed as typed pointer argument in function calls (C2664)
        // Generic specialization sometimes maps ConditionalWeakTable<T[],V> parent ref to MdArray*
        // instead of the actual ConditionalWeakTable type.
        if (rendered.Contains("(cil2cpp::MdArray*)(void*)"))
        {
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                // Pattern: FuncName(..., (cil2cpp::MdArray*)(void*)expr) — passing MdArray* to non-array function
                if (s.Contains("(cil2cpp::MdArray*)(void*)") && !s.StartsWith("auto ") &&
                    !s.Contains("array_") && !s.Contains("= (cil2cpp::MdArray*)"))
                    return "MdArray* passed as typed pointer argument (C2664)";
            }
        }

        // Multi-line pattern: comparison of unrelated pointer types (C2446)
        // When a typed pointer (__this, parameter) is compared with Object* parameter/variable
        {
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                // Catches: __this != value, __this == value, comparer != __tN, etc.
                // where one side is Object* and the other is a typed pointer
                if ((s.Contains("__this != ") || s.Contains("__this == ") ||
                     s.Contains("!= value") || s.Contains("== value") ||
                     s.Contains("comparer != ") || s.Contains("comparer == ") ||
                     s.Contains("== __this") || s.Contains("!= __this")) &&
                    !s.Contains("(void*)") && !s.Contains("nullptr") &&
                    (s.Contains("__t") || s.Contains("value") || s.Contains("comparer") ||
                     s.Contains("obj") || s.Contains("other")))
                {
                    // Only flag if the function signature shows an Object* parameter
                    // (mixed type comparison is the issue)
                    if (method.Parameters.Any(p => p.CppTypeName == "cil2cpp::Object*"))
                        return "comparison of unrelated pointer types (C2446)";
                }
            }
        }

        // Multi-line pattern: cross-scope variable declared as Object* but assigned value type
        // Detects: cil2cpp::Object* __tN = nullptr; ... __tN = intExpr / boolExpr / doubleExpr;
        {
            var objectPtrVars = new HashSet<string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                if (s.StartsWith("cil2cpp::Object* __t") && s.Contains("= nullptr;"))
                {
                    var varEnd = s.IndexOf(' ', 20);
                    if (varEnd > 20)
                        objectPtrVars.Add(s[20..varEnd]);
                }
            }
            if (objectPtrVars.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    foreach (var v in objectPtrVars)
                    {
                        var prefix = $"__t{v} = ";
                        if (!s.StartsWith(prefix)) continue;
                        var rhs = s[prefix.Length..].TrimEnd(';').Trim();
                        // __tN = expr == 0 / != 0 / != nullptr (assigns bool to Object*)
                        if (rhs.Contains("== 0") || rhs.Contains("!= 0") ||
                            rhs.Contains("!= nullptr") || rhs.Contains("== nullptr"))
                            return $"Object* var __t{v} assigned boolean expression";
                        // __tN = small_int; (assigns int literal to Object*)
                        if (rhs.Length > 0 && rhs.All(c => char.IsDigit(c) || c == '-' || c == '.'))
                            return $"Object* var __t{v} assigned int literal";
                        // __tN = expr + expr (arithmetic/bitwise — can't assign int result to Object*)
                        if (rhs.Contains(" + ") || rhs.Contains(" - ") || rhs.Contains(" * ")
                            || rhs.Contains(" / ") || rhs.Contains(" % ") || rhs.Contains(" | ")
                            || rhs.Contains(" & ") || rhs.Contains(" ^ "))
                            return $"Object* var __t{v} assigned arithmetic/bitwise result";
                        // __tN = expr < N / expr > N / expr <= N / expr >= N (comparison → bool, not Object*)
                        if (rhs.Contains(" < ") || rhs.Contains(" > ") ||
                            rhs.Contains(" <= ") || rhs.Contains(" >= "))
                            return $"Object* var __t{v} assigned comparison result";
                        // __tN = -value (negation of non-pointer value)
                        if (rhs.StartsWith("-") && !rhs.Contains("nullptr") && !rhs.Contains("("))
                            return $"Object* var __t{v} assigned negation";
                    }
                }
            }
        }

        // Multi-line pattern: cross-scope variable declared as non-pointer but assigned Object*
        // Detects: int32_t __tN = 0; or double __tN = 0; ... __tN = obj->field (which is Object*)
        {
            var nonPtrVarTypes = new Dictionary<string, string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                if (s.StartsWith("int32_t __t") || s.StartsWith("double __t") ||
                    s.StartsWith("int64_t __t") || s.StartsWith("float __t"))
                {
                    var spaceIdx = s.IndexOf(' ');
                    var eqIdx = s.IndexOf(' ', spaceIdx + 1);
                    if (spaceIdx > 0 && eqIdx > spaceIdx)
                    {
                        var varName = s[(spaceIdx + 1)..eqIdx];
                        nonPtrVarTypes[varName] = s[..spaceIdx];
                    }
                }
            }
            if (nonPtrVarTypes.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    foreach (var (varName, _) in nonPtrVarTypes)
                    {
                        // varName = (SomeType*)(void*) expr; — pointer assigned to int/double
                        // Only flag when the pointer cast is the DIRECT assignment, not inside a function argument.
                        // Direct cast: __t33 = (SomeType*)(void*)expr; — RHS starts with "("
                        // Function call with cast arg: __t33 = FuncName((SomeType*)(void*)arg); — RHS starts with identifier
                        if (s.StartsWith($"{varName} = "))
                        {
                            var rhs = s.Substring($"{varName} = ".Length);
                            if (rhs.StartsWith("(") && rhs.Contains("*)(void*)"))
                                return $"non-pointer var {varName} assigned pointer cast";
                        }
                    }
                }
            }
        }

        // Multi-line pattern: cross-scope assignment without cast between incompatible types
        // __tN = (TypeA*)(void*)... then later __tN = __tM where __tM is different TypeB*
        // Only flag when the SAME __tN variable appears in both cast and plain assignment
        if (rendered.Contains("(void*)"))
        {
            var castVars = new HashSet<string>();
            var plainAssignVars = new HashSet<string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s2 = line.ToString().TrimStart();
                // Track __tN = (TypeA*)(void*)... → variable receives a pointer cast
                if (s2.StartsWith("__t") && !s2.StartsWith("__this") && s2.Contains("*)(void*)"))
                {
                    var eqIdx = s2.IndexOf(" = ");
                    if (eqIdx > 0)
                        castVars.Add(s2[..eqIdx]);
                }
                // Track __tN = __tM; → plain assignment without cast
                if (s2.StartsWith("__t") && !s2.StartsWith("__this") && s2.Contains(" = __t") && !s2.Contains("(") && s2.EndsWith(";"))
                {
                    var eqIdx = s2.IndexOf(" = ");
                    if (eqIdx > 0)
                        plainAssignVars.Add(s2[..eqIdx]);
                }
            }
            if (castVars.Overlaps(plainAssignVars))
                return "cross-scope temp with cast and plain assignment (incompatible types)";
        }

        // Multi-line pattern: pointer variable accessed with dot instead of arrow
        // Detects locals assigned from pointer casts, auto temps, and pointer params
        {
            var ptrVars = new HashSet<string>();
            // Include pointer parameters (by-ref value type params are Type* in C++)
            // Exclude __this — always used with -> correctly
            foreach (var param in method.Parameters)
            {
                if (param.CppTypeName.EndsWith("*") && param.Name != "__this")
                    ptrVars.Add(param.Name);
            }
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s2 = line.ToString().TrimStart();
                // Detect: loc_N = (SomeType*)expr;
                if (s2.StartsWith("loc_") && s2.Contains(" = (") && s2.Contains("*)"))
                {
                    var spIdx = s2.IndexOf(' ');
                    if (spIdx > 0)
                        ptrVars.Add(s2[..spIdx]);
                }
                // Detect: auto __tN = (SomeType*)expr; (exclude derefs *(Type*))
                if (s2.StartsWith("auto __t") && s2.Contains("*)") &&
                    s2.Contains(" = (") && !s2.Contains(" = *("))
                {
                    var spIdx = s2.IndexOf(' ', 5); // after "auto "
                    if (spIdx > 5)
                        ptrVars.Add(s2[5..spIdx]);
                }
                // Detect: auto __tN = cil2cpp::unbox_ptr<...>(...); (returns pointer)
                if (s2.StartsWith("auto __t") && s2.Contains("unbox_ptr<"))
                {
                    var spIdx = s2.IndexOf(' ', 5); // after "auto "
                    if (spIdx > 5)
                        ptrVars.Add(s2[5..spIdx]);
                }
                // Detect: auto __tN = &expr; (address-of produces pointer)
                if (s2.StartsWith("auto __t") && s2.Contains(" = &"))
                {
                    var spIdx = s2.IndexOf(' ', 5); // after "auto "
                    if (spIdx > 5)
                        ptrVars.Add(s2[5..spIdx]);
                }
            }
            if (ptrVars.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s2 = line.ToString().TrimStart();
                    foreach (var v in ptrVars)
                    {
                        // Require word boundary: v must not be preceded by alphanumeric/underscore
                        // to avoid false positives (e.g., "System_String_statics.f_Empty" matching "s.f_")
                        var dotPattern = $"{v}.f_";
                        var dotIdx = s2.IndexOf(dotPattern);
                        if (dotIdx >= 0)
                        {
                            // Check that the character before v is NOT alphanumeric or underscore
                            if (dotIdx == 0 || !char.IsLetterOrDigit(s2[dotIdx - 1]) && s2[dotIdx - 1] != '_')
                                return $"pointer variable '{v}' accessed with dot instead of arrow";
                        }
                    }
                }
            }
        }

        // Multi-line pattern: array_get<T>/array_set<T> with reference type (value↔pointer mismatch)
        // array_get returns T by value — casting result to T* means it's a reference type array
        // array_set expects T by value — passing a T* pointer means it's a reference type array
        // Note: array_get<Object*>/array_set<Object*> are correct (pointer-type template arg)
        if (rendered.Contains("array_get<") || rendered.Contains("array_set<"))
        {
            var arrayGetVars = new HashSet<string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                // Track __tN assigned from array_get with NON-POINTER element type
                // array_get<Object*> returns a pointer — casting is fine, don't flag
                if (s.StartsWith("auto __t") && s.Contains("array_get<"))
                {
                    var getIdx = s.IndexOf("array_get<");
                    var closeAngle = s.IndexOf('>', getIdx + 10);
                    if (closeAngle > getIdx + 10)
                    {
                        var elemTypeArg = s[(getIdx + 10)..closeAngle];
                        if (!elemTypeArg.EndsWith("*"))
                        {
                            var spIdx = s.IndexOf(' ', 5);
                            if (spIdx > 5) arrayGetVars.Add(s[5..spIdx]);
                        }
                    }
                }
                // array_set with pointer value in 3rd arg — reference type stored as value
                // Only flag if the template arg is NOT a pointer type (non-pointer = value mismatch)
                if (s.Contains("array_set<"))
                {
                    var setIdx = s.IndexOf("array_set<");
                    var closeAngle = s.IndexOf('>', setIdx + 10);
                    if (closeAngle > setIdx + 10)
                    {
                        var typeArg = s[(setIdx + 10)..closeAngle];
                        if (!typeArg.EndsWith("*"))
                        {
                            // Check if the 3rd arg is a pointer-cast expression (indicates ref type mismatch)
                            var argsStart = s.IndexOf('(', closeAngle);
                            if (argsStart > 0)
                            {
                                var argsStr = s[(argsStart + 1)..];
                                // Count commas to find 3rd arg
                                var commaCount = 0;
                                var argStart = 0;
                                for (int ci = 0; ci < argsStr.Length; ci++)
                                {
                                    if (argsStr[ci] == ',' && ++commaCount == 2)
                                    {
                                        argStart = ci + 1;
                                        break;
                                    }
                                }
                                if (commaCount >= 2)
                                {
                                    var thirdArg = argsStr[argStart..].Trim().TrimEnd(';', ')').Trim();
                                    // Flag if 3rd arg is a pointer cast like (Type*)expr
                                    if (thirdArg.Contains("*)"))
                                        return "array_set<non-pointer> with pointer cast value (ref type as value)";
                                    // Flag if 3rd arg is a method parameter with pointer type
                                    // (reference type stored as value in array — needs pointer)
                                    var matchParam = method.Parameters.FirstOrDefault(
                                        p => p.Name == thirdArg && p.CppTypeName.EndsWith("*"));
                                    if (matchParam != null)
                                        return "array_set<non-pointer> with pointer param value (ref type as value)";
                                }
                            }
                        }
                    }
                }
            }
            if (arrayGetVars.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    foreach (var v in arrayGetVars)
                    {
                        // (X*)varName — value-to-pointer cast of array_get result
                        if (s.Contains($"*){v}") && !s.Contains("array_"))
                            return $"array_get<non-pointer> result {v} cast to pointer";
                    }
                }
            }
        }

        // Method-level: DIM implementations in System.Numerics interfaces
        // These use raw CIL arithmetic/comparison opcodes (add, sub, cgt, clt, etc.)
        // which translate to C++ operators (+, -, >, <) that struct types don't support.
        // Only flag methods ON interface types (not concrete types like Byte/Int32 that
        // implement the interfaces — those have scalar aliases with valid C++ operators).
        if (method.DeclaringType?.ILFullName != null)
        {
            var declType = method.DeclaringType.ILFullName;
            if (declType.StartsWith("System.Numerics.I") && method.DeclaringType.IsInterface)
            {
                // Allow concrete specializations where all type params are scalar-aliased primitives
                // (e.g., IAdditionOperators<Byte,Byte,Byte>.op_Addition — uint8_t + uint8_t is valid C++)
                bool allPrimitive = method.Parameters.All(p =>
                    CppNameMapper.IsPrimitive(p.ILTypeName ?? "") ||
                    p.CppTypeName is "bool" or "void" ||
                    p.CppTypeName.EndsWith("*"));
                if (!allPrimitive)
                    return "System.Numerics DIM with non-primitive params";
                // Also check return type — non-scalar returns indicate complex DIM logic
                if (!string.IsNullOrEmpty(method.ReturnTypeCpp) &&
                    method.ReturnTypeCpp != "void" && method.ReturnTypeCpp != "bool" &&
                    !method.ReturnTypeCpp.EndsWith("*") &&
                    method.ReturnTypeCpp != "int32_t" && method.ReturnTypeCpp != "uint8_t" &&
                    method.ReturnTypeCpp != "int8_t" && method.ReturnTypeCpp != "int16_t" &&
                    method.ReturnTypeCpp != "uint16_t" && method.ReturnTypeCpp != "uint32_t" &&
                    method.ReturnTypeCpp != "int64_t" && method.ReturnTypeCpp != "uint64_t" &&
                    method.ReturnTypeCpp != "float" && method.ReturnTypeCpp != "double" &&
                    method.ReturnTypeCpp != "char16_t" && method.ReturnTypeCpp != "intptr_t" &&
                    method.ReturnTypeCpp != "uintptr_t")
                {
                    return "System.Numerics DIM with non-scalar return type";
                }
            }
        }

        // Method-level: System.Reflection.Pointer — f_ptr is void* but IL treats as IntPtr.
        // GetPointerType and Equals compile fine (pointer-to-pointer operations).
        // GetPointerValue returns intptr_t from void* field, GetHashCode assigns void* to uintptr_t local.
        // Only block methods where f_ptr value flows to intptr_t/uintptr_t without cast.
        if (method.DeclaringType?.ILFullName == "System.Reflection.Pointer" && rendered.Contains("f_ptr"))
        {
            if (method.ReturnTypeCpp is "intptr_t" or "uintptr_t")
                return "Reflection.Pointer f_ptr void* returned as intptr_t/uintptr_t";
            if (method.Locals.Any(l => l.CppTypeName is "intptr_t" or "uintptr_t") && !rendered.Contains("(intptr_t)") && !rendered.Contains("(uintptr_t)"))
                return "Reflection.Pointer f_ptr void* assigned to intptr_t/uintptr_t local without cast";
        }

        // Method-level: IntPtr/UIntPtr methods try to access f_value field
        // IntPtr is aliased to intptr_t (scalar), so ->f_value is invalid
        if (method.DeclaringType?.ILFullName is "System.IntPtr" or "System.UIntPtr")
        {
            if (rendered.Contains("->f_value"))
                return "IntPtr/UIntPtr ->f_value on scalar alias";
        }

        // Method-level: void* parameter assigned to typed field (Span<T> constructors)
        if (rendered.Contains("f_reference = pointer") &&
            method.Parameters.Any(p => p.CppTypeName == "void*"))
            return "void* param assigned to typed Span f_reference field";

        // Note: void* local in intptr_t-returning method gate removed —
        // return value casting now adds (intptr_t) cast at ret instruction.

        // Method-level: Span ctor called with intptr_t/uintptr_t parameter as actual argument
        // Only flag when the Span ctor call line actually contains the intptr_t param as argument
        if (rendered.Contains("Span_1_") && rendered.Contains("__ctor"))
        {
            var intptrParams = method.Parameters
                .Where(p => p.CppTypeName is "intptr_t" or "uintptr_t")
                .Select(p => p.Name)
                .ToHashSet();
            if (intptrParams.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s2 = line.ToString().TrimStart();
                    if (s2.Contains("Span_1_") && s2.Contains("__ctor"))
                    {
                        foreach (var param in intptrParams)
                        {
                            if (s2.Contains($", {param},") || s2.Contains($", {param})"))
                                return $"Span ctor called with intptr_t/uintptr_t param '{param}'";
                        }
                    }
                }
            }
        }

        // NOTE: Array_IndexOf/LastIndexOf check removed. The (cil2cpp::Array*)(void*)expr cast
        // is valid C++ — all Array.IndexOf declarations take cil2cpp::Array* as first parameter.

        // Method-level: ActivityTracker Guid manipulation with pointer arithmetic type mismatch
        if (method.CppName.Contains("AddIdToGuid"))
            return "ActivityTracker.AddIdToGuid pointer arithmetic type mismatch";

        // Method-level: Encoding GetCharsWithFallback — Span<Char> passed as ReadOnlySpan<Byte>,
        // cross-scope type mismatch between DecoderFallback* and ReadOnlySpan, etc.
        if (method.CppName.Contains("GetCharsWithFallback") &&
            (method.CppName.Contains("UTF8Encoding") || method.CppName.Contains("ASCIIEncoding")))
        {
            return "Encoding.GetCharsWithFallback Span/ReadOnlySpan cross-scope type mismatch";
        }

        // Method-level: EventSource_WriteEventString — EventData* → intptr_t mismatch
        if (method.CppName.Contains("EventSource_WriteEventString"))
        {
            return "EventSource_WriteEventString EventData* to intptr_t mismatch";
        }

        // Method-level: EventProvider_EncodeObject — static_cast<uint64_t>(&pointer) repeated
        if (method.CppName.Contains("EventProvider_EncodeObject"))
        {
            return "EventProvider_EncodeObject static_cast<uint64_t>(&pointer)";
        }

        // Method-level: CancellationToken_ThrowOperationCanceledException — IL maps CancellationToken
        // struct value into f_innerException (Exception*), which is a struct→pointer C2440
        if (method.CppName.Contains("CancellationToken_ThrowOperationCanceledException"))
        {
            return "CancellationToken struct mapped to Exception* f_innerException (C2440)";
        }

        // Method-level: RuntimeResourceSet_GetObject — assigns Dictionary<string,ResourceLocator>*
        // to f_caseInsensitiveTable which is declared as Dictionary<string,Object>*
        if (method.CppName.Contains("RuntimeResourceSet_GetObject"))
        {
            return "RuntimeResourceSet_GetObject Dictionary generic type mismatch";
        }

        // Method-level: Thread.StartCore — references f_priority which doesn't exist on ManagedThread
        if (method.CppName.Contains("Thread_StartCore"))
        {
            return "Thread.StartCore references f_priority not on ManagedThread";
        }

        // Method-level: RuntimeParameterInfo .ctor — references f_MemberImpl which doesn't exist
        // on ManagedParameterInfo (BCL internal field not mapped to runtime struct)
        if (method.CppName.Contains("RuntimeParameterInfo__ctor__System_Reflection_RuntimeParameterInfo_System_Reflection_MemberInfo"))
        {
            return "RuntimeParameterInfo .ctor references f_MemberImpl not on ManagedParameterInfo";
        }

        // Method-level: RegistryKey.GetValue — calls Interop_Advapi32_RegQueryValueEx with
        // int32_t* where uint32_t* is expected (parameter 6 type mismatch)
        if (method.CppName.Contains("RegistryKey_GetValue__System_String_System_Object"))
        {
            return "RegistryKey.GetValue int32_t* where uint32_t* expected (param 6)";
        }

        // Method-level: TraceLoggingDataCollector.AddArray — __t2 declared as pointer then
        // redefined via auto (pre-declared temp conflicts with auto declaration)
        if (method.CppName.Contains("TraceLoggingDataCollector_AddArray"))
        {
            return "TraceLoggingDataCollector.AddArray pre-declared temp conflicts with auto";
        }

        // Method-level: ValueTuple`4<String,...>.GetHashCode — takes &f_Item1/&f_Item4 (String**)
        // and assigns to String* temp variable (address-of ref type field yields double pointer)
        if (method.CppName.Contains("ValueTuple_4_System_String_System_Int32_System_Int32_System_String_GetHashCode"))
        {
            return "ValueTuple`4<String,...>.GetHashCode &f_Item yields String** assigned to String*";
        }

        // Method-level: Interop.Kernel32.LocalFree(void*) — calls LocalFree(IntPtr) overload
        // but void* doesn't implicitly convert to intptr_t in MSVC
        if (method.CppName == "Interop_Kernel32_LocalFree__System_Void")
        {
            return "Interop.Kernel32.LocalFree void* to intptr_t mismatch";
        }

        // Method-level: EventPipe methods using intptr_t fields with Span ctors
        if (method.CppName.Contains("DispatchEventsToEventListeners") ||
            method.CppName.Contains("EventData_SetMetadata"))
            return "EventPipe intptr_t fields with Span ctors";

        // Method-level: BCL's System.TypedReference methods reference internal CLR field layout
        // (_value, _type) that doesn't match our TypedReference struct.
        if (method.CppName.Contains("System_TypedReference_"))
            return "TypedReference internal field layout";

        // Phase II.2: DBNull guard removed — DBNull compiles from BCL IL

        // Phase II.5: Pre-declared Thread* temp assigned from ICall returning void*/Object*
        // ExecutionContext methods use Thread.CurrentThread (ICall returns void* but var is Thread*)
        if (rendered.Contains("System_Threading_Thread* __t") && rendered.Contains("Thread_get_CurrentThread"))
            return "Thread.CurrentThread pre-declared type mismatch";

        // Phase III.7: TimeZoneInfo cross-scope check REMOVED — all 52 methods compile fine in MSVC
        // Previously flagged DateTime temps and AdjustmentRule references, but with improved
        // DetermineTempVarTypes and TempVarTypes, cross-scope issues are resolved.

        // Method-level: switch-between-switch goto-skips-init (C2362)
        // Two consecutive switch blocks with auto __tN between them
        if (rendered.Contains("switch (") && rendered.Contains("auto __t") &&
            rendered.Contains("goto IL_003C") && rendered.Contains("goto IL_003E"))
            return "switch goto-skips-init (C2362)";

        // Method-level: GuidResult pointer parameter accessed with dot instead of arrow
        // stfld on by-ref param generates result.f_X instead of result->f_X
        if (method.Parameters.Any(p => p.CppTypeName.Contains("GuidResult*")))
        {
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s2 = line.ToString().TrimStart();
                if (s2.StartsWith("result.f_"))
                    return "GuidResult pointer dot-access";
            }
        }

        // Multi-line pattern: primitive-typed pre-declared variable used with dot access
        // e.g., bool __t0 = {}; ... __t0.f_hasCustomFormatter (always wrong — primitives have no fields)
        {
            var primitiveVars = new HashSet<string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                if ((s.StartsWith("bool __t") || s.StartsWith("int32_t __t") ||
                     s.StartsWith("int64_t __t") || s.StartsWith("double __t") ||
                     s.StartsWith("float __t") || s.StartsWith("uint8_t __t") ||
                     s.StartsWith("uint16_t __t") || s.StartsWith("uint32_t __t")) &&
                    s.Contains(" = "))
                {
                    var spIdx = s.IndexOf(' ');
                    var eqIdx = s.IndexOf(' ', spIdx + 1);
                    if (eqIdx > spIdx)
                        primitiveVars.Add(s[(spIdx + 1)..eqIdx]);
                }
            }
            if (primitiveVars.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    foreach (var v in primitiveVars)
                    {
                        if (s.Contains($"{v}.f_"))
                            return "primitive-typed pre-declared with dot-access";
                    }
                }
            }
        }

        // Check for calls to undeclared disambiguated functions
        if (_declaredFunctionNames.Count > 0)
        {
            foreach (var block in method.BasicBlocks)
            {
                foreach (var instr in block.Instructions)
                {
                    if (instr is IR.IRCall call && !string.IsNullOrEmpty(call.FunctionName)
                        && !call.FunctionName.StartsWith("cil2cpp::")
                        && !call.FunctionName.EndsWith("_ensure_cctor")
                        && call.FunctionName.Contains("__") // disambiguated name
                        && !_declaredFunctionNames.Contains(call.FunctionName))
                        return $"undeclared disambiguated function: {call.FunctionName}";
                }
            }
        }

        // Multi-line: Object* pre-declared temp redeclared as struct type (value type)
        // AddAutoDeclarations pre-declares cross-scope __tN as Object*, but the body later
        // has "StructType __tN = {0};" — MSVC C2086 redefinition error.
        {
            var objectPreDeclVars = new HashSet<string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                // Match: cil2cpp::Object* __tNN = nullptr;
                if (s.StartsWith("cil2cpp::Object* __t") && s.EndsWith("= nullptr;"))
                {
                    var spaceIdx = s.IndexOf(' ', 20);
                    if (spaceIdx > 20)
                        objectPreDeclVars.Add(s[20..spaceIdx]);
                }
            }
            if (objectPreDeclVars.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    // Match: SomeStructType __tNN = {0}; or SomeStructType __tNN;
                    foreach (var v in objectPreDeclVars)
                    {
                        var marker = $" __t{v} =";
                        var idx = s.IndexOf(marker);
                        if (idx <= 0) continue;
                        // Ensure what precedes is a type name (not "auto" or "cil2cpp::Object*")
                        var prefix = s[..idx].Trim();
                        if (prefix.Length > 0 && prefix != "auto" && !prefix.Contains("Object*")
                            && !prefix.StartsWith("//") && !prefix.StartsWith("#"))
                            return "Object* pre-declared temp redeclared as struct (C2086)";
                    }
                }
            }
        }

        // Multi-line: uintptr_t/intptr_t temp passed as function argument or assigned to void* variable
        // In .NET JIT, IntPtr/UIntPtr and void* are identical (native int = pointer).
        // In C++, uintptr_t is an integer type incompatible with pointer types.
        // BCL IL uses conv.u/conv.i to cast pointers → integers before P/Invoke calls,
        // but our generated wrappers keep typed pointer parameters → type mismatch (C2664/C2440).
        if (rendered.Contains("(uintptr_t)(") || rendered.Contains("(intptr_t)("))
        {
            var uintptrTemps = new HashSet<string>();
            var voidPtrVars = new HashSet<string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                // Track auto __tN = (uintptr_t/intptr_t)(expr)
                // Only flag when expr looks like a pointer expression (contains * for pointer cast/deref).
                // Skip when expr is a plain integer temp (__tN) — just an int→uintptr widening cast.
                if (s.StartsWith("auto ") && (s.Contains("= (uintptr_t)(") || s.Contains("= (intptr_t)(")))
                {
                    var castType = s.Contains("= (uintptr_t)(") ? "= (uintptr_t)(" : "= (intptr_t)(";
                    var exprStart = s.IndexOf(castType) + castType.Length;
                    var exprEnd = s.LastIndexOf(')');
                    var expr = exprEnd > exprStart ? s[exprStart..exprEnd] : "";
                    // Only add if expr looks like a pointer (cast, deref, or address-of)
                    if (expr.Contains('*') || expr.Contains("->") || expr.StartsWith("&"))
                    {
                        var spIdx = s.IndexOf(' ', 5);
                        if (spIdx > 5)
                            uintptrTemps.Add(s[5..spIdx]);
                    }
                }
                // Track void* loc_N declarations
                if (s.StartsWith("void* ") && s.Contains(" = "))
                {
                    var eqIdx = s.IndexOf(' ', 6);
                    if (eqIdx > 6)
                        voidPtrVars.Add(s[6..eqIdx]);
                }
            }
            if (uintptrTemps.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    foreach (var t in uintptrTemps)
                    {
                        // Passed as function argument: func(t, ...) or func(..., t)
                        // Exclude: if/while conditions, and simple auto assignments
                        if (s.Contains($"({t},") || s.Contains($"({t})") ||
                             s.Contains($", {t},") || s.Contains($", {t})"))
                        {
                            if (s.StartsWith("if ") || s.StartsWith("while "))
                                continue;
                            // Skip stackalloc — uintptr_t is the correct type for allocation size
                            if (s.Contains("CIL2CPP_STACKALLOC"))
                                continue;
                            // Skip Buffer_Memmove — its size parameter IS uintptr_t/size_t
                            if (s.Contains("Buffer_Memmove"))
                                continue;
                            // Skip to_unsigned/to_signed — integer conversion templates accept any integer type
                            if (s.Contains("to_unsigned(") || s.Contains("to_signed("))
                                continue;
                            // Skip checked_conv — checked conversion templates accept any numeric type
                            if (s.Contains("checked_conv"))
                                continue;
                            if (s.StartsWith("auto "))
                            {
                                // Skip simple assignments: auto __tM = (__tN); or auto __tM = __tN;
                                var eqPos = s.IndexOf(" = ");
                                if (eqPos >= 0)
                                {
                                    var rhs = s[(eqPos + 3)..].TrimEnd(';').Trim();
                                    if (rhs == t || rhs == $"({t})")
                                        continue;
                                }
                                // Skip static_cast — integer-to-integer conversion, not a function call
                                if (s.Contains("static_cast<"))
                                    continue;
                                return "uintptr_t/intptr_t temp in function call";
                            }
                            return "uintptr_t/intptr_t temp passed as function arg";
                        }
                        // Assigned to void* variable
                        foreach (var v in voidPtrVars)
                        {
                            if (s == $"{v} = {t};")
                                return "uintptr_t/intptr_t assigned to void* variable";
                        }
                    }
                }
            }
        }

        return null;
    }

    /// <summary>
    /// Check a single rendered C++ line for patterns that would cause MSVC errors.
    /// Returns null if no error, or a reason string describing the detected error.
    /// </summary>
    private static string? GetRenderedLineErrorReason(string s, HashSet<string>? knownStringTemps = null)
    {
        // Pattern: &variable = (assigning to address-of, invalid l-value)
        if (s.StartsWith("&") && s.Contains(" = "))
            return "&variable = (assigning to address-of, invalid l-value)";

        // Pattern: ->f_m_value on primitive types (System_Single = float, System_Double = double)
        // These are aliased to C++ primitives and don't have the f_m_value field.
        // Note: Non-primitive types (RuntimeMethodHandle, RuntimeFieldHandle) legitimately have
        // f_m_value as a struct field — only flag when the type name is a known scalar alias.
        // With the IR-level scalar alias interception (ldfld/stfld m_value → direct value access),
        // this check is now a safety net for any missed cases.
        if (s.Contains("->f_m_value") && !s.Contains("System_I") && !s.Contains("IRuntimeMethodInfo"))
        {
            // Check if the expression before ->f_m_value is a known scalar alias type
            var fmIdx = s.IndexOf("->f_m_value");
            if (fmIdx > 0)
            {
                // Only flag for __this->f_m_value in methods on primitive types
                // (non-primitives have valid f_m_value struct fields)
                var prefix = s[..fmIdx].TrimStart();
                if (prefix.EndsWith("__this") || prefix.Contains("intptr_t") || prefix.Contains("uintptr_t")
                    || prefix.Contains("int32_t") || prefix.Contains("int64_t") || prefix.Contains("float")
                    || prefix.Contains("double") || prefix.Contains("bool") || prefix.Contains("char16_t")
                    || prefix.Contains("uint8_t") || prefix.Contains("int8_t"))
                    return "(non-primitives have valid f_m_value struct fields)";
            }
        }

        // Interop_Globalization_ check REMOVED — CastArgumentsToParameterTypes now handles
        // pointer type casts at call sites (originally caught Interop_GetRandomBytes mismatch).
        // Note: RuntimeHelpers.CreateSpan<T>(RuntimeFieldHandle) is now intercepted in IRBuilder
        // and produces inline span init code. Only catch unintercepted CreateSpan calls.
        // Exclude function definitions (end with '{') — the function name itself contains CreateSpan.
        if (s.Contains("RuntimeHelpers_CreateSpan") && s.Contains("(") && !s.Contains("f_reference")
            && !s.TrimEnd().EndsWith("{"))
            return "and produces inline span init code. Only catch unintercepted CreateSpan calls.";

        // Pattern: string_length called with non-String arg (Object* from array_get)
        if (s.Contains("string_length(cil2cpp::array_get<"))
            return "string_length called with non-String arg (Object* from array_get)";

        // Pattern: array operations on Object* — byref deref produces Object*
        // but array_length/array_get/array_set/array_get_element_ptr need Array*
        if (s.Contains("array_length(*(cil2cpp::Object**)") ||
            s.Contains("array_get<") && s.Contains("(*(cil2cpp::Object**)") ||
            s.Contains("array_set<") && s.Contains("(*(cil2cpp::Object**)") ||
            s.Contains("array_get_element_ptr(*(cil2cpp::Object**)"))
            return "but array_length/array_get/array_set/array_get_element_ptr need Array*";
        // array_set with 0 as first arg (null array pointer)
        if (s.Contains("array_set<") && s.Contains(">(0,"))
            return "array_set with 0 as first arg (null array pointer)";

        // Pattern: OperationCanceledException.f_cancellationToken is void* in runtime
        if (s.Contains("f_cancellationToken") && !s.Contains("(void*)") && !s.Contains("nullptr")
            && !s.Contains("//"))
            return "OperationCanceledException.f_cancellationToken is void* in runtime";

        // Pattern: GetLocaleInfoEx — BCL code passes int32_t* where char16_t* expected
        // Only match actual calls (not function definitions which end with '{')
        if ((s.Contains("Interop_Kernel32_GetLocaleInfoEx(") || s.Contains("Interop_Kernel32_GetLocaleInfoExInt("))
            && !s.TrimEnd().EndsWith("{"))
            return "GetLocaleInfoEx — BCL code passes int32_t* where char16_t* expected";

        // Pattern: AsyncLocal<T>.ctor called with wrong arg count (2 args for 1-arg ctor
        // mapped to no-arg ctor name). Exclude function definition lines (ending with '{').
        if (s.Contains("System_Threading_AsyncLocal_1_") && s.Contains("__ctor(")
            && !s.TrimEnd().EndsWith("{"))
        {
            // Count commas to detect multi-arg calls to the no-arg ctor name
            var ctorIdx = s.IndexOf("__ctor(");
            var parenIdx = s.IndexOf('(', ctorIdx);
            if (parenIdx >= 0)
            {
                var afterParen = s[(parenIdx + 1)..];
                var closeIdx = afterParen.IndexOf(')');
                if (closeIdx >= 0 && afterParen[..closeIdx].Contains(','))
                    return "multi-arg call to no-arg ctor name — wrong overload resolution"; // multi-arg call to no-arg ctor name — wrong overload resolution
            }
        }

        // Pattern: broken type name from function pointer mishandling
        // e.g., "methodSystem_Void*" or "reinterpret_cast<void(*)"
        if (s.Contains("methodSystem_") || s.Contains("reinterpret_cast<void(*)("))
            return "broken type name from function pointer mishandling";

        // Pattern: f_innerException = (cil2cpp::Exception*)<value_type>
        // Only flag when the cast source is a value type variable (not a pointer).
        // Pointer-to-pointer casts like (Exception*)__str_N or (Exception*)__tN compile fine via C-style cast.
        // The real error is struct-to-pointer like (Exception*)cancellationToken.
        if (s.Contains("->f_innerException = (cil2cpp::Exception*)") &&
            !s.Contains("(cil2cpp::Exception*)nullptr") &&
            !s.Contains("(cil2cpp::Exception*)(void*)"))
        {
            // Extract what follows (cil2cpp::Exception*)
            var castIdx = s.IndexOf("(cil2cpp::Exception*)");
            if (castIdx >= 0)
            {
                var val = s[(castIdx + 21)..].TrimEnd(';').Trim();
                // Simple identifiers (variables/parameters) compile fine with C-style cast
                // between pointer types. Only flag struct field access patterns.
                bool isSimpleIdentifier = val.Length > 0 &&
                    val.All(c => char.IsLetterOrDigit(c) || c == '_') &&
                    !val.Contains(".f_");
                if (!isSimpleIdentifier && !val.StartsWith("("))
                    return "between pointer types. Only flag struct field access patterns.";
            }
        }

        // Phase II.3/II.4: Reflection type BCL internal fields that don't exist on our aliased types
        // RuntimeFieldInfo.m_reflectedTypeCache, RuntimeMethodInfo.m_declaringType, etc.
        // NOTE: These field names are VALID on concrete subtypes (RtFieldInfo, MdFieldInfo, RuntimeEventInfo,
        // RuntimeParameterInfo, Signature) which have full struct definitions with these fields.
        // Only flag when used on aliased types (RuntimeFieldInfo→ManagedFieldInfo, RuntimeMethodInfo→ManagedMethodInfo)
        // that don't have the fields. The check is now in RenderedBodyHasErrors with method context.
        // See: RenderedBodyHasErrors "Reflection aliased type field access" section.

        // RuntimeFieldInfo/RuntimeMethodInfo.m_declaringType accessed via arrow — only for aliased types
        // (moved to RenderedBodyHasErrors with method context to avoid false positives on concrete subtypes)

        // Phase II.1: GetCalendarInfoEx passes char16_t* where intptr_t expected
        // Also catches definitions — some variants call nested PInvoke helpers that may have no body
        // FIXME: fix PInvoke helper body generation for _g____PInvoke variants, then exclude definitions
        if (s.Contains("Interop_Kernel32_GetCalendarInfoEx") || s.Contains("Interop_Kernel32_GetCalendarInfoW"))
            return "fix PInvoke helper body generation for _g____PInvoke variants, then exclude d...";

        // Pattern: enum type pointer cast where value expected
        // e.g., (System_Resources_UltimateResourceFallbackLocation*)__t5 in function args
        // These appear when ldflda/ldloca produces an address but callee expects value
        if (s.Contains("UltimateResourceFallbackLocation*)"))
            return "These appear when ldflda/ldloca produces an address but callee expects value";

        // Phase II.1: CalendarId guard removed — CalendarId compiles as enum from IL

        // Pattern: ReadOnlySpan/Span struct cast to void*
        // BCL code casts Span structs but C++ can't implicit-cast struct to void*
        // Exclude: function names containing Span type where (void*) is in arguments
        // Exclude: function pointer type params like (void(*)(Stream*, ReadOnlySpan_1_Byte))
        if ((s.Contains("ReadOnlySpan_1_") || s.Contains("Span_1_")) && s.Contains("(void*)"))
        {
            // Find the Span type in the line and check what follows the containing identifier
            var spanIdx = s.IndexOf("Span_1_");
            // Walk to end of the identifier containing Span_1_
            var endIdx = spanIdx;
            while (endIdx < s.Length && (char.IsLetterOrDigit(s[endIdx]) || s[endIdx] == '_'))
                endIdx++;
            // If identifier is followed by '(' → function call name → safe
            // If identifier is followed by '*)(void*)' → Span pointer cast through void* → problematic
            // If identifier is followed by '*)&' or '*)<expr>' without void* → byref address-of → safe
            // If identifier is followed by ')' without '*' → function pointer param type → safe
            if (endIdx + 9 <= s.Length && s.Substring(endIdx, 9) == "*)(void*)")
                return "(SpanType*)(void*) — pointer cast to Span through void*"; // (SpanType*)(void*) — pointer cast to Span through void*
            if (endIdx >= s.Length)
                return "truncated line — flag as error"; // truncated line — flag as error
        }

        // Pattern: missing this pointer — function call where first arg is small int
        // but function expects a pointer (value type method on struct)
        // Detect: GuidResult_SetFailure(7, or GetLocaleInfoFromLCType(4099,
        if (s.Contains("GuidResult_SetFailure(") && !s.TrimEnd().EndsWith("{") &&
            !s.Contains("GuidResult_SetFailure(result") &&
            !s.Contains("GuidResult_SetFailure(&") && !s.Contains("GuidResult_SetFailure(loc_") &&
            !s.Contains("GuidResult_SetFailure(__"))
            return "Detect: GuidResult_SetFailure(7, or GetLocaleInfoFromLCType(4099,";
        if (s.Contains("GetLocaleInfoFromLCType(") && char.IsDigit(s[s.IndexOf("GetLocaleInfoFromLCType(") + 24]))
            return "Detect: GuidResult_SetFailure(7, or GetLocaleInfoFromLCType(4099,";
        // Pattern: ValueListBuilder method called with wrong this (literal instead of pointer)
        // Skip function definition lines (ending with '{').
        if (s.Contains("ValueListBuilder_1_") && !s.TrimEnd().EndsWith("{"))
        {
            var fnEnd = s.LastIndexOf('(');
            if (fnEnd > 0)
            {
                var afterParen = s[(fnEnd + 1)..].TrimStart();
                // Only flag if first arg is a literal (digit or string), not a variable/param
                if (afterParen.Length > 0 && (char.IsDigit(afterParen[0]) || afterParen[0] == '"'))
                    return "ValueListBuilder method called with wrong this (literal instead of pointer)";
            }
        }

        // Pattern: array_data result cast to wrong pointer depth
        // e.g., f_reference = (cil2cpp::Object*)cil2cpp::array_data(  — should be Object**
        if (s.Contains("= (cil2cpp::Object*)cil2cpp::array_data("))
            return "e.g., f_reference = (cil2cpp::Object*)cil2cpp::array_data(  — should be Object**";

        // Pattern: Span type confusion in function argument
        // Span_1_System_Char passed where ReadOnlySpan_1_System_Byte expected
        // Exclude: function signatures (end with '{'), function pointer types ('(*)'),
        // and lines where both types appear in the function name (before first '(')
        if (s.Contains("System_Span_1_System_Char") && s.Contains("ReadOnlySpan_1_System_Byte")
            && !s.TrimEnd().EndsWith("{") && !s.Contains("(*)"))
        {
            var firstParen = s.IndexOf('(');
            if (firstParen < 0 || !(s[..firstParen].Contains("Span_1_System_Char") &&
                                     s[..firstParen].Contains("ReadOnlySpan_1_System_Byte")))
                return "and lines where both types appear in the function name (before first '(')";
        }

        // Pattern: static_cast<uint64_t>(ptr) — pointer to uint64 needs reinterpret_cast
        // Only flag when the argument looks like a pointer variable (contains * or ->)
        // Don't flag integer widening conversions like static_cast<uint64_t>(count)
        if (s.Contains("static_cast<uint64_t>(") && (s.Contains("->") || s.Contains("*)")))
            return "Don't flag integer widening conversions like static_cast<uint64_t>(count)";

        // Pattern: Guid* subtracted from uint8_t* (pointer arithmetic type mismatch)
        if (s.Contains("System_Guid*") && s.Contains("uint8_t*") && s.Contains("-"))
            return "Guid* subtracted from uint8_t* (pointer arithmetic type mismatch)";

        // Pattern: interface type assignment (class* → interface*)
        // CultureInfo* → IFormatProvider*, etc.
        // NOTE: C-style cast works fine in MSVC for unrelated pointer types in our flat model.
        // Removed: was causing false positives. The cast is safe because both sides are
        // flat structs with compatible memory layout (all inherit __type_info + __sync_block).
        // if (s.Contains("= (System_IFormatProvider*)") && !s.Contains("(void*)"))
        //     return true;

        // Pattern: null-pointer dereference for Unsafe.NullRef
        // (((Type*)0))->field = value; — dereferencing null pointer
        // Only flag when followed by member access (-> or .), not just passing null as arg
        if (s.Contains("*)0))->") || s.Contains("*)0))."))
            return "(((Type*)0))->field = value; — dereferencing null pointer";

        // Pattern: void* dot access — lParam.f_X when lParam is void*
        if (s.Contains("lParam.f_"))
            return "void* dot access — lParam.f_X when lParam is void*";

        // NOTE: volatile_write type mismatch and nullptr ambiguity checks removed —
        // runtime template uses std::type_identity_t<T> for second param, so T is deduced
        // only from first arg. Both int64_t/uint64_t mismatch and nullptr_t are now handled.

        // Pattern: unbox_ptr/array_get_element_ptr result accessed with dot instead of arrow
        if ((s.Contains("unbox_ptr<") || s.Contains("array_get_element_ptr(")) && s.Contains(").f_"))
            return "unbox_ptr/array_get_element_ptr result accessed with dot instead of arrow";

        // Note: Decimal/Int128/UInt128/Half operators are caught at method-level
        // by the System.Numerics interface DIM pattern in RenderedBodyHasErrors

        // Pattern: unbox/unbox_ptr with trailing underscore in type name (mangling mismatch)
        // e.g., unbox<System_ValueTuple_4_..._String_> — trailing _ before > is always wrong
        if ((s.Contains("unbox<") || s.Contains("unbox_ptr<")) && s.Contains("_>"))
            return "e.g., unbox<System_ValueTuple_4_..._String_> — trailing _ before > is always ...";

        // Pattern: double trailing underscore from nested generic mangling (>>→__)
        // e.g., List_1_WeakReference_1_EventSource__*) — the __ before *) is wrong
        if (s.Contains("__*)") || s.Contains("__*>"))
            return "e.g., List_1_WeakReference_1_EventSource__*) — the __ before *) is wrong";

        // Pattern: VerificationException undeclared type
        if (s.Contains("VerificationException"))
            return "VerificationException undeclared type";

        // Pattern: GCHandle_Alloc with int first arg (should be Object*)
        // Handle disambiguated names: GCHandle_Alloc__System_Object_...(2, 1)
        if (s.Contains("GCHandle_Alloc") && !s.Contains("(cil2cpp::Object*)"))
        {
            var allocIdx = s.IndexOf("GCHandle_Alloc");
            // Find the opening paren of the call arguments
            var parenIdx = s.IndexOf('(', allocIdx);
            if (parenIdx >= 0)
            {
                var afterParen = s[(parenIdx + 1)..].TrimStart();
                if (afterParen.Length > 0 && (char.IsDigit(afterParen[0]) || afterParen[0] == '-'))
                    return "Handle disambiguated names: GCHandle_Alloc__System_Object_...(2, 1)";
            }
        }

        // Pattern: DataCollector methods with wrong this pointer (args shifted)
        if (s.Contains("DataCollector_Add") && s.Contains("(loc_") && !s.Contains("DataCollector*"))
            return "DataCollector methods with wrong this pointer (args shifted)";

        // Pattern: void* to intptr_t/uintptr_t conversion (needs reinterpret_cast)
        if ((s.Contains("loc_0 = __t") || s.Contains("return __t")) && s.Contains("ToPointer"))
            return "void* to intptr_t/uintptr_t conversion (needs reinterpret_cast)";

        // Pattern: Calendar-derived to Calendar-base assignment without cast
        if (s.Contains("GregorianCalendar*") && s.Contains("Calendar*") && s.Contains("= __t"))
            return "Calendar-derived to Calendar-base assignment without cast";

        // Pattern: Enum as value type in function arg (it's a reference type)
        if (s.Contains("System_Enum_GetValue(") && !s.Contains("System_Enum*"))
            return "Enum as value type in function arg (it's a reference type)";

        // Pattern: pointer-parameter dot-access (EventSourceOptions* → options.f_X)
        if (s.Contains("options.f_") && !s.Contains("->"))
            return "pointer-parameter dot-access (EventSourceOptions* → options.f_X)";

        // Pattern: intptr_t/uint8_t* pointer mismatch in reflection/tracing
        if (s.Contains("_GetPropertyOrFieldData(") || s.Contains("set_DataPointer("))
            return "intptr_t/uint8_t* pointer mismatch in reflection/tracing";

        // Pattern: CustomAttributeData comparison with Object*
        // The comparison line itself may not mention the type — it just has "obj == __this"
        // Detect at method level instead


        // Pattern: CancellationToken struct in OperationCanceledException ctor
        if (s.Contains("OperationCanceledException__ctor") && s.Contains("CancellationToken"))
            return "CancellationToken struct in OperationCanceledException ctor";

        // Pattern: InformThreadNameChange with wrong first arg (String* instead of ThreadHandle)
        if (s.Contains("InformThreadNameChange(") && !s.Contains("ThreadHandle"))
            return "InformThreadNameChange with wrong first arg (String* instead of ThreadHandle)";

        // Pattern: DBNull* comparison with Object* (unrelated pointer types)
        if (s.Contains("DBNull*") && (s.Contains("!=") || s.Contains("==")))
            return "DBNull* comparison with Object* (unrelated pointer types)";

        // Pattern: VectorMath hardware intrinsic types (JIT intrinsic, no IL body)
        // Note: Vector128_1_ removed — Vector types now have scalar fallback struct definitions
        if (s.Contains("VectorMath_"))
            return "Note: Vector128_1_ removed — Vector types now have scalar fallback struct def...";

        // Pattern: TypedReference passed as void* — it's a struct, not a pointer
        if (s.Contains("TypedReference") && s.Contains("GetTypeFromHandle"))
            return "TypedReference passed as void* — it's a struct, not a pointer";

        // Pattern: FreeCoTaskMem — BCL passes raw pointers (uint8_t*, uint16_t*) where intptr_t expected
        if (s.Contains("FreeCoTaskMem(") && !s.Contains("(intptr_t)"))
            return "FreeCoTaskMem — BCL passes raw pointers (uint8_t*, uint16_t*) where intptr_t ...";

        // Pattern: void* pointer arithmetic (void has unknown size)
        // e.g., __t3 + index where __t3 is void*
        // Note: IntPtr.ToPointer is now an ICall, but callers still produce void* values
        // that may be used in pointer arithmetic. Keep the gate for now.
        if (s.Contains("ToPointer("))
            return "that may be used in pointer arithmetic. Keep the gate for now.";

        // Phase III.7: Span_1_System_TimeZoneInfo_AdjustmentRule check REMOVED — compiles fine in MSVC

        // Pattern: enum pointer passed where enum value expected (ResourceTypeCode, etc.)
        // Only flag when address-of (&) is taken on a non-pointer variable — this creates a pointer
        // where a value is expected. Pointer-to-pointer casts like (ResourceTypeCode*)typeCode
        // are valid when the variable is already ResourceTypeCode*.
        if (s.Contains("ResourceTypeCode*)&"))
            return "are valid when the variable is already ResourceTypeCode*.";

        // Pattern: MethodTable field access — JIT internal structure not fully supported
        if (s.Contains("f_ComponentSize") || s.Contains("f_BaseSize") ||
            (s.Contains("f_Flags") && s.Contains("MethodTable")))
            return "MethodTable field access — JIT internal structure not fully supported";

        // Pattern: TypeHandle/MethodTable JIT internals — bitwise ops on void* (f_m_asTAddr)
        if (s.Contains("f_m_asTAddr"))
            return "TypeHandle/MethodTable JIT internals — bitwise ops on void* (f_m_asTAddr)";
        // Pattern: TypeHandle__ctor with intptr_t arg (needs void*, not intptr_t)
        if (s.Contains("TypeHandle__ctor(") || s.Contains("TypeHandle_TypeHandleOf"))
            return "TypeHandle__ctor with intptr_t arg (needs void*, not intptr_t)";

        // Pattern: RuntimeMethodHandle_InvokeMethod — callers pass intptr_t* but it needs void**
        if (s.Contains("RuntimeMethodHandle_InvokeMethod("))
            return "RuntimeMethodHandle_InvokeMethod — callers pass intptr_t* but it needs void**";

        // Pattern: enum pointer passed where enum value expected (InvokerStrategy)
        if (s.Contains("InvokerStrategy*)"))
            return "enum pointer passed where enum value expected (InvokerStrategy)";

        // Pattern: string_length with array_get result (Object* not String*)
        if (s.Contains("string_length(") && !s.Contains("string_length((cil2cpp::String*)"))
        {
            // Allow: string_length(__this), string_length(someStringVar), string_length(paramName)
            // Reject: string_length(__tN) where __tN came from array_get — unless __tN
            // was previously assigned from a (cil2cpp::String*) cast (known to be safe)
            var idx = s.IndexOf("string_length(");
            if (idx >= 0)
            {
                var argStart = idx + 14;
                var afterParen = s[argStart..];
                if (afterParen.StartsWith("__t") && !afterParen.StartsWith("__this"))
                {
                    // Extract the variable name (__tN)
                    var endIdx = 0;
                    while (endIdx < afterParen.Length && (char.IsLetterOrDigit(afterParen[endIdx]) || afterParen[endIdx] == '_'))
                        endIdx++;
                    var tempName = afterParen[..endIdx];
                    // Only flag if the temp is NOT known to be String*
                    if (knownStringTemps == null || !knownStringTemps.Contains(tempName))
                        return "Extract the variable name (__tN)";
                }
                // Also allow: string_length(loc_N) and string_length(paramName) — locals and
                // params of String* type are safe
                // Only flag __tN temps from array_get, not named vars
            }
        }

        // Pattern: SpanHelpers pointer alignment — bitwise AND of pointer with integer (C2296)
        if (s.Contains("SpanHelpers_UnalignedCount"))
            return "SpanHelpers pointer alignment — bitwise AND of pointer with integer (C2296)";

        // NOTE: TimeSpanFormat_FormatG/FormatC pattern removed — the functions are declared as stubs
        // and calls to them are valid C++. The stubs themselves have wrong arg order, but callers are fine.

        // Pattern: EventPipeMetadataGenerator_WriteToBuffer — char16_t* → uint8_t* mismatch
        if (s.Contains("EventPipeMetadataGenerator_WriteToBuffer("))
            return "EventPipeMetadataGenerator_WriteToBuffer — char16_t* → uint8_t* mismatch";

        // Pattern: GetThreadIOPendingFlag with wrong arg types
        if (s.Contains("GetThreadIOPendingFlag("))
            return "GetThreadIOPendingFlag with wrong arg types";

        // Pattern: ReadUnalignedI4 — REMOVED: body compiles fine (creates ReadOnlySpan + calls BinaryPrimitives).
        // The old check caught the function's own definition line. Callers pass (int32_t*)(void*) which is valid.

        // FIXME: codegen bug — conv.i before Marshal_FreeHGlobal not emitting (intptr_t) cast
        // Pointer arg passed where intptr_t expected → C2664
        if (s.Contains("Marshal_FreeHGlobal(") && !s.Contains("Marshal_FreeHGlobal((intptr_t)"))
        {
            // Check if arg is a typed pointer temp (not already intptr_t)
            var idx = s.IndexOf("Marshal_FreeHGlobal(") + "Marshal_FreeHGlobal(".Length;
            var arg = s[idx..].TrimStart();
            if (arg.StartsWith("__t") || arg.StartsWith("loc_") || arg.StartsWith("__this"))
                return "Pointer arg passed where intptr_t expected → C2664";
        }

        // Pattern: ValueStringBuilder — wrong this pointer (String* instead of VSB*)
        // Only flag when first arg is clearly wrong (numeric literal, string literal).
        // Skip function definition lines (ending with '{').
        if ((s.Contains("ValueStringBuilder_Append") || s.Contains("ValueStringBuilder_Insert"))
            && !s.TrimEnd().EndsWith("{"))
        {
            var fnEnd = s.LastIndexOf('(');
            if (fnEnd > 0)
            {
                var afterParen = s[(fnEnd + 1)..].TrimStart();
                // First arg should be a pointer expression: &loc_, __this, __tN, param name, cast
                // Only flag if it starts with a digit (integer literal) or quote (string literal)
                if (afterParen.Length > 0 && (char.IsDigit(afterParen[0]) || afterParen[0] == '"'))
                    return "First arg should be a pointer expression: &loc_, __this, __tN, param name, cast";
            }
        }

        // Pattern: static_cast<uint64_t>(pointer*) — pointer→int needs reinterpret_cast
        // EventProvider_EncodeObject has many of these (int32_t*, uint64_t*, Guid*, Decimal*, etc.)
        if (s.Contains("static_cast<uint64_t>(") && s.Contains("*>") == false)
        {
            // Extract the argument of static_cast<uint64_t>(...)
            var castIdx = s.IndexOf("static_cast<uint64_t>(");
            if (castIdx >= 0)
            {
                var argStart = castIdx + 22; // after "static_cast<uint64_t>("
                var argEnd = s.IndexOf(')', argStart);
                if (argEnd > argStart)
                {
                    var arg = s[argStart..argEnd].Trim();
                    // If the argument starts with & (address-of), it's a pointer
                    if (arg.StartsWith("&"))
                        return "If the argument starts with & (address-of), it's a pointer";
                }
            }
        }

        // Pattern: EventProvider_WriteEvent with pointer→intptr_t mismatch
        if (s.Contains("EventProvider_WriteEvent") && s.Contains("EventData*"))
            return "EventProvider_WriteEvent with pointer→intptr_t mismatch";

        // Pattern: SearchValues_TryGetSingleRange — Span<Char> inline init bug: generic specialization
        // uses Span<Char> where Span<bool> is needed → bool*/char16_t* type mismatch in f_reference.
        // FIXME: fix the Span inline init type inference in IRBuilder
        if (s.Contains("SearchValues_TryGetSingleRange"))
            return "fix the Span inline init type inference in IRBuilder";

        // Pattern: static_cast<uint64_t>(pointer_param) — pointer parameter cast to uint64
        // UnmanagedMemoryStream_Initialize has static_cast<uint64_t>(pointer) where pointer is uint8_t*
        if (s.Contains("static_cast<uint64_t>(") && !s.Contains("->") && !s.Contains("*)"))
        {
            var castIdx = s.IndexOf("static_cast<uint64_t>(");
            if (castIdx >= 0)
            {
                var argStart = castIdx + 22;
                var argEnd = s.IndexOf(')', argStart);
                if (argEnd > argStart)
                {
                    var arg = s[argStart..argEnd].Trim();
                    // If the arg is a parameter name (not a number/expression), flag it
                    // Exclude __t temps and loc_ locals (correctly auto-typed by codegen)
                    // Only flag names that look like pointer parameters (contain "ptr", "pointer", "buffer")
                    if (arg.Length > 0 && char.IsLetter(arg[0]) && !arg.Contains('+') && !arg.Contains('-')
                        && !arg.StartsWith("__t") && !arg.StartsWith("loc_")
                        && (arg.Contains("ptr") || arg.Contains("Ptr") || arg.Contains("pointer")
                            || arg.Contains("buffer") || arg.Contains("Buffer")))
                        return "If the arg is a parameter name (not a number/expression), flag it";
                }
            }
        }

        // Pattern: DONT_USE_InternalThread field — not part of ManagedThread struct
        if (s.Contains("f_DONT_USE_InternalThread"))
            return "DONT_USE_InternalThread field — not part of ManagedThread struct";

        // Pattern: StringBuilder_Append ambiguous overload (char, int vs char16_t, int)
        // When first arg is 0 (int literal), MSVC can't choose between char and char16_t overloads
        if (s.Contains("StringBuilder_Append__System_Char_System_Int32") && s.Contains(", 0,"))
            return "When first arg is 0 (int literal), MSVC can't choose between char and char16_...";

        // Dictionary generic type mismatch handled at method level (RuntimeResourceSet_GetObject)

        // Pattern: (void*) applied to negated primitive — boxing a negated double/float
        // e.g., (cil2cpp::Object*)(void*)-value where value is double/float → C2440
        if (s.Contains("(void*)-") && !s.Contains("(void*)->"))
            return "e.g., (cil2cpp::Object*)(void*)-value where value is double/float → C2440";

        // Pattern: void* parameter arrow-access — lParam->f_X when lParam is void*
        // void* cannot be dereferenced (existing check only covers dot-access lParam.f_)
        if (s.Contains("lParam->f_"))
            return "void* cannot be dereferenced (existing check only covers dot-access lParam.f_)";

        // Pattern: ReadOnlySpan passed to compareinfo ICall expecting String*
        // BCL calls compareinfo with ReadOnlySpan<char> but our ICall takes cil2cpp::String*
        if (s.Contains("ReadOnlySpan_1_System_Char") && s.Contains("compareinfo_"))
            return "BCL calls compareinfo with ReadOnlySpan<char> but our ICall takes cil2cpp::St...";

        // Pattern: char16_t pointer division — pointer arithmetic error
        // e.g., (char16_t*) ... / 2 → C2296 pointer division is invalid
        if (s.Contains("char16_t*") && s.Contains("/ 2"))
            return "e.g., (char16_t*) ... / 2 → C2296 pointer division is invalid";

        // Pattern: ExceptionHandlingClauseOptions_TypeInfo — undeclared reflection enum TypeInfo
        if (s.Contains("ExceptionHandlingClauseOptions_TypeInfo"))
            return "ExceptionHandlingClauseOptions_TypeInfo — undeclared reflection enum TypeInfo";

        // Pattern: RuntimeMethodInfo/RuntimeConstructorInfo __ctor — undeclared constructor calls
        // These runtime-provided types don't have generated constructors
        if (s.Contains("RuntimeMethodInfo__ctor(") || s.Contains("RuntimeConstructorInfo__ctor("))
            return "These runtime-provided types don't have generated constructors";

        // Pattern: Interlocked.CompareExchange<IntPtr> called with pointer argument
        // BCL IL passes conv.i (ptr→intptr_t) but codegen may pass raw pointer
        if (s.Contains("Interlocked_CompareExchange__System_IntPtr") &&
            s.Contains("overlapped", StringComparison.OrdinalIgnoreCase))
            return "BCL IL passes conv.i (ptr→intptr_t) but codegen may pass raw pointer";

        // Pattern: delegate invoke with Object* arg where typed pointer expected (C2664).
        // NOTE: IRDelegateInvoke.ToCpp() now inserts (Type*)(void*) casts for all typed
        // pointer arguments. Only flag if the line lacks these casts (legacy codegen).
        if (s.Contains("->method_ptr)") && s.Contains("cil2cpp::Object*")
            && !s.Contains("(void*)"))
        {
            var fptIdx = s.IndexOf("(*)(");
            if (fptIdx >= 0)
            {
                var fptEnd = s.IndexOf("))", fptIdx);
                if (fptEnd > fptIdx)
                {
                    var fptParams = s[(fptIdx + 4)..fptEnd];
                    var parts = fptParams.Split(',');
                    foreach (var part in parts)
                    {
                        var p = part.Trim();
                        if (p.EndsWith("*") && !p.Contains("cil2cpp::Object*")
                            && !p.Contains("void*"))
                            return "line contains cil2cpp::Object*";
                    }
                }
            }
        }

        return null;
    }

    /// <summary>
    /// Extract function name → set of valid parameter counts from C++ signatures.
    /// Signature format: "retType funcName(Type1 p1, Type2 p2, ...)" → funcName → {2}
    /// </summary>
    private static Dictionary<string, HashSet<int>> ExtractFunctionParamCounts(HashSet<string> signatures)
    {
        var result = new Dictionary<string, HashSet<int>>();
        foreach (var sig in signatures)
        {
            var parenIdx = sig.IndexOf('(');
            if (parenIdx <= 0) continue;

            // Extract function name
            var beforeParen = sig[..parenIdx].TrimEnd();
            var spaceIdx = beforeParen.LastIndexOf(' ');
            if (spaceIdx < 0) continue;
            var name = beforeParen[(spaceIdx + 1)..];
            if (name.StartsWith("*"))
                name = name.TrimStart('*');
            if (string.IsNullOrEmpty(name)) continue;

            // Count parameters (count commas + 1, handle void/empty)
            var closeIdx = sig.IndexOf(')', parenIdx);
            if (closeIdx < 0) continue;
            var paramStr = sig[(parenIdx + 1)..closeIdx].Trim();
            int paramCount = 0;
            if (!string.IsNullOrEmpty(paramStr) && paramStr != "void")
            {
                paramCount = 1;
                // Count commas not inside nested angle brackets or parens
                int depth = 0;
                foreach (var ch in paramStr)
                {
                    if (ch is '<' or '(') depth++;
                    else if (ch is '>' or ')') depth--;
                    else if (ch == ',' && depth == 0) paramCount++;
                }
            }

            if (!result.TryGetValue(name, out var counts))
            {
                counts = new HashSet<int>();
                result[name] = counts;
            }
            counts.Add(paramCount);
        }
        return result;
    }
}
