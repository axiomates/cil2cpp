using System.Text;
using CIL2CPP.Core.IR;

namespace CIL2CPP.Core.CodeGen;

public partial class CppCodeGenerator
{
    private GeneratedFile GenerateHeader()
    {
        var sb = new StringBuilder();

        sb.AppendLine("// Generated by CIL2CPP - DO NOT EDIT");
        sb.AppendLine($"// Source assembly: {_module.Name}");
        sb.AppendLine();
        sb.AppendLine("#pragma once");
        sb.AppendLine();
        sb.AppendLine("#include <cil2cpp/cil2cpp.h>");
        sb.AppendLine();

        // Filter out compiler-generated types and open generic types with unresolved params
        var userTypes = _module.Types
            .Where(t => !CppNameMapper.IsCompilerGeneratedType(t.ILFullName))
            .Where(t => !HasUnresolvedGenericParams(t))
            .ToList();

        // Forward declarations — all types except enums, delegates, runtime-provided, and cil2cpp:: types
        sb.AppendLine("// ===== Forward Declarations =====");
        var forwardDeclared = new HashSet<string>();
        // Build set of types that will become using aliases (not struct forward-decls).
        // This includes delegates and core runtime types with using aliases.
        var aliasedTypes = new HashSet<string>();
        foreach (var type in _module.Types)
        {
            if (type.IsDelegate)
                aliasedTypes.Add(type.CppName);
        }
        // Core runtime types that get using aliases (Object, String, Array, etc.)
        foreach (var ilName in IRBuilder.RuntimeProvidedTypes)
            aliasedTypes.Add(CppNameMapper.MangleTypeName(ilName));
        foreach (var (mangled, _) in GetRuntimeProvidedTypeAliases())
            aliasedTypes.Add(mangled);
        // Primitive types that get using aliases (System_Byte = uint8_t, etc.)
        foreach (var (mangled, _) in GetPrimitiveTypeAliases())
            aliasedTypes.Add(mangled);
        // Types already aliased in runtime headers — skip struct definitions
        foreach (var mangled in RuntimeHeaderAliasedTypes)
            aliasedTypes.Add(mangled);
        foreach (var type in userTypes)
        {
            if (type.IsEnum || type.IsDelegate) continue;
            // Skip types that have using aliases (they're resolved via alias, not forward-decl)
            if (aliasedTypes.Contains(type.CppName)) continue;
            if (!IsValidCppIdentifier(type.CppName)) continue;
            sb.AppendLine($"struct {type.CppName};");
            forwardDeclared.Add(type.CppName);
        }
        // Collect enum type names — can't be forward-declared as struct
        var enumTypes = new HashSet<string>();
        foreach (var type in userTypes)
        {
            if (type.IsEnum)
                enumTypes.Add(type.CppName);
        }
        // Include external enum types (BCL enums not in the IR module)
        foreach (var (mangledName, _) in _module.ExternalEnumTypes)
            enumTypes.Add(mangledName);
        // Also forward-declare types referenced by method parameters, return types, and field types.
        // Scan ALL types (not just non-runtime-provided) to ensure complete forward declarations.
        foreach (var type in userTypes)
        {
            if (type.IsDelegate) continue;
            // Collect type names from method signatures
            foreach (var method in type.Methods)
            {
                var sigTypes = new List<string>();
                foreach (var param in method.Parameters)
                    sigTypes.Add(param.CppTypeName);
                if (!string.IsNullOrEmpty(method.ReturnTypeCpp) && method.ReturnTypeCpp != "void")
                    sigTypes.Add(method.ReturnTypeCpp);

                foreach (var typeName in sigTypes)
                    TryForwardDeclare(sb, typeName, forwardDeclared, aliasedTypes, enumTypes);
            }
            // Collect type names from field types (for pointer fields that aren't sanitized to void*)
            foreach (var field in type.Fields)
                TryForwardDeclare(sb, CppNameMapper.GetCppTypeForDecl(field.FieldTypeName), forwardDeclared, aliasedTypes, enumTypes);
            foreach (var field in type.StaticFields)
                TryForwardDeclare(sb, CppNameMapper.GetCppTypeForDecl(field.FieldTypeName), forwardDeclared, aliasedTypes, enumTypes);
        }
        // Using aliases for runtime-provided types (mangled name → cil2cpp:: struct)
        // These types are provided by the runtime but their mangled names may appear
        // as generic type arguments or cast targets in generated code.
        foreach (var (mangled, cppAlias) in GetRuntimeProvidedTypeAliases())
        {
            if (!forwardDeclared.Contains(mangled))
                sb.AppendLine($"using {mangled} = {cppAlias};");
        }
        // Using aliases for primitive types (System_Byte = uint8_t, etc.)
        // Primitive types map to C++ built-in types. Methods are compiled from BCL IL
        // but the struct definition is not emitted — the using alias provides the type.
        foreach (var (mangled, cppAlias) in GetPrimitiveTypeAliases())
        {
            if (!forwardDeclared.Contains(mangled))
                sb.AppendLine($"using {mangled} = {cppAlias};");
        }
        sb.AppendLine();

        // Type info declarations (skip runtime-provided types — declared in runtime headers)
        sb.AppendLine("// ===== Type Info Declarations =====");
        // Collect types whose TypeInfo is already declared elsewhere (exception aliases or primitive section)
        var runtimeDeclaredTypeInfos = new HashSet<string>();
        foreach (var (mangledName, _) in GetExceptionTypeInfoAliases())
            runtimeDeclaredTypeInfos.Add(mangledName);
        // Skip System.Object/System.String from main loop when declared in primitive type section
        foreach (var entry in _module.PrimitiveTypeInfos.Values)
        {
            if (GetRuntimeTypeInfoAlias(entry.ILFullName) != null)
                runtimeDeclaredTypeInfos.Add(entry.CppMangledName);
        }
        foreach (var type in userTypes)
        {
            // Skip types whose TypeInfo is already declared in runtime headers
            if (runtimeDeclaredTypeInfos.Contains(type.CppName)) continue;
            if (!IsValidCppIdentifier(type.CppName)) continue;
            // Types with a runtime TypeInfo alias (Object, String) are defined as
            // TypeInfo& references in the source — header must match
            if (GetRuntimeTypeInfoAlias(type.ILFullName) != null)
                sb.AppendLine($"extern cil2cpp::TypeInfo& {type.CppName}_TypeInfo;");
            else
                sb.AppendLine($"extern cil2cpp::TypeInfo {type.CppName}_TypeInfo;");
        }
        // Primitive type TypeInfo declarations (for array element types)
        foreach (var entry in _module.PrimitiveTypeInfos.Values)
        {
            // Runtime-provided reference types: declared as TypeInfo& reference to runtime's TypeInfo
            var runtimeAlias = GetRuntimeTypeInfoAlias(entry.ILFullName);
            if (runtimeAlias != null)
                sb.AppendLine($"extern cil2cpp::TypeInfo& {entry.CppMangledName}_TypeInfo;");
            else
                sb.AppendLine($"extern cil2cpp::TypeInfo {entry.CppMangledName}_TypeInfo;");
        }
        // Exception TypeInfo reference aliases — maps mangled names to runtime-declared TypeInfos
        // (e.g., System_Exception_TypeInfo → cil2cpp::Exception_TypeInfo)
        foreach (var (mangledName, runtimeTypeInfoName) in GetExceptionTypeInfoAliases())
        {
            sb.AppendLine($"extern cil2cpp::TypeInfo& {mangledName}_TypeInfo;");
        }
        sb.AppendLine();

        // Build set of all types that will be defined (for field type sanitization)
        var definedTypeNames = new HashSet<string>();
        foreach (var type in userTypes)
            definedTypeNames.Add(type.CppName);
        // Also include aliased types (they exist as cil2cpp:: types)
        foreach (var name in aliasedTypes)
            definedTypeNames.Add(name);
        foreach (var name in enumTypes)
            definedTypeNames.Add(name);

        // Type Definitions — ordering: enums first, then delegates, then structs (topologically sorted).
        sb.AppendLine("// ===== Type Definitions =====");
        var emittedStructs = new HashSet<string>();
        // Phase 1: Enums (must come first — used as value-type fields in structs)
        foreach (var type in userTypes)
        {
            if (!type.IsEnum || type.IsRuntimeProvided) continue;
            if (!IsValidCppIdentifier(type.CppName)) continue;
            GenerateEnumDefinition(sb, type);
            emittedStructs.Add(type.CppName);
        }
        // Phase 1.5: External enum aliases (BCL enums referenced in method signatures but not in IR module)
        // Use using = type (not enum) since generated code passes integers directly.
        // Method overloading conflicts are handled by DisambiguateOverloadedMethods.
        foreach (var (mangledName, underlyingType) in _module.ExternalEnumTypes)
        {
            if (emittedStructs.Contains(mangledName)) continue;
            sb.AppendLine($"using {mangledName} = {underlyingType};");
            emittedStructs.Add(mangledName);
            definedTypeNames.Add(mangledName);
        }
        // Phase 2: Delegate aliases
        foreach (var type in userTypes)
        {
            if (!type.IsDelegate || type.IsRuntimeProvided) continue;
            if (!IsValidCppIdentifier(type.CppName)) continue;
            sb.AppendLine($"using {type.CppName} = cil2cpp::Delegate;");
            sb.AppendLine();
            emittedStructs.Add(type.CppName);
        }
        // Phase 3: Emit stub structs for unknown value types referenced as fields
        var unknownValueTypeStubs = new HashSet<string>();
        CollectUnknownValueTypeFields(userTypes, definedTypeNames, unknownValueTypeStubs);
        foreach (var stubName in unknownValueTypeStubs)
        {
            // Span/ReadOnlySpan opaque stubs need f_reference + f_length for field access
            if (stubName.StartsWith("System_Span_1_") || stubName.StartsWith("System_ReadOnlySpan_1_"))
                sb.AppendLine($"struct {stubName} {{ void* f_reference; int32_t f_length; }}; // opaque Span stub");
            else
                sb.AppendLine($"struct {stubName} {{ }}; // opaque BCL internal type");
            emittedStructs.Add(stubName);
            definedTypeNames.Add(stubName);
        }
        // Phase 4: All struct types — topologically sorted by value-type field dependencies
        var structTypes = userTypes
            .Where(t => !t.IsEnum && !t.IsDelegate && IsValidCppIdentifier(t.CppName))
            .ToList();
        var sortedStructTypes = TopologicalSortByFieldDeps(structTypes, aliasedTypes);
        foreach (var type in sortedStructTypes)
        {
            if (emittedStructs.Contains(type.CppName)) continue;
            // Skip types with using aliases (their layout is resolved by the alias target)
            if (aliasedTypes.Contains(type.CppName)) continue;
            // Skip runtime-provided types (struct layout comes from runtime headers)
            if (type.IsRuntimeProvided) continue;
            // Skip primitive types (mapped to C++ built-in types via using aliases)
            if (type.IsPrimitiveType) continue;
            if (type.IsInterface) continue;
            GenerateStructDefinition(sb, type, definedTypeNames);
            emittedStructs.Add(type.CppName);
        }

        // Save emitted struct definitions for source generator (stub filtering)
        _emittedStructDefs = new HashSet<string>(emittedStructs);
        // Also include aliased types (they have full definitions via alias)
        foreach (var name in aliasedTypes) _emittedStructDefs.Add(name);
        foreach (var name in enumTypes) _emittedStructDefs.Add(name);
        foreach (var name in unknownValueTypeStubs) _emittedStructDefs.Add(name);

        // Static field storage declarations
        // Note: RuntimeProvided types still need statics (e.g., String.Empty)
        foreach (var type in userTypes)
        {
            if (type.IsEnum || type.IsDelegate) continue;
            if (type.StaticFields.Count > 0)
            {
                sb.AppendLine($"// Static fields for {type.ILFullName}");
                sb.AppendLine($"struct {type.CppName}_Statics {{");
                var emittedStaticFields = new HashSet<string>();
                foreach (var field in type.StaticFields)
                {
                    if (!emittedStaticFields.Add(field.CppName)) continue; // Deduplicate
                    var cppType = SanitizeFieldType(field.FieldTypeName, definedTypeNames);
                    sb.AppendLine($"    {cppType} {field.CppName};");
                }
                sb.AppendLine("};");
                sb.AppendLine($"extern {type.CppName}_Statics {type.CppName}_statics;");
                sb.AppendLine();
            }
        }

        // Build set of all known C++ type names (defined + forward-declared + stubs)
        var knownTypeNames = new HashSet<string>(definedTypeNames);
        foreach (var name in forwardDeclared)
            knownTypeNames.Add(name);
        foreach (var name in unknownValueTypeStubs)
            knownTypeNames.Add(name);

        // Method declarations (skip delegates and InternalCall methods)
        // RuntimeProvided types: only emit methods that have compiled IL bodies
        sb.AppendLine("// ===== Method Declarations =====");
        var emittedMethodDecls = new HashSet<string>();
        foreach (var type in userTypes)
        {
            if (type.IsDelegate) continue;

            // For interfaces, only emit declarations for DIM methods (non-abstract with bodies)
            if (type.IsInterface)
            {
                foreach (var method in type.Methods)
                {
                    if (method.IsAbstract || method.BasicBlocks.Count == 0) continue;
                    if (HasUnknownParameterTypes(method, knownTypeNames)) continue;
                    if (!emittedMethodDecls.Add(method.GetCppSignature())) continue;
                    sb.AppendLine($"{method.GetCppSignature()};");
                }
                continue;
            }

            foreach (var method in type.Methods)
            {
                if (method.IsAbstract || method.IsInternalCall) continue;
                if (method.BasicBlocks.Count == 0 && !method.IsPInvoke) continue;
                // Core runtime types (Object, String, Array, etc.): only emit static methods.
                // Non-core RuntimeProvided types (Task, Thread, CancellationToken) emit all methods.
                if (type.IsRuntimeProvided && !method.IsStatic
                    && IRBuilder.CoreRuntimeTypes.Contains(type.ILFullName)) continue;
                // Skip methods whose parameter/return types reference unknown struct types
                if (HasUnknownParameterTypes(method, knownTypeNames)) continue;
                if (!emittedMethodDecls.Add(method.GetCppSignature())) continue;
                sb.AppendLine($"{method.GetCppSignature()};");
            }
            sb.AppendLine();
        }

        // Generate stub declarations for methods called but not declared.
        // This handles methods on RuntimeProvided types and types not in the module.
        GenerateMissingMethodStubs(sb, emittedMethodDecls, userTypes, knownTypeNames);

        // Populate the declared function names and param counts for use by source generation.
        // This allows the source generator to filter out methods that call undeclared functions
        // or methods that call functions with wrong arg counts (overload mismatches).
        _declaredFunctionNames = ExtractFunctionNamesFromSignatures(emittedMethodDecls);
        _declaredFunctionParamCounts = ExtractFunctionParamCounts(emittedMethodDecls);

        // Static constructor guard declarations
        foreach (var type in userTypes)
        {
            if (type.HasCctor)
            {
                sb.AppendLine($"void {type.CppName}_ensure_cctor();");
            }
        }
        if (userTypes.Any(t => t.HasCctor))
            sb.AppendLine();

        // String literal initializer and extern declarations
        if (_module.StringLiterals.Count > 0)
        {
            sb.AppendLine("// String literal initializer");
            sb.AppendLine("void __init_string_literals();");
            sb.AppendLine();

            // Extern declarations for string literal variables (defined in data file)
            sb.AppendLine("// String literal extern declarations");
            foreach (var (_, literal) in _module.StringLiterals)
            {
                sb.AppendLine($"extern cil2cpp::String* {literal.Id};");
            }
            sb.AppendLine();
        }

        // Extern declarations for array initializer data (defined in data file)
        if (_module.ArrayInitDataBlobs.Count > 0)
        {
            sb.AppendLine("// Array initializer data extern declarations");
            foreach (var blob in _module.ArrayInitDataBlobs)
            {
                sb.AppendLine($"extern const unsigned char {blob.Id}[];");
            }
            sb.AppendLine();
        }

        return new GeneratedFile
        {
            FileName = $"{_module.Name}.h",
            Content = sb.ToString()
        };
    }

    private void GenerateStructDefinition(StringBuilder sb, IRType type, HashSet<string>? definedTypes = null)
    {
        sb.AppendLine($"// {type.ILFullName}");

        if (type.IsValueType)
        {
            sb.AppendLine($"struct {type.CppName} {{");
        }
        else
        {
            sb.AppendLine($"struct {type.CppName} {{");
            sb.AppendLine($"    cil2cpp::TypeInfo* __type_info;");
            sb.AppendLine($"    cil2cpp::UInt32 __sync_block;");

            // Base type fields (walk full inheritance chain)
            var inheritedFields = CollectInheritedFields(type);
            // Track inherited field names to avoid duplicate own fields (C2086)
            var inheritedFieldNames = new HashSet<string>();
            if (inheritedFields.Count > 0)
            {
                sb.AppendLine($"    // Inherited fields");
                foreach (var (field, fromType) in inheritedFields)
                {
                    var cppType = SanitizeFieldType(field.FieldTypeName, definedTypes);
                    sb.AppendLine($"    {cppType} {field.CppName}; // from {fromType.ILFullName}");
                    inheritedFieldNames.Add(field.CppName);
                }
            }

            // Own fields (skip fields already emitted as inherited)
            foreach (var field in type.Fields)
            {
                if (inheritedFieldNames.Contains(field.CppName)) continue;
                var cppType = SanitizeFieldType(field.FieldTypeName, definedTypes);
                sb.AppendLine($"    {cppType} {field.CppName};");
            }

            sb.AppendLine("};");
            sb.AppendLine();
            return;
        }

        if (type.ExplicitSize > 0)
        {
            // Types with explicit ClassSize metadata (ECMA-335 II.10.1.2).
            // Three sub-cases:
            //   1. FixedBuffer: single FixedElementField → emit as C array
            //   2. StaticArrayInitTypeSize: no fields → emit raw byte array
            //   3. Other: has fields + explicit size → emit fields + padding

            if (type.Fields.Count == 1 && type.Fields[0].Name == "FixedElementField")
            {
                // Case 1: Fixed-size buffer (C# fixed keyword / [InlineArray])
                var field = type.Fields[0];
                var cppType = SanitizeFieldType(field.FieldTypeName, definedTypes);
                int elemSize = GetPrimitiveSize(cppType);
                if (elemSize > 0)
                {
                    int count = type.ExplicitSize / elemSize;
                    sb.AppendLine($"    {cppType} {field.CppName}[{count}];");
                }
                else
                {
                    // Fallback: emit as raw byte array to guarantee correct sizeof
                    sb.AppendLine($"    uint8_t {field.CppName}[{type.ExplicitSize}]; // FIXME: unknown element type '{cppType}'");
                }
            }
            else if (type.Fields.Count == 0)
            {
                // Case 2: Opaque sized type (e.g., __StaticArrayInitTypeSize=N)
                sb.AppendLine($"    uint8_t __data[{type.ExplicitSize}];");
            }
            else
            {
                // Case 3: Regular struct with explicit size — emit fields + tail padding
                foreach (var field in type.Fields)
                {
                    var cppType = SanitizeFieldType(field.FieldTypeName, definedTypes);
                    sb.AppendLine($"    {cppType} {field.CppName};");
                }
            }
        }
        else
        {
            // Normal value type: emit fields as-is
            foreach (var field in type.Fields)
            {
                var cppType = SanitizeFieldType(field.FieldTypeName, definedTypes);
                sb.AppendLine($"    {cppType} {field.CppName};");
            }
        }

        sb.AppendLine("};");
        sb.AppendLine();
    }

    /// <summary>
    /// Try to forward-declare a type name if it's a pointer type to an unknown struct.
    /// </summary>
    private static void TryForwardDeclare(StringBuilder sb, string cppTypeName,
        HashSet<string> forwardDeclared, HashSet<string> aliasedTypes, HashSet<string> enumTypes)
    {
        var raw = cppTypeName.TrimEnd('*').Trim();
        if (raw.Length == 0 || raw.StartsWith("cil2cpp::") || IsCppPrimitiveType(raw)) return;
        if (aliasedTypes.Contains(raw)) return;
        if (!IsValidCppIdentifier(raw)) return;
        if (enumTypes.Contains(raw)) return;
        if (!forwardDeclared.Contains(raw))
        {
            sb.AppendLine($"struct {raw};");
            forwardDeclared.Add(raw);
        }
    }

    /// <summary>
    /// Sanitize a field type for struct definition.
    /// If the type is a pointer to an unknown type, replace with void*.
    /// If the type is a value type not in the known set, it should have been stubbed.
    /// </summary>
    private static string SanitizeFieldType(string fieldTypeName, HashSet<string>? definedTypes)
    {
        var cppType = CppNameMapper.GetCppTypeForDecl(fieldTypeName);
        if (definedTypes == null) return cppType;

        // Check if the raw type name (without *) is known
        var rawType = cppType.TrimEnd('*').Trim();
        if (rawType.Length == 0 || rawType.StartsWith("cil2cpp::") || IsCppPrimitiveType(rawType))
            return cppType;

        if (!definedTypes.Contains(rawType))
        {
            // Unknown type — replace pointer fields with void*
            if (cppType.EndsWith("*"))
                return "void*";
            // Non-pointer unknown → should have been stubbed, but fallback to void*
            return "void*";
        }

        return cppType;
    }

    /// <summary>
    /// Collect unknown value types used as non-pointer fields in any struct.
    /// These need stub struct definitions to avoid C++ errors.
    /// </summary>
    private static void CollectUnknownValueTypeFields(
        List<IRType> types, HashSet<string> definedTypes, HashSet<string> stubs)
    {
        foreach (var type in types)
        {
            if (type.IsEnum || type.IsDelegate) continue;
            foreach (var field in type.Fields)
            {
                CheckFieldForStub(field.FieldTypeName, definedTypes, stubs);
            }
            // Also check inherited fields for reference types
            if (!type.IsValueType)
            {
                var inherited = CollectInheritedFields(type);
                foreach (var (field, _) in inherited)
                    CheckFieldForStub(field.FieldTypeName, definedTypes, stubs);
            }
            // Check static fields
            foreach (var field in type.StaticFields)
                CheckFieldForStub(field.FieldTypeName, definedTypes, stubs);
        }
    }

    private static void CheckFieldForStub(string fieldTypeName, HashSet<string> definedTypes, HashSet<string> stubs)
    {
        var cppType = CppNameMapper.GetCppTypeForDecl(fieldTypeName);
        if (cppType.EndsWith("*")) return; // Pointers will be replaced with void*
        var rawType = cppType.Trim();
        if (rawType.Length == 0 || rawType.StartsWith("cil2cpp::") || IsCppPrimitiveType(rawType)) return;
        if (definedTypes.Contains(rawType)) return;
        if (!IsValidCppIdentifier(rawType)) return;
        stubs.Add(rawType);
    }

    /// <summary>
    /// Topologically sort struct types by value-type field dependencies.
    /// If struct A has a non-pointer field of type B, B must come before A.
    /// </summary>
    private static List<IRType> TopologicalSortByFieldDeps(List<IRType> types, HashSet<string> aliasedTypes)
    {
        var typeMap = new Dictionary<string, IRType>();
        foreach (var t in types)
            typeMap[t.CppName] = t;

        var visited = new HashSet<string>();
        var inStack = new HashSet<string>();
        var result = new List<IRType>();

        foreach (var t in types)
        {
            if (!visited.Contains(t.CppName))
                TopoVisit(t, typeMap, aliasedTypes, visited, inStack, result);
        }

        return result;
    }

    private static void TopoVisit(IRType type, Dictionary<string, IRType> typeMap,
        HashSet<string> aliasedTypes, HashSet<string> visited, HashSet<string> inStack,
        List<IRType> result)
    {
        if (visited.Contains(type.CppName)) return;
        if (inStack.Contains(type.CppName)) return; // Cycle — break it

        inStack.Add(type.CppName);

        // Collect all field types (own + inherited)
        var allFields = new List<string>();
        foreach (var f in type.Fields)
            allFields.Add(f.FieldTypeName);
        if (!type.IsValueType)
        {
            var inherited = CollectInheritedFields(type);
            foreach (var (f, _) in inherited)
                allFields.Add(f.FieldTypeName);
        }
        foreach (var f in type.StaticFields)
            allFields.Add(f.FieldTypeName);

        foreach (var fieldTypeName in allFields)
        {
            var cppType = CppNameMapper.GetCppTypeForDecl(fieldTypeName);
            if (cppType.EndsWith("*")) continue; // Pointers don't need ordering
            var rawType = cppType.Trim();
            if (rawType.StartsWith("cil2cpp::") || IsCppPrimitiveType(rawType)) continue;
            if (aliasedTypes.Contains(rawType)) continue;
            if (typeMap.TryGetValue(rawType, out var dep))
                TopoVisit(dep, typeMap, aliasedTypes, visited, inStack, result);
        }

        inStack.Remove(type.CppName);
        visited.Add(type.CppName);
        result.Add(type);
    }

    private static List<(IRField Field, IRType FromType)> CollectInheritedFields(IRType type)
    {
        var result = new List<(IRField, IRType)>();
        var ancestors = new List<IRType>();
        var current = type.BaseType;
        while (current != null && current.ILFullName != "System.Object")
        {
            ancestors.Add(current);
            current = current.BaseType;
        }
        ancestors.Reverse(); // furthest ancestor first
        foreach (var ancestor in ancestors)
        {
            foreach (var field in ancestor.Fields)
                result.Add((field, ancestor));
        }
        return result;
    }

    /// <summary>
    /// Returns true if any parameter or return type references a non-pointer struct not in the known type set.
    /// This filters out BCL methods that reference types not in the compilation unit (e.g. Func&lt;T&gt;).
    /// Pointer-type parameters only need forward declarations, which are generated automatically.
    /// </summary>
    private static bool HasUnknownParameterTypes(IRMethod method, HashSet<string> knownTypeNames)
    {
        // Check for function pointer types (IL function pointer types have "()" syntax in type names
        // or produce "method" prefix in mangled names)
        foreach (var param in method.Parameters)
        {
            if (param.CppTypeName.Contains("(") || param.CppTypeName.Contains(")")
                || param.CppTypeName.StartsWith("method"))
                return true;
        }
        if (method.ReturnTypeCpp.Contains("(") || method.ReturnTypeCpp.Contains(")")
            || method.ReturnTypeCpp.StartsWith("method"))
            return true;

        // Check return type
        if (!string.IsNullOrEmpty(method.ReturnTypeCpp))
        {
            var retType = method.ReturnTypeCpp;
            if (!IsValidCppIdentifier(retType.TrimEnd('*').Trim()) && !retType.StartsWith("cil2cpp::"))
                return true;
            var retTypeName = retType.TrimEnd('*').Trim();
            if (retTypeName.Length > 0 && !retTypeName.StartsWith("cil2cpp::") && !IsCppPrimitiveType(retTypeName))
            {
                if (IsUnresolvedGenericParam(retTypeName)) return true;
                if (!retType.EndsWith("*") && !knownTypeNames.Contains(retTypeName))
                    return true;
            }
        }
        foreach (var param in method.Parameters)
        {
            var rawType = param.CppTypeName;
            // Filter function pointer types (contain parentheses or "method" prefix)
            if (!IsValidCppIdentifier(rawType.TrimEnd('*').Trim()) && !rawType.StartsWith("cil2cpp::"))
                return true;
            var typeName = rawType.TrimEnd('*').Trim();
            // Skip known runtime types (cil2cpp:: namespace, primitive C++ types)
            if (typeName.StartsWith("cil2cpp::") || IsCppPrimitiveType(typeName)) continue;
            // Unresolved generic param names (TOther, TArg1, TNegator, etc.)
            if (IsUnresolvedGenericParam(typeName)) return true;
            // Pointer-type params: check for bare unresolved generic param names
            if (rawType.EndsWith("*"))
            {
                if (typeName.Length > 0 && !typeName.Contains('_') && !knownTypeNames.Contains(typeName))
                    return true;
                continue;
            }
            // Non-pointer unknown struct: the body would need the full type definition
            if (typeName.Length > 0 && !knownTypeNames.Contains(typeName))
                return true;
        }
        return false;
    }

    /// <summary>
    /// Check if method body references undefined non-pointer value types in locals.
    /// Methods with such references would produce C++ compilation errors (undefined struct).
    /// </summary>
    private static bool HasUnknownBodyReferences(IRMethod method, HashSet<string> knownTypeNames)
    {
        // Check local variables for references to undefined types
        foreach (var local in method.Locals)
        {
            var baseType = local.CppTypeName.TrimEnd('*').Trim();
            if (string.IsNullOrEmpty(baseType)) continue;
            if (baseType.StartsWith("cil2cpp::") || IsCppPrimitiveType(baseType)) continue;
            if (!knownTypeNames.Contains(baseType))
            {
                // For pointer types, the base type must still be either known or a valid forward-declared type.
                // Unresolved generic params (TChar, T1, TKey, etc.) are NOT known types.
                if (local.CppTypeName.EndsWith("*"))
                {
                    // Pointer to unknown type is only OK if the base type looks like a
                    // regular user/BCL type (contains underscore from namespace mangling)
                    // AND the type is actually known (has a forward declaration).
                    // Raw single-word types like TChar, T1, TKey are unresolved generic params.
                    if (!baseType.Contains('_'))
                        return true;
                    // Also reject if the type is not in knownTypeNames
                    // (no forward declaration → C2065 undeclared identifier)
                    if (!knownTypeNames.Contains(baseType))
                        return true;
                    continue; // pointer to known type — forward decl suffices
                }
                return true; // non-pointer value type must be fully defined
            }
        }

        // Check body instructions for references to undefined types
        foreach (var block in method.BasicBlocks)
        {
            foreach (var instr in block.Instructions)
            {
                if (HasUnknownInstructionReference(instr, knownTypeNames))
                    return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Check if a single instruction references an undefined type (struct, sizeof, function call).
    /// </summary>
    private static bool HasUnknownInstructionReference(IRInstruction instr, HashSet<string> knownTypeNames)
    {
        // IRNewObj: TypeCppName must be known (generates sizeof(TypeCppName))
        if (instr is IRNewObj newObj)
        {
            if (IsUnknownValueType(newObj.TypeCppName, knownTypeNames))
                return true;
        }

        // IRRawCpp: check for sizeof(TypeName) and TypeName local declarations
        if (instr is IRRawCpp rawCpp)
        {
            var code = rawCpp.Code;
            // Check sizeof(X) patterns
            int idx = 0;
            while ((idx = code.IndexOf("sizeof(", idx)) >= 0)
            {
                var start = idx + 7;
                var end = code.IndexOf(')', start);
                if (end > start)
                {
                    var typeName = code[start..end].Trim();
                    if (IsUnknownValueType(typeName, knownTypeNames))
                        return true;
                }
                idx = start;
            }
            // Check for value-type local declarations
            if (rawCpp.ResultTypeCpp != null && IsUnknownValueType(rawCpp.ResultTypeCpp, knownTypeNames))
                return true;
        }

        // IRCall: check if function targets a type not in knownTypeNames
        if (instr is IRCall call && !call.IsVirtual
                 && !string.IsNullOrEmpty(call.FunctionName)
                 && !call.FunctionName.StartsWith("cil2cpp::"))
        {
            if (IsCallToUnknownType(call.FunctionName, knownTypeNames))
                return true;
        }

        // IRCast: check TargetTypeCpp for unknown types (catches unresolved generic params T1/T2/TKey etc.)
        if (instr is IRCast cast)
        {
            if (IsUnknownTypeReference(cast.TargetTypeCpp, knownTypeNames))
                return true;
        }

        // Catch-all: scan the rendered C++ code for unresolved generic parameter names
        // These are single-word type names (no underscores) used in casts like (T1*), (TChar*), etc.
        var renderedCpp = instr.ToCpp();
        if (HasUnresolvedGenericParamInCode(renderedCpp, knownTypeNames))
            return true;

        // Check for unresolved function pointer types: method<Type>_ptr patterns
        // These are IL delegate/function-pointer types that weren't resolved to proper C++ syntax.
        if (renderedCpp.Contains("method") && renderedCpp.Contains("_ptr"))
            return true;

        return false;
    }

    /// <summary>
    /// Check if a type name references an undefined non-pointer value type.
    /// </summary>
    private static bool IsUnknownValueType(string typeRef, HashSet<string> knownTypeNames)
    {
        if (string.IsNullOrEmpty(typeRef)) return false;
        var typeName = typeRef.TrimEnd('*').Trim();
        if (string.IsNullOrEmpty(typeName)) return false;
        if (typeRef.EndsWith("*")) return false; // pointer types only need forward decl
        if (typeName.StartsWith("cil2cpp::") || IsCppPrimitiveType(typeName)) return false;
        return !knownTypeNames.Contains(typeName);
    }

    /// <summary>
    /// Check if a type reference (including pointer forms) refers to an unknown type.
    /// Unlike IsUnknownValueType, this also catches unresolved generic params in pointer form
    /// (e.g., T1*, TChar**, TKey*) which are single-word names with no namespace mangling.
    /// </summary>
    private static bool IsUnknownTypeReference(string typeRef, HashSet<string> knownTypeNames)
    {
        if (string.IsNullOrEmpty(typeRef)) return false;
        var baseType = typeRef.TrimEnd('*').Trim();
        if (string.IsNullOrEmpty(baseType)) return false;
        if (baseType.StartsWith("cil2cpp::") || IsCppPrimitiveType(baseType)) return false;
        if (knownTypeNames.Contains(baseType)) return false;
        // Unknown base type — could be an unresolved generic param (TChar, T1, TKey, etc.)
        // These are single-word identifiers without namespace underscores.
        // Regular mangled types always have underscores (System_Int32, MyNs_MyType, etc.)
        if (!baseType.Contains('_')) return true;
        // For pointer types, the base type is unknown but looks like a mangled type name
        // — that's OK, it just needs a forward declaration
        if (typeRef.EndsWith("*")) return false;
        // Non-pointer unknown type — must be fully defined
        return true;
    }

    /// <summary>
    /// Scan rendered C++ code for unresolved generic parameter names in cast expressions.
    /// Looks for patterns like (T1*), (TChar*), (TKey*) where the type name is a single word
    /// without underscores (indicating it's a generic param, not a mangled namespace type).
    /// </summary>
    private static bool HasUnresolvedGenericParamInCode(string code, HashSet<string> knownTypeNames)
    {
        // Scan for cast patterns: (TypeName*) or (TypeName)
        int i = 0;
        while (i < code.Length)
        {
            if (code[i] == '(' && i + 1 < code.Length && char.IsUpper(code[i + 1]))
            {
                // Found '(' followed by uppercase — could be a cast
                int start = i + 1;
                int end = start;
                while (end < code.Length && (char.IsLetterOrDigit(code[end]) || code[end] == '_'))
                    end++;
                // Strip trailing * for pointer casts
                int nameEnd = end;
                while (nameEnd < code.Length && code[nameEnd] == '*') nameEnd++;
                if (nameEnd < code.Length && code[nameEnd] == ')')
                {
                    var typeName = code[start..end];
                    // Single-word uppercase name without underscores = likely unresolved generic param
                    if (typeName.Length >= 1 && !typeName.Contains('_')
                        && !IsCppPrimitiveType(typeName) && typeName != "Object"
                        && !knownTypeNames.Contains(typeName))
                        return true;
                }
            }
            i++;
        }
        return false;
    }

    /// <summary>
    /// Check if a function call targets a method on a type not in knownTypeNames.
    /// Function names follow the pattern TypeCppName_MethodName or TypeCppName__MethodName.
    /// </summary>
    private static bool IsCallToUnknownType(string functionName, HashSet<string> knownTypeNames)
    {
        // Try to find the type prefix: scan from right, try each underscore position
        // as a potential type/method separator
        for (int i = functionName.Length - 1; i >= 0; i--)
        {
            if (functionName[i] != '_') continue;
            var prefix = functionName[..i];
            if (string.IsNullOrEmpty(prefix)) continue;
            // Check if this prefix is a known type (with or without trailing underscore)
            if (knownTypeNames.Contains(prefix))
                return false; // found known type — call is valid
            if (prefix.EndsWith("_") && knownTypeNames.Contains(prefix.TrimEnd('_')))
                return false;
        }
        // No known type prefix found — this targets an unknown type
        return true;
    }

    private static bool IsCppPrimitiveType(string typeName)
    {
        return typeName is "bool" or "int8_t" or "uint8_t" or "int16_t" or "uint16_t"
            or "int32_t" or "uint32_t" or "int64_t" or "uint64_t" or "float" or "double"
            or "char16_t" or "intptr_t" or "uintptr_t" or "void";
    }

    /// <summary>
    /// Get the size in bytes of a C++ primitive type name.
    /// Returns 0 for unknown / non-primitive types.
    /// </summary>
    private static int GetPrimitiveSize(string cppType)
    {
        return cppType switch
        {
            "bool" or "int8_t" or "uint8_t" => 1,
            "int16_t" or "uint16_t" or "char16_t" => 2,
            "int32_t" or "uint32_t" or "float" => 4,
            "int64_t" or "uint64_t" or "double" => 8,
            "intptr_t" or "uintptr_t" => 8, // 64-bit assumption
            _ => 0,
        };
    }

    /// <summary>
    /// Get using aliases for runtime-provided types (mangled name → cil2cpp:: struct).
    /// </summary>
    private static IEnumerable<(string Mangled, string CppAlias)> GetRuntimeProvidedTypeAliases()
    {
        // Core runtime types
        yield return ("System_Object", "cil2cpp::Object");
        yield return ("System_String", "cil2cpp::String");
        yield return ("System_Array", "cil2cpp::Array");
        yield return ("System_Delegate", "cil2cpp::Delegate");
        yield return ("System_MulticastDelegate", "cil2cpp::Delegate");
        yield return ("System_Type", "cil2cpp::Object");  // Type represented as opaque pointer
        yield return ("System_RuntimeType", "cil2cpp::Type");  // Phase I.2: RuntimeType = Type (Unity IL2CPP pattern)
        yield return ("System_Attribute", "cil2cpp::Object");  // Base class for all attributes
        yield return ("System_Enum", "cil2cpp::Object");  // Abstract base for enums — same layout as Object
        yield return ("System_ValueType", "cil2cpp::Object");  // Abstract base for value types — same layout as Object

        // Exception hierarchy — all map to runtime C++ exception types
        yield return ("System_Exception", "cil2cpp::Exception");
        yield return ("System_NullReferenceException", "cil2cpp::NullReferenceException");
        yield return ("System_IndexOutOfRangeException", "cil2cpp::IndexOutOfRangeException");
        yield return ("System_InvalidCastException", "cil2cpp::InvalidCastException");
        yield return ("System_InvalidOperationException", "cil2cpp::InvalidOperationException");
        yield return ("System_ObjectDisposedException", "cil2cpp::ObjectDisposedException");
        yield return ("System_NotSupportedException", "cil2cpp::NotSupportedException");
        yield return ("System_PlatformNotSupportedException", "cil2cpp::PlatformNotSupportedException");
        yield return ("System_NotImplementedException", "cil2cpp::NotImplementedException");
        yield return ("System_ArgumentException", "cil2cpp::ArgumentException");
        yield return ("System_ArgumentNullException", "cil2cpp::ArgumentNullException");
        yield return ("System_ArgumentOutOfRangeException", "cil2cpp::ArgumentOutOfRangeException");
        yield return ("System_ArithmeticException", "cil2cpp::ArithmeticException");
        yield return ("System_OverflowException", "cil2cpp::OverflowException");
        yield return ("System_DivideByZeroException", "cil2cpp::DivideByZeroException");
        yield return ("System_FormatException", "cil2cpp::FormatException");
        yield return ("System_RankException", "cil2cpp::RankException");
        yield return ("System_ArrayTypeMismatchException", "cil2cpp::ArrayTypeMismatchException");
        yield return ("System_TypeInitializationException", "cil2cpp::TypeInitializationException");
        yield return ("System_TimeoutException", "cil2cpp::TimeoutException");
        yield return ("System_AggregateException", "cil2cpp::AggregateException");
        yield return ("System_OperationCanceledException", "cil2cpp::OperationCanceledException");
        yield return ("System_Threading_Tasks_TaskCanceledException", "cil2cpp::TaskCanceledException");
        yield return ("System_Collections_Generic_KeyNotFoundException", "cil2cpp::KeyNotFoundException");

        // Phase II.3: Runtime reflection subtypes → existing runtime structs
        yield return ("System_Reflection_RuntimeMethodInfo", "cil2cpp::ManagedMethodInfo");
        yield return ("System_Reflection_RuntimeFieldInfo", "cil2cpp::ManagedFieldInfo");
        yield return ("System_Reflection_RuntimeConstructorInfo", "cil2cpp::ManagedMethodInfo");
        yield return ("System_Reflection_TypeInfo", "cil2cpp::Type");
        // Phase II.4: New runtime structs for Assembly + PropertyInfo
        yield return ("System_Reflection_RuntimePropertyInfo", "cil2cpp::ManagedPropertyInfo");
        yield return ("System_Reflection_Assembly", "cil2cpp::ManagedAssembly");
        yield return ("System_Reflection_RuntimeAssembly", "cil2cpp::ManagedAssembly");
        // Phase II.5: WaitHandle hierarchy
        yield return ("System_Threading_WaitHandle", "cil2cpp::ManagedWaitHandle");
        yield return ("System_Threading_EventWaitHandle", "cil2cpp::ManagedEventWaitHandle");
        yield return ("System_Threading_ManualResetEvent", "cil2cpp::ManagedEventWaitHandle");
        yield return ("System_Threading_AutoResetEvent", "cil2cpp::ManagedEventWaitHandle");
        yield return ("System_Threading_Mutex", "cil2cpp::ManagedMutex");
        yield return ("System_Threading_Semaphore", "cil2cpp::ManagedSemaphore");
    }

    /// <summary>
    /// Get using aliases for primitive types (mangled name → C++ built-in type).
    /// Primitive types map directly to C++ built-in types; no struct is emitted.
    /// </summary>
    private static IEnumerable<(string Mangled, string CppAlias)> GetPrimitiveTypeAliases()
    {
        yield return ("System_Boolean", "bool");
        yield return ("System_Byte", "uint8_t");
        yield return ("System_SByte", "int8_t");
        yield return ("System_Int16", "int16_t");
        yield return ("System_UInt16", "uint16_t");
        yield return ("System_Int32", "int32_t");
        yield return ("System_UInt32", "uint32_t");
        yield return ("System_Int64", "int64_t");
        yield return ("System_UInt64", "uint64_t");
        yield return ("System_Single", "float");
        yield return ("System_Double", "double");
        yield return ("System_Char", "char16_t");
        yield return ("System_IntPtr", "intptr_t");
        yield return ("System_UIntPtr", "uintptr_t");
    }

    /// <summary>
    /// Types whose "using System_X = cil2cpp::Y;" alias is already defined in runtime headers
    /// (task.h, memberinfo.h, cancellation.h, async_enumerable.h).
    /// The codegen must NOT emit struct definitions OR using aliases for these —
    /// the runtime headers handle both.
    /// </summary>
    private static readonly HashSet<string> RuntimeHeaderAliasedTypes = new()
    {
        // task.h
        "System_Threading_Tasks_Task",
        "System_Runtime_CompilerServices_TaskAwaiter",
        "System_Runtime_CompilerServices_AsyncTaskMethodBuilder",
        "System_Runtime_CompilerServices_IAsyncStateMachine",
        // memberinfo.h
        "System_Reflection_MemberInfo",
        "System_Reflection_MethodBase",
        "System_Reflection_MethodInfo",
        "System_Reflection_FieldInfo",
        "System_Reflection_ParameterInfo",
        // cancellation.h
        "System_Threading_CancellationTokenSource",
        "System_Threading_CancellationToken",
        // async_enumerable.h
        "System_Threading_Tasks_ValueTask",
        "System_Runtime_CompilerServices_ValueTaskAwaiter",
        "System_Runtime_CompilerServices_AsyncIteratorMethodBuilder",
        // threading.h — ManagedThread is in cil2cpp namespace but no using alias;
        // still needs to be skipped since runtime defines the struct
        "System_Threading_Thread",
        // typed_reference.h
        "System_TypedReference",
        "System_ArgIterator",
        // Phase II.3: Runtime reflection subtypes — aliases in memberinfo.h / reflection.h
        "System_Reflection_RuntimeMethodInfo",
        "System_Reflection_RuntimeFieldInfo",
        "System_Reflection_RuntimeConstructorInfo",
        "System_Reflection_TypeInfo",
        // Phase II.4: Assembly + PropertyInfo — aliases in assembly.h
        "System_Reflection_RuntimePropertyInfo",
        "System_Reflection_Assembly",
        "System_Reflection_RuntimeAssembly",
        // Phase II.5: WaitHandle hierarchy — aliases in waithandle.h
        "System_Threading_WaitHandle",
        "System_Threading_EventWaitHandle",
        "System_Threading_ManualResetEvent",
        "System_Threading_AutoResetEvent",
        "System_Threading_Mutex",
        "System_Threading_Semaphore",
    };

    /// <summary>
    /// Get TypeInfo reference aliases for runtime exception types.
    /// Maps mangled IL names (System_Exception) to runtime-declared TypeInfo names (cil2cpp::Exception_TypeInfo).
    /// Used by castclass/isinst/catch to reference exception TypeInfos by their mangled names.
    /// </summary>
    private static IEnumerable<(string MangledName, string RuntimeTypeInfoName)> GetExceptionTypeInfoAliases()
    {
        yield return ("System_Exception", "cil2cpp::Exception_TypeInfo");
        yield return ("System_NullReferenceException", "cil2cpp::NullReferenceException_TypeInfo");
        yield return ("System_IndexOutOfRangeException", "cil2cpp::IndexOutOfRangeException_TypeInfo");
        yield return ("System_InvalidCastException", "cil2cpp::InvalidCastException_TypeInfo");
        yield return ("System_InvalidOperationException", "cil2cpp::InvalidOperationException_TypeInfo");
        yield return ("System_ObjectDisposedException", "cil2cpp::ObjectDisposedException_TypeInfo");
        yield return ("System_NotSupportedException", "cil2cpp::NotSupportedException_TypeInfo");
        yield return ("System_PlatformNotSupportedException", "cil2cpp::PlatformNotSupportedException_TypeInfo");
        yield return ("System_NotImplementedException", "cil2cpp::NotImplementedException_TypeInfo");
        yield return ("System_ArgumentException", "cil2cpp::ArgumentException_TypeInfo");
        yield return ("System_ArgumentNullException", "cil2cpp::ArgumentNullException_TypeInfo");
        yield return ("System_ArgumentOutOfRangeException", "cil2cpp::ArgumentOutOfRangeException_TypeInfo");
        yield return ("System_ArithmeticException", "cil2cpp::ArithmeticException_TypeInfo");
        yield return ("System_OverflowException", "cil2cpp::OverflowException_TypeInfo");
        yield return ("System_DivideByZeroException", "cil2cpp::DivideByZeroException_TypeInfo");
        yield return ("System_FormatException", "cil2cpp::FormatException_TypeInfo");
        yield return ("System_RankException", "cil2cpp::RankException_TypeInfo");
        yield return ("System_ArrayTypeMismatchException", "cil2cpp::ArrayTypeMismatchException_TypeInfo");
        yield return ("System_TypeInitializationException", "cil2cpp::TypeInitializationException_TypeInfo");
        yield return ("System_TimeoutException", "cil2cpp::TimeoutException_TypeInfo");
        yield return ("System_AggregateException", "cil2cpp::AggregateException_TypeInfo");
        yield return ("System_OperationCanceledException", "cil2cpp::OperationCanceledException_TypeInfo");
        yield return ("System_Threading_Tasks_TaskCanceledException", "cil2cpp::TaskCanceledException_TypeInfo");
        yield return ("System_Collections_Generic_KeyNotFoundException", "cil2cpp::KeyNotFoundException_TypeInfo");
    }

    /// <summary>
    /// Runtime-provided base types that need stub TypeInfo definitions in generated code.
    /// These are referenced as .base_type for value types, enums, and delegates.
    /// </summary>
    private static IEnumerable<(string MangledName, string ILFullName)> GetRuntimeBaseTypeInfoStubs()
    {
        yield return ("System_ValueType", "System.ValueType");
        yield return ("System_Enum", "System.Enum");
        yield return ("System_MulticastDelegate", "System.MulticastDelegate");
        yield return ("System_Delegate", "System.Delegate");
    }

    /// <summary>
    /// Scan all method bodies for function calls, and generate stub declarations
    /// for any called function that wasn't declared. This handles methods on
    /// RuntimeProvided types and types not in the IR module.
    /// </summary>
    private void GenerateMissingMethodStubs(StringBuilder sb, HashSet<string> emittedMethodDecls,
        List<IR.IRType> userTypes, HashSet<string> knownTypeNames)
    {
        // Build lookup: method CppName → IRMethod (for finding signatures)
        var methodLookup = new Dictionary<string, IR.IRMethod>();
        foreach (var type in _module.Types)
        {
            foreach (var method in type.Methods)
            {
                methodLookup.TryAdd(method.CppName, method);
            }
        }

        // Collect all called function names from method bodies that WILL be compiled.
        // Only scan methods that pass the same filters as method implementation generation.
        var calledFunctions = new HashSet<string>();
        foreach (var type in userTypes)
        {
            if (type.IsDelegate || type.IsRuntimeProvided) continue;
            foreach (var method in type.Methods)
            {
                if (method.IsAbstract || method.IsInternalCall) continue;
                if (method.BasicBlocks.Count == 0 && !method.IsPInvoke) continue;
                // Only check methods that will actually be emitted
                if (!emittedMethodDecls.Contains(method.GetCppSignature())) continue;

                foreach (var block in method.BasicBlocks)
                {
                    foreach (var instr in block.Instructions)
                    {
                        if (instr is IR.IRCall call && !string.IsNullOrEmpty(call.FunctionName)
                            && !call.FunctionName.StartsWith("cil2cpp::"))
                            calledFunctions.Add(call.FunctionName);
                    }
                }
            }
        }

        // Find called functions that have no declaration
        var declaredNames = new HashSet<string>();
        foreach (var sig in emittedMethodDecls)
        {
            // Extract function name from signature: "retType funcName(..."
            var parenIdx = sig.IndexOf('(');
            if (parenIdx > 0)
            {
                var beforeParen = sig[..parenIdx].TrimEnd();
                var spaceIdx = beforeParen.LastIndexOf(' ');
                if (spaceIdx >= 0)
                    declaredNames.Add(beforeParen[(spaceIdx + 1)..]);
                // Handle pointer return types: "retType* funcName("
                var starIdx = beforeParen.LastIndexOf('*');
                if (starIdx > spaceIdx)
                    declaredNames.Add(beforeParen[(starIdx + 1)..].TrimStart());
            }
        }

        var missingFunctions = new List<(string name, IR.IRMethod? method)>();
        foreach (var funcName in calledFunctions)
        {
            if (declaredNames.Contains(funcName)) continue;
            methodLookup.TryGetValue(funcName, out var irMethod);
            missingFunctions.Add((funcName, irMethod));
        }

        if (missingFunctions.Count == 0) return;

        sb.AppendLine("// ===== Stub Declarations (methods on RuntimeProvided or unreachable types) =====");
        foreach (var (funcName, irMethod) in missingFunctions.OrderBy(m => m.name))
        {
            if (irMethod != null && !HasUnknownParameterTypes(irMethod, knownTypeNames))
            {
                var sig = irMethod.GetCppSignature();
                if (emittedMethodDecls.Add(sig))
                {
                    sb.AppendLine($"{sig};");
                    declaredNames.Add(funcName);
                }
            }
            else
            {
                // Unknown or complex signature — skip, will cause linker error if actually needed.
                // This is better than a compile error that blocks all other compilation.
            }
        }
        sb.AppendLine();
    }

    private void GenerateEnumDefinition(StringBuilder sb, IRType type)
    {
        var underlyingCppType = CppNameMapper.GetCppTypeForDecl(type.EnumUnderlyingType ?? "System.Int32");
        sb.AppendLine($"// {type.ILFullName} (enum)");
        sb.AppendLine($"using {type.CppName} = {underlyingCppType};");

        // Emit named constants
        foreach (var field in type.StaticFields)
        {
            if (field.ConstantValue != null)
            {
                sb.AppendLine($"constexpr {underlyingCppType} {type.CppName}_{field.CppName} = {field.ConstantValue};");
            }
        }
        sb.AppendLine();
    }

    /// <summary>
    /// Extract function names from C++ method signatures.
    /// Signature format: "retType funcName(params)" → extract "funcName".
    /// </summary>
    private static HashSet<string> ExtractFunctionNamesFromSignatures(HashSet<string> signatures)
    {
        var names = new HashSet<string>();
        foreach (var sig in signatures)
        {
            var parenIdx = sig.IndexOf('(');
            if (parenIdx <= 0) continue;

            var beforeParen = sig[..parenIdx].TrimEnd();
            var spaceIdx = beforeParen.LastIndexOf(' ');
            if (spaceIdx >= 0)
            {
                var name = beforeParen[(spaceIdx + 1)..];
                // Handle pointer return types: "retType* funcName"
                if (name.StartsWith("*"))
                    name = name.TrimStart('*');
                if (!string.IsNullOrEmpty(name))
                    names.Add(name);
            }
        }
        return names;
    }

    /// <summary>
    /// Check if a method's body calls functions that are not declared in the output,
    /// or calls functions with wrong number of arguments (overload mismatch).
    /// </summary>
    private bool CallsUndeclaredOrMismatchedFunctions(IR.IRMethod method)
    {
        if (_declaredFunctionNames.Count == 0) return false;

        foreach (var block in method.BasicBlocks)
        {
            foreach (var instr in block.Instructions)
            {
                if (instr is IR.IRCall call && !string.IsNullOrEmpty(call.FunctionName))
                {
                    var funcName = call.FunctionName;
                    if (funcName.StartsWith("cil2cpp::")) continue;
                    if (funcName.EndsWith("_ensure_cctor")) continue;
                    if (!_declaredFunctionNames.Contains(funcName))
                        return true;
                    if (_declaredFunctionParamCounts.TryGetValue(funcName, out var validCounts))
                    {
                        if (!validCounts.Contains(call.Arguments.Count))
                            return true;
                    }
                }
            }
        }
        return false;
    }

    /// <summary>
    /// Check if a method's rendered C++ body contains patterns known to cause MSVC errors.
    /// This is a post-IR check that catches issues not detectable at the IR level.
    /// </summary>
    private bool HasKnownBrokenPatterns(IR.IRMethod method, HashSet<string> knownTypeNames)
    {
        // JIT intrinsics have self-recursive IL bodies — the JIT replaces them with
        // CPU instructions or constants at runtime. AOT: detect and stub them.
        // Covers ALL System.Runtime.Intrinsics types including Vector base types.
        // Vector struct definitions are needed (for knownTypeNames) but their method bodies
        // contain SIMD-specific patterns (void* arithmetic, pointer casts) that can't compile.
        // Call sites are already intercepted in IRBuilder.Emit.cs (IsSupported=0, ops=default).
        if (method.DeclaringType?.ILFullName?.Contains("System.Runtime.Intrinsics") == true)
            return true;
        // SIMD-specific BCL method variants: hardware-accelerated implementations that contain
        // pointer arithmetic, alignment checks, and SIMD operations that can't compile to valid C++.
        // These methods have scalar fallback alternatives that the BCL dispatches to when IsSupported==false.
        if (method.Name.EndsWith("_Sse2") || method.Name.EndsWith("_Sse41") ||
            method.Name.EndsWith("_Sse3") || method.Name.EndsWith("_Avx") ||
            method.Name.EndsWith("_Avx2") || method.Name.EndsWith("_Intrinsified"))
            return true;
        // SIMD-heavy BCL internal types whose methods do pointer-to-integer casts for alignment checks
        if (method.DeclaringType?.ILFullName is "System.Text.Ascii"
                                              or "System.Text.Latin1Utility"
                                              or "System.Text.Utf16Utility"
                                              or "System.Buffers.IndexOfAnyAsciiSearcher")
            return true;
        // Detect self-recursion: method calls itself (JIT intrinsics with no real IL body)
        var selfCallPattern = $"{method.CppName}(";
        foreach (var block in method.BasicBlocks)
        {
            foreach (var instr in block.Instructions)
            {
                if (instr.ToCpp().Contains(selfCallPattern))
                    return true;
            }
        }

        foreach (var block in method.BasicBlocks)
        {
            foreach (var instr in block.Instructions)
            {
                if (InstructionHasBrokenPattern(instr, knownTypeNames))
                    return true;
            }
        }
        return false;
    }

    private static bool InstructionHasBrokenPattern(IR.IRInstruction instr, HashSet<string> knownTypeNames)
    {
        var code = instr.ToCpp();

        // Pattern 1: References to _TypeInfo that are not declared
        if (HasUndeclaredTypeInfoRef(code, knownTypeNames))
            return true;

        // Pattern 2: (uintptr_t) cast followed by struct field access
        if (code.Contains("(uintptr_t)(") && code.Contains(".f_"))
            return true;

        // Pattern 3: volatile_write with bool* (no matching template specialization)
        if (code.Contains("volatile_write((bool*)"))
            return true;

        // Pattern 4: removed — Unsafe specializations now compile as valid C++ functions.
        // Callers of broken Unsafe stubs are caught by stage 3 (CallsUndeclaredOrMismatchedFunctions).

        // Pattern 5: array_get/array_set/array_length called with non-Array argument
        if (code.Contains("array_length(0)"))
            return true;

        // Pattern 6: removed

        // Pattern 7: Invalid stind pattern: &param = &local (address-of on both sides)
        if (code.StartsWith("&") && code.Contains(" = &"))
            return true;

        // Pattern 7b: GCFrameRegistration uses void** but locals may be intptr_t*
        if (code.Contains("GCFrameRegistration__ctor"))
            return true;

        // Pattern 8: (uintptr_t) cast ONLY when combined with struct member access
        // Standalone (uintptr_t)(ptr) is valid C++ for pointer→int conversion (e.g., fixed/Span)
        // Pattern 2 already catches (uintptr_t)( + .f_ — this catches additional struct patterns
        if (code.Contains("(uintptr_t)(") && (code.Contains("->f_") || code.Contains("sizeof(")))
            return true;

        // Pattern 9: Unresolved generic type params in interface vtable casts
        if (code.Contains("_1_T*") || code.Contains("_1_T,") || code.Contains("_2_T*")
            || code.Contains("_1_TKey*") || code.Contains("_1_TValue*")
            || code.Contains("_1_TResult*")
            || code.Contains("_1_TFrom") || code.Contains("_1_TTo"))
            return true;

        return false;
    }

    private static bool HasUndeclaredTypeInfoRef(string code, HashSet<string> knownTypeNames)
    {
        var tiIdx = 0;
        while ((tiIdx = code.IndexOf("_TypeInfo", tiIdx)) >= 0)
        {
            // Walk backward to find the type name
            int start = tiIdx - 1;
            while (start >= 0 && (char.IsLetterOrDigit(code[start]) || code[start] == '_'))
                start--;
            start++;
            if (start < tiIdx)
            {
                var typeName = code[start..tiIdx];
                // Skip cil2cpp:: prefixed TypeInfo refs
                if (start >= 2 && code.Length >= start && start >= 2
                    && code[(start - 2)..start] == "::")
                {
                    tiIdx += 9;
                    continue;
                }
                if (!string.IsNullOrEmpty(typeName) && !typeName.StartsWith("cil2cpp")
                    && !knownTypeNames.Contains(typeName))
                    return true;
            }
            tiIdx += 9;
        }
        return false;
    }

    /// <summary>
    /// Post-render validation: scan the fully rendered C++ body for patterns
    /// that will cause MSVC compilation errors. Used as a final safety net
    /// after all IR-level checks have passed.
    /// </summary>
    private bool RenderedBodyHasErrors(string rendered, IR.IRMethod method, HashSet<string>? knownTypes = null)
    {
        // Method-level check: __this referenced in static methods
        if (method.IsStatic && rendered.Contains("__this"))
            return true;

        // Method-level check: method returns intptr_t/uintptr_t but body has (void*) casts
        // that feed into return values (Unsafe.AsPointer producing void* that MSVC can't implicitly
        // convert to intptr_t). Detect any auto __tN = (void*)expr; return __tN; pattern.
        if (method.ReturnTypeCpp is "intptr_t" or "uintptr_t"
            && rendered.Contains("= (void*)"))
        {
            return true;
        }

        // Body-level check: gc_allocate_uninitialized_array returns void*, CompareExchange expects Array*
        if (rendered.Contains("gc_allocate_uninitialized_array") && rendered.Contains("CompareExchange"))
            return true;

        // Body-level check: undeclared Action<Object>.Invoke delegate specialization
        if (rendered.Contains("Action_1_System_Object_Invoke"))
            return true;

        // Body-level check: CancellationToken cast to String* in f_message assignment (BCL IL body bug)
        if (rendered.Contains("CancellationToken") && rendered.Contains("->f_message = (cil2cpp::String*)"))
            return true;

        // Body-level check: method takes ReadOnlySpan parameters but body calls compareinfo ICalls
        // that expect String* — the ReadOnlySpan struct can't convert to String*
        if (rendered.Contains("compareinfo_") && method.Parameters.Any(p =>
                p.CppTypeName.Contains("ReadOnlySpan_1_")))
            return true;

        // Body-level check: char16_t* pointer division — IL subtracts char16_t* pointers then
        // divides by 2, but in C++ pointer subtraction already gives element count.
        // Only flag when a temp assigned (char16_t*) is directly divided — NOT when
        // the division is on an intptr_t/ptrdiff_t from byte-level subtraction.
        {
            var char16Temps = new HashSet<string>();
            foreach (var ln in rendered.AsSpan().EnumerateLines())
            {
                var s = ln.ToString().TrimStart();
                // auto __tN = (char16_t*)expr;
                if (s.StartsWith("auto ") && s.Contains("= (char16_t*)"))
                {
                    var varEnd = s.IndexOf(' ', 5);
                    if (varEnd > 5) char16Temps.Add(s[5..varEnd]);
                }
            }
            if (char16Temps.Count > 0)
            {
                foreach (var ln in rendered.AsSpan().EnumerateLines())
                {
                    var s = ln.ToString().TrimStart();
                    foreach (var t in char16Temps)
                    {
                        if (s.Contains($"{t} / 2"))
                            return true;
                    }
                }
            }
        }

        // Check each line for known error patterns
        foreach (var line in rendered.AsSpan().EnumerateLines())
        {
            var s = line.ToString().TrimStart();
            if (s.Length == 0 || s.StartsWith("//") || s.StartsWith("#")) continue;

            if (RenderedLineHasError(s))
                return true;

            // Check for references to undeclared _statics globals
            var staticsIdx = s.IndexOf("_statics.", StringComparison.Ordinal);
            if (staticsIdx > 0)
            {
                // Extract type name before "_statics." — find the start of the identifier
                var start = staticsIdx - 1;
                while (start > 0 && (char.IsLetterOrDigit(s[start - 1]) || s[start - 1] == '_'))
                    start--;
                var typeName = s[start..staticsIdx];
                if (typeName.Length > 0 && knownTypes != null && !knownTypes.Contains(typeName))
                    return true;
            }
        }

        // Multi-line pattern: Object* variable from byref dereference used where typed ptr expected
        // Detects: __tN = *(cil2cpp::Object**)... then later:
        //   - array_length/__tN), array_get<...>(__tN,...), array_set etc.
        //   - comparisons with typed local variables (locN == __tN)
        //   - string_length(__tN)
        {
            var objectDerefTemps = new HashSet<string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                if (s.StartsWith("auto ") && s.Contains("= *(cil2cpp::Object**)"))
                {
                    var varEnd = s.IndexOf(' ', 5);
                    if (varEnd > 5)
                        objectDerefTemps.Add(s[5..varEnd]);
                }
            }
            if (objectDerefTemps.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    foreach (var temp in objectDerefTemps)
                    {
                        // Array operations (need Array*, get Object*)
                        if (s.Contains($"array_length({temp})") ||
                            s.Contains($"array_get<") && s.Contains($"({temp},") ||
                            s.Contains($"array_set<") && s.Contains($"({temp},") ||
                            s.Contains($"array_get_element_ptr({temp},"))
                            return true;
                        // String operations
                        if (s.Contains($"string_length({temp})"))
                            return true;
                        // Comparison involving objectDerefTemp (on either side)
                        if (s.Contains($"== {temp}") || s.Contains($"!= {temp}") ||
                            s.Contains($"{temp} ==") || s.Contains($"{temp} !="))
                            return true;
                    }
                }
            }
        }

        // Multi-line pattern: comparison of unrelated pointer types (C2446)
        // When a typed pointer (__this, parameter) is compared with Object* parameter/variable
        {
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                // Catches: __this != value, __this == value, comparer != __tN, etc.
                // where one side is Object* and the other is a typed pointer
                if ((s.Contains("__this != ") || s.Contains("__this == ") ||
                     s.Contains("!= value") || s.Contains("== value") ||
                     s.Contains("comparer != ") || s.Contains("comparer == ") ||
                     s.Contains("== __this") || s.Contains("!= __this")) &&
                    !s.Contains("(void*)") && !s.Contains("nullptr") &&
                    (s.Contains("__t") || s.Contains("value") || s.Contains("comparer") ||
                     s.Contains("obj") || s.Contains("other")))
                {
                    // Only flag if the function signature shows an Object* parameter
                    // (mixed type comparison is the issue)
                    if (method.Parameters.Any(p => p.CppTypeName == "cil2cpp::Object*"))
                        return true;
                }
            }
        }

        // Multi-line pattern: cross-scope variable declared as Object* but assigned value type
        // Detects: cil2cpp::Object* __tN = nullptr; ... __tN = intExpr / boolExpr / doubleExpr;
        {
            var objectPtrVars = new HashSet<string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                if (s.StartsWith("cil2cpp::Object* __t") && s.Contains("= nullptr;"))
                {
                    var varEnd = s.IndexOf(' ', 20);
                    if (varEnd > 20)
                        objectPtrVars.Add(s[20..varEnd]);
                }
            }
            if (objectPtrVars.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    foreach (var v in objectPtrVars)
                    {
                        var prefix = $"__t{v} = ";
                        if (!s.StartsWith(prefix)) continue;
                        var rhs = s[prefix.Length..].TrimEnd(';').Trim();
                        // __tN = expr == 0 / != 0 / != nullptr (assigns bool to Object*)
                        if (rhs.Contains("== 0") || rhs.Contains("!= 0") ||
                            rhs.Contains("!= nullptr") || rhs.Contains("== nullptr"))
                            return true;
                        // __tN = small_int; (assigns int literal to Object*)
                        if (rhs.Length > 0 && rhs.All(c => char.IsDigit(c) || c == '-' || c == '.'))
                            return true;
                        // __tN = expr + expr (arithmetic/bitwise — can't assign int result to Object*)
                        if (rhs.Contains(" + ") || rhs.Contains(" - ") || rhs.Contains(" * ")
                            || rhs.Contains(" / ") || rhs.Contains(" % ") || rhs.Contains(" | ")
                            || rhs.Contains(" & ") || rhs.Contains(" ^ "))
                            return true;
                        // __tN = expr < N / expr > N / expr <= N / expr >= N (comparison → bool, not Object*)
                        if (rhs.Contains(" < ") || rhs.Contains(" > ") ||
                            rhs.Contains(" <= ") || rhs.Contains(" >= "))
                            return true;
                        // __tN = -value (negation of non-pointer value)
                        if (rhs.StartsWith("-") && !rhs.Contains("nullptr") && !rhs.Contains("("))
                            return true;
                    }
                }
            }
        }

        // Multi-line pattern: cross-scope variable declared as non-pointer but assigned Object*
        // Detects: int32_t __tN = 0; or double __tN = 0; ... __tN = obj->field (which is Object*)
        {
            var nonPtrVarTypes = new Dictionary<string, string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                if (s.StartsWith("int32_t __t") || s.StartsWith("double __t") ||
                    s.StartsWith("int64_t __t") || s.StartsWith("float __t"))
                {
                    var spaceIdx = s.IndexOf(' ');
                    var eqIdx = s.IndexOf(' ', spaceIdx + 1);
                    if (spaceIdx > 0 && eqIdx > spaceIdx)
                    {
                        var varName = s[(spaceIdx + 1)..eqIdx];
                        nonPtrVarTypes[varName] = s[..spaceIdx];
                    }
                }
            }
            if (nonPtrVarTypes.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    foreach (var (varName, _) in nonPtrVarTypes)
                    {
                        // varName = (SomeType*)(void*) expr; — pointer assigned to int/double
                        if (s.StartsWith($"{varName} = ") && s.Contains("*)(void*)"))
                            return true;
                    }
                }
            }
        }

        // Multi-line pattern: cross-scope assignment without cast between incompatible types
        // __tN = (TypeA*)(void*)... then later __tN = __tM where __tM is different TypeB*
        // Only flag when the SAME __tN variable appears in both cast and plain assignment
        if (rendered.Contains("(void*)"))
        {
            var castVars = new HashSet<string>();
            var plainAssignVars = new HashSet<string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s2 = line.ToString().TrimStart();
                // Track __tN = (TypeA*)(void*)... → variable receives a pointer cast
                if (s2.StartsWith("__t") && !s2.StartsWith("__this") && s2.Contains("*)(void*)"))
                {
                    var eqIdx = s2.IndexOf(" = ");
                    if (eqIdx > 0)
                        castVars.Add(s2[..eqIdx]);
                }
                // Track __tN = __tM; → plain assignment without cast
                if (s2.StartsWith("__t") && !s2.StartsWith("__this") && s2.Contains(" = __t") && !s2.Contains("(") && s2.EndsWith(";"))
                {
                    var eqIdx = s2.IndexOf(" = ");
                    if (eqIdx > 0)
                        plainAssignVars.Add(s2[..eqIdx]);
                }
            }
            if (castVars.Overlaps(plainAssignVars))
                return true;
        }

        // Multi-line pattern: pointer variable accessed with dot instead of arrow
        // Detects locals assigned from pointer casts, auto temps, and pointer params
        {
            var ptrVars = new HashSet<string>();
            // Include pointer parameters (by-ref value type params are Type* in C++)
            // Exclude __this — always used with -> correctly
            foreach (var param in method.Parameters)
            {
                if (param.CppTypeName.EndsWith("*") && param.Name != "__this")
                    ptrVars.Add(param.Name);
            }
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s2 = line.ToString().TrimStart();
                // Detect: loc_N = (SomeType*)expr;
                if (s2.StartsWith("loc_") && s2.Contains(" = (") && s2.Contains("*)"))
                {
                    var spIdx = s2.IndexOf(' ');
                    if (spIdx > 0)
                        ptrVars.Add(s2[..spIdx]);
                }
                // Detect: auto __tN = (SomeType*)expr; (exclude derefs *(Type*))
                if (s2.StartsWith("auto __t") && s2.Contains("*)") &&
                    s2.Contains(" = (") && !s2.Contains(" = *("))
                {
                    var spIdx = s2.IndexOf(' ', 5); // after "auto "
                    if (spIdx > 5)
                        ptrVars.Add(s2[5..spIdx]);
                }
                // Detect: auto __tN = cil2cpp::unbox_ptr<...>(...); (returns pointer)
                if (s2.StartsWith("auto __t") && s2.Contains("unbox_ptr<"))
                {
                    var spIdx = s2.IndexOf(' ', 5); // after "auto "
                    if (spIdx > 5)
                        ptrVars.Add(s2[5..spIdx]);
                }
                // Detect: auto __tN = &expr; (address-of produces pointer)
                if (s2.StartsWith("auto __t") && s2.Contains(" = &"))
                {
                    var spIdx = s2.IndexOf(' ', 5); // after "auto "
                    if (spIdx > 5)
                        ptrVars.Add(s2[5..spIdx]);
                }
            }
            if (ptrVars.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s2 = line.ToString().TrimStart();
                    foreach (var v in ptrVars)
                    {
                        if (s2.Contains($"{v}.f_"))
                            return true;
                    }
                }
            }
        }

        // Multi-line pattern: array_get<T>/array_set<T> with reference type (value↔pointer mismatch)
        // array_get returns T by value — casting result to T* means it's a reference type array
        // array_set expects T by value — passing a T* pointer means it's a reference type array
        // Note: array_get<Object*>/array_set<Object*> are correct (pointer-type template arg)
        if (rendered.Contains("array_get<") || rendered.Contains("array_set<"))
        {
            var arrayGetVars = new HashSet<string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                // Track __tN assigned from array_get with NON-POINTER element type
                // array_get<Object*> returns a pointer — casting is fine, don't flag
                if (s.StartsWith("auto __t") && s.Contains("array_get<"))
                {
                    var getIdx = s.IndexOf("array_get<");
                    var closeAngle = s.IndexOf('>', getIdx + 10);
                    if (closeAngle > getIdx + 10)
                    {
                        var elemTypeArg = s[(getIdx + 10)..closeAngle];
                        if (!elemTypeArg.EndsWith("*"))
                        {
                            var spIdx = s.IndexOf(' ', 5);
                            if (spIdx > 5) arrayGetVars.Add(s[5..spIdx]);
                        }
                    }
                }
                // array_set with pointer value in 3rd arg — reference type stored as value
                // Only flag if the template arg is NOT a pointer type (non-pointer = value mismatch)
                if (s.Contains("array_set<"))
                {
                    var setIdx = s.IndexOf("array_set<");
                    var closeAngle = s.IndexOf('>', setIdx + 10);
                    if (closeAngle > setIdx + 10)
                    {
                        var typeArg = s[(setIdx + 10)..closeAngle];
                        if (!typeArg.EndsWith("*"))
                        {
                            // Check if the 3rd arg is a pointer-cast expression (indicates ref type mismatch)
                            var argsStart = s.IndexOf('(', closeAngle);
                            if (argsStart > 0)
                            {
                                var argsStr = s[(argsStart + 1)..];
                                // Count commas to find 3rd arg
                                var commaCount = 0;
                                var argStart = 0;
                                for (int ci = 0; ci < argsStr.Length; ci++)
                                {
                                    if (argsStr[ci] == ',' && ++commaCount == 2)
                                    {
                                        argStart = ci + 1;
                                        break;
                                    }
                                }
                                if (commaCount >= 2)
                                {
                                    var thirdArg = argsStr[argStart..].Trim().TrimEnd(';', ')').Trim();
                                    // Flag if 3rd arg is a pointer cast like (Type*)expr
                                    if (thirdArg.Contains("*)"))
                                        return true;
                                    // Flag if 3rd arg is a method parameter with pointer type
                                    // (reference type stored as value in array — needs pointer)
                                    var matchParam = method.Parameters.FirstOrDefault(
                                        p => p.Name == thirdArg && p.CppTypeName.EndsWith("*"));
                                    if (matchParam != null)
                                        return true;
                                }
                            }
                        }
                    }
                }
            }
            if (arrayGetVars.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    foreach (var v in arrayGetVars)
                    {
                        // (X*)varName — value-to-pointer cast of array_get result
                        if (s.Contains($"*){v}") && !s.Contains("array_"))
                            return true;
                    }
                }
            }
        }

        // Method-level: DIM implementations in System.Numerics interfaces
        // These use raw CIL arithmetic/comparison opcodes (add, sub, cgt, clt, etc.)
        // which translate to C++ operators (+, -, >, <) that struct types don't support
        if (method.DeclaringType?.ILFullName != null)
        {
            var declType = method.DeclaringType.ILFullName;
            // All System.Numerics.I* interfaces have potential operator issues
            if (declType.StartsWith("System.Numerics.I") && method.DeclaringType.IsInterface)
                return true;
        }

        // Method-level: System.Reflection.Pointer methods use void* as intptr_t/uintptr_t
        if (method.DeclaringType?.ILFullName == "System.Reflection.Pointer")
        {
            if (rendered.Contains("f_ptr"))
                return true;
        }

        // Method-level: IntPtr/UIntPtr methods try to access f_value field
        // IntPtr is aliased to intptr_t (scalar), so ->f_value is invalid
        if (method.DeclaringType?.ILFullName is "System.IntPtr" or "System.UIntPtr")
        {
            if (rendered.Contains("->f_value"))
                return true;
        }

        // Method-level: void* parameter assigned to typed field (Span<T> constructors)
        if (rendered.Contains("f_reference = pointer") &&
            method.Parameters.Any(p => p.CppTypeName == "void*"))
            return true;

        // Method-level: void* local returned from intptr_t/uintptr_t function
        // In .NET, IntPtr and void* are identical; in C++ they're incompatible
        if ((method.ReturnTypeCpp is "intptr_t" or "uintptr_t") && rendered.Contains("void* loc_"))
            return true;

        // Method-level: Span ctor called with intptr_t/uintptr_t parameter as actual argument
        // Only flag when the Span ctor call line actually contains the intptr_t param as argument
        if (rendered.Contains("Span_1_") && rendered.Contains("__ctor"))
        {
            var intptrParams = method.Parameters
                .Where(p => p.CppTypeName is "intptr_t" or "uintptr_t")
                .Select(p => p.Name)
                .ToHashSet();
            if (intptrParams.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s2 = line.ToString().TrimStart();
                    if (s2.Contains("Span_1_") && s2.Contains("__ctor"))
                    {
                        foreach (var param in intptrParams)
                        {
                            if (s2.Contains($", {param},") || s2.Contains($", {param})"))
                                return true;
                        }
                    }
                }
            }
        }

        // NOTE: Array_IndexOf/LastIndexOf check removed. The (cil2cpp::Array*)(void*)expr cast
        // is valid C++ — all Array.IndexOf declarations take cil2cpp::Array* as first parameter.

        // Method-level: ActivityTracker Guid manipulation with pointer arithmetic type mismatch
        if (method.CppName.Contains("AddIdToGuid"))
            return true;

        // Method-level: Encoding GetCharsWithFallback — Span<Char> passed as ReadOnlySpan<Byte>,
        // cross-scope type mismatch between DecoderFallback* and ReadOnlySpan, etc.
        if (method.CppName.Contains("GetCharsWithFallback") &&
            (method.CppName.Contains("UTF8Encoding") || method.CppName.Contains("ASCIIEncoding")))
        {
            return true;
        }

        // Method-level: EventSource_WriteEventString — EventData* → intptr_t mismatch
        if (method.CppName.Contains("EventSource_WriteEventString"))
        {
            return true;
        }

        // Method-level: EventProvider_EncodeObject — static_cast<uint64_t>(&pointer) repeated
        if (method.CppName.Contains("EventProvider_EncodeObject"))
        {
            return true;
        }

        // Method-level: CancellationToken_ThrowOperationCanceledException — IL maps CancellationToken
        // struct value into f_innerException (Exception*), which is a struct→pointer C2440
        if (method.CppName.Contains("CancellationToken_ThrowOperationCanceledException"))
        {
            return true;
        }

        // Method-level: RuntimeResourceSet_GetObject — assigns Dictionary<string,ResourceLocator>*
        // to f_caseInsensitiveTable which is declared as Dictionary<string,Object>*
        if (method.CppName.Contains("RuntimeResourceSet_GetObject"))
        {
            return true;
        }

        // Method-level: Thread.StartCore — references f_priority which doesn't exist on ManagedThread
        if (method.CppName.Contains("Thread_StartCore"))
        {
            return true;
        }

        // Method-level: RuntimeParameterInfo .ctor — references f_MemberImpl which doesn't exist
        // on ManagedParameterInfo (BCL internal field not mapped to runtime struct)
        if (method.CppName.Contains("RuntimeParameterInfo__ctor__System_Reflection_RuntimeParameterInfo_System_Reflection_MemberInfo"))
        {
            return true;
        }

        // Method-level: RegistryKey.GetValue — calls Interop_Advapi32_RegQueryValueEx with
        // int32_t* where uint32_t* is expected (parameter 6 type mismatch)
        if (method.CppName.Contains("RegistryKey_GetValue__System_String_System_Object"))
        {
            return true;
        }

        // Method-level: TraceLoggingDataCollector.AddArray — __t2 declared as pointer then
        // redefined via auto (pre-declared temp conflicts with auto declaration)
        if (method.CppName.Contains("TraceLoggingDataCollector_AddArray"))
        {
            return true;
        }

        // Method-level: ValueTuple`4<String,...>.GetHashCode — takes &f_Item1/&f_Item4 (String**)
        // and assigns to String* temp variable (address-of ref type field yields double pointer)
        if (method.CppName.Contains("ValueTuple_4_System_String_System_Int32_System_Int32_System_String_GetHashCode"))
        {
            return true;
        }

        // Method-level: Interop.Kernel32.LocalFree(void*) — calls LocalFree(IntPtr) overload
        // but void* doesn't implicitly convert to intptr_t in MSVC
        if (method.CppName == "Interop_Kernel32_LocalFree__System_Void")
        {
            return true;
        }

        // Method-level: EventPipe methods using intptr_t fields with Span ctors
        if (method.CppName.Contains("DispatchEventsToEventListeners") ||
            method.CppName.Contains("EventData_SetMetadata"))
            return true;

        // Method-level: BCL's System.TypedReference methods reference internal CLR field layout
        // (_value, _type) that doesn't match our TypedReference struct.
        if (method.CppName.Contains("System_TypedReference_"))
            return true;

        // Phase II.2: DBNull guard removed — DBNull compiles from BCL IL

        // Phase II.5: Pre-declared Thread* temp assigned from ICall returning void*/Object*
        // ExecutionContext methods use Thread.CurrentThread (ICall returns void* but var is Thread*)
        if (rendered.Contains("System_Threading_Thread* __t") && rendered.Contains("Thread_get_CurrentThread"))
            return true;

        // Method-level: TimeZoneInfo methods with cross-scope DateTime/TimeSpan/AdjustmentRule
        if (method.DeclaringType?.ILFullName?.Contains("TimeZoneInfo") == true &&
            (rendered.Contains("System_DateTime __t") || rendered.Contains("AdjustmentRule")))
            return true;

        // Method-level: switch-between-switch goto-skips-init (C2362)
        // Two consecutive switch blocks with auto __tN between them
        if (rendered.Contains("switch (") && rendered.Contains("auto __t") &&
            rendered.Contains("goto IL_003C") && rendered.Contains("goto IL_003E"))
            return true;

        // Method-level: GuidResult pointer parameter accessed with dot instead of arrow
        // stfld on by-ref param generates result.f_X instead of result->f_X
        if (method.Parameters.Any(p => p.CppTypeName.Contains("GuidResult*")))
        {
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s2 = line.ToString().TrimStart();
                if (s2.StartsWith("result.f_"))
                    return true;
            }
        }

        // Multi-line pattern: primitive-typed pre-declared variable used with dot access
        // e.g., bool __t0 = {}; ... __t0.f_hasCustomFormatter (always wrong — primitives have no fields)
        {
            var primitiveVars = new HashSet<string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                if ((s.StartsWith("bool __t") || s.StartsWith("int32_t __t") ||
                     s.StartsWith("int64_t __t") || s.StartsWith("double __t") ||
                     s.StartsWith("float __t") || s.StartsWith("uint8_t __t") ||
                     s.StartsWith("uint16_t __t") || s.StartsWith("uint32_t __t")) &&
                    s.Contains(" = "))
                {
                    var spIdx = s.IndexOf(' ');
                    var eqIdx = s.IndexOf(' ', spIdx + 1);
                    if (eqIdx > spIdx)
                        primitiveVars.Add(s[(spIdx + 1)..eqIdx]);
                }
            }
            if (primitiveVars.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    foreach (var v in primitiveVars)
                    {
                        if (s.Contains($"{v}.f_"))
                            return true;
                    }
                }
            }
        }

        // Check for calls to undeclared disambiguated functions
        if (_declaredFunctionNames.Count > 0)
        {
            foreach (var block in method.BasicBlocks)
            {
                foreach (var instr in block.Instructions)
                {
                    if (instr is IR.IRCall call && !string.IsNullOrEmpty(call.FunctionName)
                        && !call.FunctionName.StartsWith("cil2cpp::")
                        && !call.FunctionName.EndsWith("_ensure_cctor")
                        && call.FunctionName.Contains("__") // disambiguated name
                        && !_declaredFunctionNames.Contains(call.FunctionName))
                        return true;
                }
            }
        }

        // Multi-line: Object* pre-declared temp redeclared as struct type (value type)
        // AddAutoDeclarations pre-declares cross-scope __tN as Object*, but the body later
        // has "StructType __tN = {0};" — MSVC C2086 redefinition error.
        {
            var objectPreDeclVars = new HashSet<string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                // Match: cil2cpp::Object* __tNN = nullptr;
                if (s.StartsWith("cil2cpp::Object* __t") && s.EndsWith("= nullptr;"))
                {
                    var spaceIdx = s.IndexOf(' ', 20);
                    if (spaceIdx > 20)
                        objectPreDeclVars.Add(s[20..spaceIdx]);
                }
            }
            if (objectPreDeclVars.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    // Match: SomeStructType __tNN = {0}; or SomeStructType __tNN;
                    foreach (var v in objectPreDeclVars)
                    {
                        var marker = $" __t{v} =";
                        var idx = s.IndexOf(marker);
                        if (idx <= 0) continue;
                        // Ensure what precedes is a type name (not "auto" or "cil2cpp::Object*")
                        var prefix = s[..idx].Trim();
                        if (prefix.Length > 0 && prefix != "auto" && !prefix.Contains("Object*")
                            && !prefix.StartsWith("//") && !prefix.StartsWith("#"))
                            return true;
                    }
                }
            }
        }

        // Multi-line: uintptr_t/intptr_t temp passed as function argument or assigned to void* variable
        // In .NET JIT, IntPtr/UIntPtr and void* are identical (native int = pointer).
        // In C++, uintptr_t is an integer type incompatible with pointer types.
        // BCL IL uses conv.u/conv.i to cast pointers → integers before P/Invoke calls,
        // but our generated wrappers keep typed pointer parameters → type mismatch (C2664/C2440).
        if (rendered.Contains("(uintptr_t)(") || rendered.Contains("(intptr_t)("))
        {
            var uintptrTemps = new HashSet<string>();
            var voidPtrVars = new HashSet<string>();
            foreach (var line in rendered.AsSpan().EnumerateLines())
            {
                var s = line.ToString().TrimStart();
                // Track auto __tN = (uintptr_t/intptr_t)(expr)
                // Only flag when expr looks like a pointer expression (contains * for pointer cast/deref).
                // Skip when expr is a plain integer temp (__tN) — just an int→uintptr widening cast.
                if (s.StartsWith("auto ") && (s.Contains("= (uintptr_t)(") || s.Contains("= (intptr_t)(")))
                {
                    var castType = s.Contains("= (uintptr_t)(") ? "= (uintptr_t)(" : "= (intptr_t)(";
                    var exprStart = s.IndexOf(castType) + castType.Length;
                    var exprEnd = s.LastIndexOf(')');
                    var expr = exprEnd > exprStart ? s[exprStart..exprEnd] : "";
                    // Only add if expr looks like a pointer (cast, deref, or address-of)
                    if (expr.Contains('*') || expr.Contains("->") || expr.StartsWith("&"))
                    {
                        var spIdx = s.IndexOf(' ', 5);
                        if (spIdx > 5)
                            uintptrTemps.Add(s[5..spIdx]);
                    }
                }
                // Track void* loc_N declarations
                if (s.StartsWith("void* ") && s.Contains(" = "))
                {
                    var eqIdx = s.IndexOf(' ', 6);
                    if (eqIdx > 6)
                        voidPtrVars.Add(s[6..eqIdx]);
                }
            }
            if (uintptrTemps.Count > 0)
            {
                foreach (var line in rendered.AsSpan().EnumerateLines())
                {
                    var s = line.ToString().TrimStart();
                    foreach (var t in uintptrTemps)
                    {
                        // Passed as function argument: func(t, ...) or func(..., t)
                        // Exclude: if/while conditions, and simple auto assignments
                        if (s.Contains($"({t},") || s.Contains($"({t})") ||
                             s.Contains($", {t},") || s.Contains($", {t})"))
                        {
                            if (s.StartsWith("if ") || s.StartsWith("while "))
                                continue;
                            // Skip stackalloc — uintptr_t is the correct type for allocation size
                            if (s.Contains("CIL2CPP_STACKALLOC"))
                                continue;
                            // Skip Buffer_Memmove — its size parameter IS uintptr_t/size_t
                            if (s.Contains("Buffer_Memmove"))
                                continue;
                            if (s.StartsWith("auto "))
                            {
                                // Skip simple assignments: auto __tM = (__tN); or auto __tM = __tN;
                                var eqPos = s.IndexOf(" = ");
                                if (eqPos >= 0)
                                {
                                    var rhs = s[(eqPos + 3)..].TrimEnd(';').Trim();
                                    if (rhs == t || rhs == $"({t})")
                                        continue;
                                }
                                return true; // function call result: auto __tM = func(__tN, ...);
                            }
                            return true;
                        }
                        // Assigned to void* variable
                        foreach (var v in voidPtrVars)
                        {
                            if (s == $"{v} = {t};")
                                return true;
                        }
                    }
                }
            }
        }

        return false;
    }

    /// <summary>
    /// Check a single rendered C++ line for patterns that would cause MSVC errors.
    /// </summary>
    private static bool RenderedLineHasError(string s)
    {
        // Pattern: &variable = (assigning to address-of, invalid l-value)
        if (s.StartsWith("&") && s.Contains(" = "))
            return true;

        // Pattern: ->f_m_value on primitive types (System_Single = float, System_Double = double)
        // These are aliased to C++ primitives and don't have the f_m_value field
        if (s.Contains("->f_m_value"))
            return true;

        // Pattern: Interop calls with wrong pointer types in BCL IL bodies
        // BCL code passes typed pointers (uint32_t*, uint64_t*, struct*) where uint8_t* expected
        if (s.Contains("Interop_GetRandomBytes(") || s.Contains("Interop_Globalization_"))
            return true;
        // Note: RuntimeHelpers.CreateSpan<T>(RuntimeFieldHandle) is now intercepted in IRBuilder
        // and produces inline span init code. Only catch unintercepted CreateSpan calls.
        // Exclude function definitions (end with '{') — the function name itself contains CreateSpan.
        if (s.Contains("RuntimeHelpers_CreateSpan") && s.Contains("(") && !s.Contains("f_reference")
            && !s.TrimEnd().EndsWith("{"))
            return true;

        // Pattern: string_length called with non-String arg (Object* from array_get)
        if (s.Contains("string_length(cil2cpp::array_get<"))
            return true;

        // Pattern: array operations on Object* — byref deref produces Object*
        // but array_length/array_get/array_set/array_get_element_ptr need Array*
        if (s.Contains("array_length(*(cil2cpp::Object**)") ||
            s.Contains("array_get<") && s.Contains("(*(cil2cpp::Object**)") ||
            s.Contains("array_set<") && s.Contains("(*(cil2cpp::Object**)") ||
            s.Contains("array_get_element_ptr(*(cil2cpp::Object**)"))
            return true;
        // array_set with 0 as first arg (null array pointer)
        if (s.Contains("array_set<") && s.Contains(">(0,"))
            return true;

        // Pattern: OperationCanceledException.f_cancellationToken is void* in runtime
        if (s.Contains("f_cancellationToken") && !s.Contains("(void*)") && !s.Contains("nullptr")
            && !s.Contains("//"))
            return true;

        // Pattern: GetLocaleInfoEx — BCL code passes int32_t* where char16_t* expected
        if (s.Contains("GetLocaleInfoEx(") || s.Contains("GetLocaleInfoExInt("))
            return true;

        // Pattern: AsyncLocal constructor with wrong arg count
        if (s.Contains("System_Threading_AsyncLocal_1_") && s.Contains("__ctor("))
            return true;

        // Pattern: broken type name from function pointer mishandling
        // e.g., "methodSystem_Void*" or "reinterpret_cast<void(*)"
        if (s.Contains("methodSystem_") || s.Contains("reinterpret_cast<void(*)("))
            return true;

        // Pattern: f_innerException = (cil2cpp::Exception*)<value_type>
        // Only flag when the cast source is a value type variable (not a pointer).
        // Pointer-to-pointer casts like (Exception*)__str_N or (Exception*)__tN compile fine via C-style cast.
        // The real error is struct-to-pointer like (Exception*)cancellationToken.
        if (s.Contains("->f_innerException = (cil2cpp::Exception*)") &&
            !s.Contains("(cil2cpp::Exception*)nullptr") &&
            !s.Contains("(cil2cpp::Exception*)(void*)"))
        {
            // Extract what follows (cil2cpp::Exception*)
            var castIdx = s.IndexOf("(cil2cpp::Exception*)");
            if (castIdx >= 0)
            {
                var val = s[(castIdx + 21)..].TrimEnd(';').Trim();
                // __str_N, __tN, and loc_N are typically pointers → C-style cast compiles fine
                // Only flag bare value-type params (e.g., cancellationToken struct)
                if (!val.StartsWith("__str") && !val.StartsWith("__t") && !val.StartsWith("(") && !val.StartsWith("loc_"))
                    return true;
            }
        }

        // Phase II.3/II.4: Reflection type BCL internal fields that don't exist on our aliased types
        // RuntimeFieldInfo.m_reflectedTypeCache, RuntimeMethodInfo.m_declaringType, etc.
        if (s.Contains("f_m_reflectedTypeCache") || s.Contains("f_m_fieldAttributes") ||
            s.Contains("f_m_fieldType") || s.Contains("f_m_returnType") || s.Contains("f_m_parameters"))
            return true;
        // RuntimeFieldInfo/RuntimeMethodInfo.m_declaringType accessed via arrow
        if (s.Contains("->f_m_declaringType") && (s.Contains("RuntimeFieldInfo") || s.Contains("RuntimeMethodInfo") ||
            s.Contains("ManagedFieldInfo") || s.Contains("ManagedMethodInfo")))
            return true;

        // Phase II.1: GetCalendarInfoEx passes char16_t* where intptr_t expected
        if (s.Contains("GetCalendarInfoEx") || s.Contains("GetCalendarInfoW"))
            return true;

        // Pattern: enum type pointer cast where value expected
        // e.g., (System_Resources_UltimateResourceFallbackLocation*)__t5 in function args
        // These appear when ldflda/ldloca produces an address but callee expects value
        if (s.Contains("UltimateResourceFallbackLocation*)"))
            return true;

        // Phase II.1: CalendarId guard removed — CalendarId compiles as enum from IL

        // Pattern: ReadOnlySpan/Span struct cast to void*
        // BCL code casts Span structs but C++ can't implicit-cast struct to void*
        // Exclude: function names containing Span type where (void*) is in arguments
        // Exclude: function pointer type params like (void(*)(Stream*, ReadOnlySpan_1_Byte))
        if ((s.Contains("ReadOnlySpan_1_") || s.Contains("Span_1_")) && s.Contains("(void*)"))
        {
            // Find the Span type in the line and check what follows the containing identifier
            var spanIdx = s.IndexOf("Span_1_");
            // Walk to end of the identifier containing Span_1_
            var endIdx = spanIdx;
            while (endIdx < s.Length && (char.IsLetterOrDigit(s[endIdx]) || s[endIdx] == '_'))
                endIdx++;
            // If identifier is followed by '(' → function call name → safe
            // If identifier is followed by '*)' → pointer-to-Span cast → problematic
            // If identifier is followed by ')' without '*' → function pointer param type → safe
            if (endIdx < s.Length && s[endIdx] == '*')
                return true; // (SpanType*)(void*) — pointer cast to Span
            if (endIdx >= s.Length)
                return true; // truncated line — flag as error
        }

        // Pattern: missing this pointer — function call where first arg is small int
        // but function expects a pointer (value type method on struct)
        // Detect: GuidResult_SetFailure(7, or GetLocaleInfoFromLCType(4099,
        if (s.Contains("GuidResult_SetFailure(") && !s.Contains("GuidResult_SetFailure(result") &&
            !s.Contains("GuidResult_SetFailure(&") && !s.Contains("GuidResult_SetFailure(loc_") &&
            !s.Contains("GuidResult_SetFailure(__"))
            return true;
        if (s.Contains("GetLocaleInfoFromLCType(") && char.IsDigit(s[s.IndexOf("GetLocaleInfoFromLCType(") + 24]))
            return true;
        // Pattern: ValueListBuilder method called with wrong this (temp var instead of pointer)
        if (s.Contains("ValueListBuilder_1_"))
        {
            var fnEnd = s.LastIndexOf('(');
            if (fnEnd > 0)
            {
                var afterParen = s[(fnEnd + 1)..].TrimStart();
                // First arg should be a pointer (&loc_, __this, etc.)
                // If it starts with __t (temp, likely ReadOnlySpan), it's wrong
                if (afterParen.StartsWith("__t") && !afterParen.StartsWith("__this"))
                    return true;
                if (afterParen.Length > 0 && char.IsDigit(afterParen[0]))
                    return true;
            }
        }

        // Pattern: array_data result cast to wrong pointer depth
        // e.g., f_reference = (cil2cpp::Object*)cil2cpp::array_data(  — should be Object**
        if (s.Contains("= (cil2cpp::Object*)cil2cpp::array_data("))
            return true;

        // Pattern: Span type confusion in function argument
        // Span_1_System_Char passed where ReadOnlySpan_1_System_Byte expected
        // Exclude: function signatures (end with '{'), function pointer types ('(*)'),
        // and lines where both types appear in the function name (before first '(')
        if (s.Contains("System_Span_1_System_Char") && s.Contains("ReadOnlySpan_1_System_Byte")
            && !s.TrimEnd().EndsWith("{") && !s.Contains("(*)"))
        {
            var firstParen = s.IndexOf('(');
            if (firstParen < 0 || !(s[..firstParen].Contains("Span_1_System_Char") &&
                                     s[..firstParen].Contains("ReadOnlySpan_1_System_Byte")))
                return true;
        }

        // Pattern: static_cast<uint64_t>(ptr) — pointer to uint64 needs reinterpret_cast
        // Only flag when the argument looks like a pointer variable (contains * or ->)
        // Don't flag integer widening conversions like static_cast<uint64_t>(count)
        if (s.Contains("static_cast<uint64_t>(") && (s.Contains("->") || s.Contains("*)")))
            return true;

        // Pattern: Guid* subtracted from uint8_t* (pointer arithmetic type mismatch)
        if (s.Contains("System_Guid*") && s.Contains("uint8_t*") && s.Contains("-"))
            return true;

        // Pattern: interface type assignment (class* → interface*)
        // CultureInfo* → IFormatProvider*, etc.
        if (s.Contains("= (System_IFormatProvider*)") && !s.Contains("(void*)"))
            return true;

        // Pattern: null-pointer dereference for Unsafe.NullRef
        // (((Type*)0))->field = value; — dereferencing null pointer
        if (s.Contains("((") && s.Contains("*)0))"))
            return true;

        // Pattern: void* dot access — lParam.f_X when lParam is void*
        if (s.Contains("lParam.f_"))
            return true;

        // Pattern: volatile_write type mismatch (uint64_t* with int64_t value, or nullptr ambiguity)
        if (s.Contains("volatile_write((uint64_t*)") && !s.Contains("(uint64_t)"))
            return true;
        // volatile_write(ptr, nullptr) — template T is ambiguous between nullptr_t and pointer
        if (s.Contains("volatile_write(") && s.Contains("nullptr"))
            return true;

        // Pattern: unbox_ptr/array_get_element_ptr result accessed with dot instead of arrow
        if ((s.Contains("unbox_ptr<") || s.Contains("array_get_element_ptr(")) && s.Contains(").f_"))
            return true;

        // Note: Decimal/Int128/UInt128/Half operators are caught at method-level
        // by the System.Numerics interface DIM pattern in RenderedBodyHasErrors

        // Pattern: unbox/unbox_ptr with trailing underscore in type name (mangling mismatch)
        // e.g., unbox<System_ValueTuple_4_..._String_> — trailing _ before > is always wrong
        if ((s.Contains("unbox<") || s.Contains("unbox_ptr<")) && s.Contains("_>"))
            return true;

        // Pattern: double trailing underscore from nested generic mangling (>>→__)
        // e.g., List_1_WeakReference_1_EventSource__*) — the __ before *) is wrong
        if (s.Contains("__*)") || s.Contains("__*>"))
            return true;

        // Pattern: VerificationException undeclared type
        if (s.Contains("VerificationException"))
            return true;

        // Pattern: GCHandle_Alloc with int first arg (should be Object*)
        // Handle disambiguated names: GCHandle_Alloc__System_Object_...(2, 1)
        if (s.Contains("GCHandle_Alloc") && !s.Contains("(cil2cpp::Object*)"))
        {
            var allocIdx = s.IndexOf("GCHandle_Alloc");
            // Find the opening paren of the call arguments
            var parenIdx = s.IndexOf('(', allocIdx);
            if (parenIdx >= 0)
            {
                var afterParen = s[(parenIdx + 1)..].TrimStart();
                if (afterParen.Length > 0 && (char.IsDigit(afterParen[0]) || afterParen[0] == '-'))
                    return true;
            }
        }

        // Pattern: DataCollector methods with wrong this pointer (args shifted)
        if (s.Contains("DataCollector_Add") && s.Contains("(loc_") && !s.Contains("DataCollector*"))
            return true;

        // Pattern: void* to intptr_t/uintptr_t conversion (needs reinterpret_cast)
        if ((s.Contains("loc_0 = __t") || s.Contains("return __t")) && s.Contains("ToPointer"))
            return true;

        // Pattern: Calendar-derived to Calendar-base assignment without cast
        if (s.Contains("GregorianCalendar*") && s.Contains("Calendar*") && s.Contains("= __t"))
            return true;

        // Pattern: Enum as value type in function arg (it's a reference type)
        if (s.Contains("System_Enum_GetValue(") && !s.Contains("System_Enum*"))
            return true;

        // Pattern: pointer-parameter dot-access (EventSourceOptions* → options.f_X)
        if (s.Contains("options.f_") && !s.Contains("->"))
            return true;

        // Pattern: intptr_t/uint8_t* pointer mismatch in reflection/tracing
        if (s.Contains("_GetPropertyOrFieldData(") || s.Contains("set_DataPointer("))
            return true;

        // Pattern: CustomAttributeData comparison with Object*
        // The comparison line itself may not mention the type — it just has "obj == __this"
        // Detect at method level instead


        // Pattern: CancellationToken struct in OperationCanceledException ctor
        if (s.Contains("OperationCanceledException__ctor") && s.Contains("CancellationToken"))
            return true;

        // Pattern: InformThreadNameChange with wrong first arg (String* instead of ThreadHandle)
        if (s.Contains("InformThreadNameChange(") && !s.Contains("ThreadHandle"))
            return true;

        // Pattern: DBNull* comparison with Object* (unrelated pointer types)
        if (s.Contains("DBNull*") && (s.Contains("!=") || s.Contains("==")))
            return true;

        // Pattern: VectorMath hardware intrinsic types (JIT intrinsic, no IL body)
        // Note: Vector128_1_ removed — Vector types now have scalar fallback struct definitions
        if (s.Contains("VectorMath_"))
            return true;

        // Pattern: TypedReference passed as void* — it's a struct, not a pointer
        if (s.Contains("TypedReference") && s.Contains("GetTypeFromHandle"))
            return true;

        // Pattern: FreeCoTaskMem — BCL passes raw pointers (uint8_t*, uint16_t*) where intptr_t expected
        if (s.Contains("FreeCoTaskMem(") && !s.Contains("(intptr_t)"))
            return true;

        // Pattern: void* pointer arithmetic (void has unknown size)
        // e.g., __t3 + index where __t3 is void*
        if (s.Contains("ToPointer("))
            return true;

        // Pattern: Span of undefined nested types
        if (s.Contains("Span_1_System_TimeZoneInfo_AdjustmentRule"))
            return true;

        // Pattern: enum pointer passed where enum value expected (ResourceTypeCode, etc.)
        // The enum pointer cast like (ResourceTypeCode*)typeCode or (ResourceTypeCode*)&loc_
        // when the callee expects the value
        if (s.Contains("ResourceTypeCode*)"))
            return true;

        // Pattern: MethodTable field access — JIT internal structure not fully supported
        if (s.Contains("f_ComponentSize") || s.Contains("f_BaseSize") ||
            (s.Contains("f_Flags") && s.Contains("MethodTable")))
            return true;

        // Pattern: TypeHandle/MethodTable JIT internals — bitwise ops on void* (f_m_asTAddr)
        if (s.Contains("f_m_asTAddr"))
            return true;
        // Pattern: TypeHandle__ctor with intptr_t arg (needs void*, not intptr_t)
        if (s.Contains("TypeHandle__ctor(") || s.Contains("TypeHandle_TypeHandleOf"))
            return true;

        // Pattern: RuntimeMethodHandle_InvokeMethod — callers pass intptr_t* but it needs void**
        if (s.Contains("RuntimeMethodHandle_InvokeMethod("))
            return true;

        // Pattern: enum pointer passed where enum value expected (InvokerStrategy)
        if (s.Contains("InvokerStrategy*)"))
            return true;

        // Pattern: string_length with array_get result (Object* not String*)
        if (s.Contains("string_length(") && !s.Contains("string_length((cil2cpp::String*)"))
        {
            // Allow: string_length(__this), string_length(someStringVar)
            // Reject: string_length(__tN) where __tN came from array_get
            var idx = s.IndexOf("string_length(");
            if (idx >= 0)
            {
                var argStart = idx + 14;
                var afterParen = s[argStart..];
                // If the argument is __tN (not cast to String*), it could be wrong type
                if (afterParen.StartsWith("__t") && !afterParen.StartsWith("__this"))
                    return true;
            }
        }

        // Pattern: SpanHelpers pointer alignment — bitwise AND of pointer with integer (C2296)
        if (s.Contains("SpanHelpers_UnalignedCount"))
            return true;

        // Pattern: TimeSpanFormat_FormatG/FormatC — wrong arg order (missing TimeSpan first arg)
        if (s.Contains("TimeSpanFormat_FormatG(") || s.Contains("TimeSpanFormat_FormatC("))
            return true;

        // Pattern: EventPipeMetadataGenerator_WriteToBuffer — char16_t* → uint8_t* mismatch
        if (s.Contains("EventPipeMetadataGenerator_WriteToBuffer("))
            return true;

        // Pattern: GetThreadIOPendingFlag with wrong arg types
        if (s.Contains("GetThreadIOPendingFlag("))
            return true;

        // Pattern: ReadUnalignedI4 with uintptr_t arg (needs int32_t*)
        if (s.Contains("ReadUnalignedI4("))
            return true;

        // Pattern: ValueStringBuilder — wrong this pointer (String* instead of VSB*)
        if (s.Contains("ValueStringBuilder_Append") || s.Contains("ValueStringBuilder_Insert"))
            return true;

        // Pattern: static_cast<uint64_t>(pointer*) — pointer→int needs reinterpret_cast
        // EventProvider_EncodeObject has many of these (int32_t*, uint64_t*, Guid*, Decimal*, etc.)
        if (s.Contains("static_cast<uint64_t>(") && s.Contains("*>") == false)
        {
            // Extract the argument of static_cast<uint64_t>(...)
            var castIdx = s.IndexOf("static_cast<uint64_t>(");
            if (castIdx >= 0)
            {
                var argStart = castIdx + 22; // after "static_cast<uint64_t>("
                var argEnd = s.IndexOf(')', argStart);
                if (argEnd > argStart)
                {
                    var arg = s[argStart..argEnd].Trim();
                    // If the argument starts with & (address-of), it's a pointer
                    if (arg.StartsWith("&"))
                        return true;
                }
            }
        }

        // Pattern: EventProvider_WriteEvent with pointer→intptr_t mismatch
        if (s.Contains("EventProvider_WriteEvent") && s.Contains("EventData*"))
            return true;

        // Pattern: SearchValues_TryGetSingleRange — bool*/char16_t* and Span assignment
        if (s.Contains("SearchValues_TryGetSingleRange"))
            return true;

        // Pattern: static_cast<uint64_t>(pointer_param) — pointer parameter cast to uint64
        // UnmanagedMemoryStream_Initialize has static_cast<uint64_t>(pointer) where pointer is uint8_t*
        if (s.Contains("static_cast<uint64_t>(") && !s.Contains("->") && !s.Contains("*)"))
        {
            var castIdx = s.IndexOf("static_cast<uint64_t>(");
            if (castIdx >= 0)
            {
                var argStart = castIdx + 22;
                var argEnd = s.IndexOf(')', argStart);
                if (argEnd > argStart)
                {
                    var arg = s[argStart..argEnd].Trim();
                    // If the arg is a parameter name (not a number/expression), flag it
                    // Exclude __t temps and loc_ locals (correctly auto-typed by codegen)
                    // Only flag names that look like pointer parameters (contain "ptr", "pointer", "buffer")
                    if (arg.Length > 0 && char.IsLetter(arg[0]) && !arg.Contains('+') && !arg.Contains('-')
                        && !arg.StartsWith("__t") && !arg.StartsWith("loc_")
                        && (arg.Contains("ptr") || arg.Contains("Ptr") || arg.Contains("pointer")
                            || arg.Contains("buffer") || arg.Contains("Buffer")))
                        return true;
                }
            }
        }

        // Pattern: DONT_USE_InternalThread field — not part of ManagedThread struct
        if (s.Contains("f_DONT_USE_InternalThread"))
            return true;

        // Pattern: StringBuilder_Append ambiguous overload (char, int vs char16_t, int)
        // When first arg is 0 (int literal), MSVC can't choose between char and char16_t overloads
        if (s.Contains("StringBuilder_Append__System_Char_System_Int32") && s.Contains(", 0,"))
            return true;

        // Dictionary generic type mismatch handled at method level (RuntimeResourceSet_GetObject)

        // Pattern: (void*) applied to negated primitive — boxing a negated double/float
        // e.g., (cil2cpp::Object*)(void*)-value where value is double/float → C2440
        if (s.Contains("(void*)-") && !s.Contains("(void*)->"))
            return true;

        // Pattern: void* parameter arrow-access — lParam->f_X when lParam is void*
        // void* cannot be dereferenced (existing check only covers dot-access lParam.f_)
        if (s.Contains("lParam->f_"))
            return true;

        // Pattern: ReadOnlySpan passed to compareinfo ICall expecting String*
        // BCL calls compareinfo with ReadOnlySpan<char> but our ICall takes cil2cpp::String*
        if (s.Contains("ReadOnlySpan_1_System_Char") && s.Contains("compareinfo_"))
            return true;

        // Pattern: char16_t pointer division — pointer arithmetic error
        // e.g., (char16_t*) ... / 2 → C2296 pointer division is invalid
        if (s.Contains("char16_t*") && s.Contains("/ 2"))
            return true;

        // Pattern: ExceptionHandlingClauseOptions_TypeInfo — undeclared reflection enum TypeInfo
        if (s.Contains("ExceptionHandlingClauseOptions_TypeInfo"))
            return true;

        // Pattern: RuntimeMethodInfo/RuntimeConstructorInfo __ctor — undeclared constructor calls
        // These runtime-provided types don't have generated constructors
        if (s.Contains("RuntimeMethodInfo__ctor(") || s.Contains("RuntimeConstructorInfo__ctor("))
            return true;

        // Pattern: Interlocked.CompareExchange<IntPtr> called with pointer argument
        // BCL IL passes conv.i (ptr→intptr_t) but codegen may pass raw pointer
        if (s.Contains("Interlocked_CompareExchange__System_IntPtr") &&
            s.Contains("overlapped", StringComparison.OrdinalIgnoreCase))
            return true;

        return false;
    }

    /// <summary>
    /// Extract function name → set of valid parameter counts from C++ signatures.
    /// Signature format: "retType funcName(Type1 p1, Type2 p2, ...)" → funcName → {2}
    /// </summary>
    private static Dictionary<string, HashSet<int>> ExtractFunctionParamCounts(HashSet<string> signatures)
    {
        var result = new Dictionary<string, HashSet<int>>();
        foreach (var sig in signatures)
        {
            var parenIdx = sig.IndexOf('(');
            if (parenIdx <= 0) continue;

            // Extract function name
            var beforeParen = sig[..parenIdx].TrimEnd();
            var spaceIdx = beforeParen.LastIndexOf(' ');
            if (spaceIdx < 0) continue;
            var name = beforeParen[(spaceIdx + 1)..];
            if (name.StartsWith("*"))
                name = name.TrimStart('*');
            if (string.IsNullOrEmpty(name)) continue;

            // Count parameters (count commas + 1, handle void/empty)
            var closeIdx = sig.IndexOf(')', parenIdx);
            if (closeIdx < 0) continue;
            var paramStr = sig[(parenIdx + 1)..closeIdx].Trim();
            int paramCount = 0;
            if (!string.IsNullOrEmpty(paramStr) && paramStr != "void")
            {
                paramCount = 1;
                // Count commas not inside nested angle brackets or parens
                int depth = 0;
                foreach (var ch in paramStr)
                {
                    if (ch is '<' or '(') depth++;
                    else if (ch is '>' or ')') depth--;
                    else if (ch == ',' && depth == 0) paramCount++;
                }
            }

            if (!result.TryGetValue(name, out var counts))
            {
                counts = new HashSet<int>();
                result[name] = counts;
            }
            counts.Add(paramCount);
        }
        return result;
    }
}
