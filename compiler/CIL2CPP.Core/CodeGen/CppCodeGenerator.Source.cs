using System.Text;
using CIL2CPP.Core.IL;
using CIL2CPP.Core.IR;

namespace CIL2CPP.Core.CodeGen;

public partial class CppCodeGenerator
{
    /// <summary>
    /// Emit common source file header (includes, assembly info).
    /// </summary>
    private void EmitSourceFileHeader(StringBuilder sb, string description)
    {
        sb.AppendLine("// Generated by CIL2CPP - DO NOT EDIT");
        sb.AppendLine($"// Source assembly: {_module.Name}");
        sb.AppendLine($"// {description}");
        if (_config.IsDebug)
            sb.AppendLine("// DEBUG BUILD - contains #line directives and IL offset comments");
        sb.AppendLine();
        sb.AppendLine($"#include \"{_module.Name}.h\"");
        sb.AppendLine();
        sb.AppendLine("#include <cstdio>");
        sb.AppendLine("#include <cmath>");
        sb.AppendLine("#include <cstring>");
        sb.AppendLine("#include <algorithm>");
        sb.AppendLine("#include <limits>");
        sb.AppendLine("#include <atomic>");
        sb.AppendLine();
    }

    /// <summary>
    /// Generate the data file: string literals, array init data, static fields,
    /// TypeInfo, VTable, interface data, reflection metadata, ensure_cctor, P/Invoke.
    /// </summary>
    private GeneratedFile GenerateDataFile()
    {
        var sb = new StringBuilder();
        EmitSourceFileHeader(sb, "Data: metadata, TypeInfo, static fields, VTable, P/Invoke");

        // String literals (non-static — referenced from method files via extern in header)
        if (_module.StringLiterals.Count > 0)
        {
            sb.AppendLine("// ===== String Literals =====");
            foreach (var (value, literal) in _module.StringLiterals)
            {
                sb.AppendLine($"cil2cpp::String* {literal.Id} = nullptr;");
            }
            sb.AppendLine();

            sb.AppendLine("void __init_string_literals() {");
            foreach (var (value, literal) in _module.StringLiterals)
            {
                var escaped = EscapeString(value);
                sb.AppendLine($"    {literal.Id} = cil2cpp::string_literal(\"{escaped}\");");
            }
            sb.AppendLine("}");
            sb.AppendLine();
        }

        // Array initializer data blobs (non-static — referenced from method files)
        if (_module.ArrayInitDataBlobs.Count > 0)
        {
            sb.AppendLine("// ===== Array Initializer Data =====");
            foreach (var blob in _module.ArrayInitDataBlobs)
            {
                var bytes = string.Join(", ", blob.Data.Select(b => $"0x{b:X2}"));
                sb.AppendLine($"const unsigned char {blob.Id}[] = {{ {bytes} }};");
            }
            sb.AppendLine();
        }

        // Static field storage (include RuntimeProvided types — BCL code uses their statics)
        foreach (var type in _userTypes)
        {
            if (type.IsEnum || type.IsDelegate) continue;
            if (type.StaticFields.Count > 0)
            {
                sb.AppendLine($"{type.CppName}_Statics {type.CppName}_statics = {{}};");
            }
        }
        if (_userTypes.Any(t => !t.IsEnum && !t.IsDelegate && t.StaticFields.Count > 0))
        {
            sb.AppendLine();
        }

        // Primitive type TypeInfo definitions (for array element types)
        // Runtime-provided reference types get aliases to runtime TypeInfo instead of new definitions.
        if (_module.PrimitiveTypeInfos.Count > 0)
        {
            sb.AppendLine("// ===== Primitive Type Info (array element types) =====");
            foreach (var entry in _module.PrimitiveTypeInfos.Values)
            {
                // Runtime-provided reference types: alias to runtime's TypeInfo (e.g., cil2cpp::System::Object_TypeInfo)
                var runtimeAlias = GetRuntimeTypeInfoAlias(entry.ILFullName);
                if (runtimeAlias != null)
                {
                    sb.AppendLine($"cil2cpp::TypeInfo& {entry.CppMangledName}_TypeInfo = {runtimeAlias};");
                    continue;
                }

                sb.AppendLine($"cil2cpp::TypeInfo {entry.CppMangledName}_TypeInfo = {{");
                sb.AppendLine($"    .name = \"{entry.ILFullName.Split('.').Last()}\",");
                sb.AppendLine($"    .namespace_name = \"{entry.ILFullName[..entry.ILFullName.LastIndexOf('.')]}\",");
                sb.AppendLine($"    .full_name = \"{entry.ILFullName}\",");
                sb.AppendLine($"    .base_type = nullptr,");
                sb.AppendLine($"    .interfaces = nullptr,");
                sb.AppendLine($"    .interface_count = 0,");
                sb.AppendLine($"    .instance_size = sizeof({entry.CppTypeName}),");
                sb.AppendLine($"    .element_size = sizeof({entry.CppTypeName}),");
                // Primitive types get both ValueType and Primitive flags (ECMA-335)
                sb.AppendLine($"    .flags = cil2cpp::TypeFlags::ValueType | cil2cpp::TypeFlags::Primitive,");
                sb.AppendLine($"    .vtable = nullptr,");
                sb.AppendLine($"    .fields = nullptr,");
                sb.AppendLine($"    .field_count = 0,");
                sb.AppendLine($"    .methods = nullptr,");
                sb.AppendLine($"    .method_count = 0,");
                sb.AppendLine($"    .default_ctor = nullptr,");
                sb.AppendLine($"    .finalizer = nullptr,");
                sb.AppendLine($"    .interface_vtables = nullptr,");
                sb.AppendLine($"    .interface_vtable_count = 0,");
                sb.AppendLine($"    .custom_attributes = nullptr,");
                sb.AppendLine($"    .custom_attribute_count = 0,");
                sb.AppendLine($"}};");
            }
            sb.AppendLine();
        }

        // Exception TypeInfo reference aliases — define references to runtime-declared TypeInfos
        // so that generated catch/cast code can use mangled names (System_Exception_TypeInfo)
        sb.AppendLine("// ===== Exception TypeInfo Aliases =====");
        foreach (var (mangledName, runtimeTypeInfoName) in GetExceptionTypeInfoAliases())
        {
            sb.AppendLine($"cil2cpp::TypeInfo& {mangledName}_TypeInfo = {runtimeTypeInfoName};");
        }
        sb.AppendLine();

        // Ensure System_Object_TypeInfo and System_String_TypeInfo exist at global scope
        // (normally defined by PrimitiveTypeInfos; alias as fallback if missing)
        var needsObjectAlias = !_module.PrimitiveTypeInfos.Values.Any(e => e.ILFullName == "System.Object");
        var needsStringAlias = !_module.PrimitiveTypeInfos.Values.Any(e => e.ILFullName == "System.String");
        if (needsObjectAlias || needsStringAlias)
        {
            sb.AppendLine("// ===== Runtime TypeInfo Aliases =====");
            if (needsObjectAlias)
                sb.AppendLine("cil2cpp::TypeInfo& System_Object_TypeInfo = cil2cpp::System_Object_TypeInfo;");
            if (needsStringAlias)
                sb.AppendLine("cil2cpp::TypeInfo& System_String_TypeInfo = cil2cpp::System_String_TypeInfo;");
            sb.AppendLine();
        }

        // Stub TypeInfos for runtime-provided base types not declared in the runtime library
        // These are referenced as .base_type in TypeInfo initialization for value types, enums, delegates
        sb.AppendLine("// ===== Runtime Base Type TypeInfo Stubs =====");
        foreach (var (mangledName, ilName) in GetRuntimeBaseTypeInfoStubs())
        {
            sb.AppendLine($"cil2cpp::TypeInfo {mangledName}_TypeInfo = {{ " +
                $".name = \"{ilName.Split('.').Last()}\", " +
                $".namespace_name = \"{string.Join(".", ilName.Split('.').SkipLast(1))}\", " +
                $".full_name = \"{ilName}\", " +
                $".base_type = &System_Object_TypeInfo }};");
        }
        sb.AppendLine();

        // VTable data
        EmitVTableData(sb, _userTypes);

        // Interface data
        EmitInterfaceData(sb, _userTypes);

        // Finalizer wrappers
        EmitFinalizerWrappers(sb, _userTypes);

        // Reflection metadata (FieldInfo/MethodInfo arrays)
        EmitReflectionMetadata(sb, _userTypes);

        // Generic variance data arrays (for variance-aware type checking)
        EmitGenericVarianceData(sb, _userTypes);

        // Type info definitions (skip runtime-provided types — already defined in runtime)
        sb.AppendLine("// ===== Type Info =====");
        var emittedTypeInfo = new HashSet<string>();
        // Collect types that already have TypeInfo definitions (primitives, exceptions, base type stubs, aliases)
        foreach (var entry in _module.PrimitiveTypeInfos.Values)
            emittedTypeInfo.Add(entry.CppMangledName);
        foreach (var (mangledName, _) in GetExceptionTypeInfoAliases())
            emittedTypeInfo.Add(mangledName);
        foreach (var (mangledName, _) in GetRuntimeBaseTypeInfoStubs())
            emittedTypeInfo.Add(mangledName);
        // Runtime TypeInfo aliases (Object, String) — already emitted as references above
        if (needsObjectAlias) emittedTypeInfo.Add("System_Object");
        if (needsStringAlias) emittedTypeInfo.Add("System_String");
        foreach (var type in _userTypes)
        {
            if (emittedTypeInfo.Contains(type.CppName)) continue;
            if (!IsValidCppIdentifier(type.CppName)) continue;
            if (!emittedTypeInfo.Add(type.CppName)) continue;
            if (type.IsRuntimeProvided && IRBuilder.CoreRuntimeTypes.Contains(type.ILFullName))
            {
                // Emit minimal TypeInfo stub for core runtime types (Object, String, etc.)
                // (other types may reference these as base_type)
                var baseName = type.BaseType != null && emittedTypeInfo.Contains(type.BaseType.CppName)
                    ? $"&{type.BaseType.CppName}_TypeInfo" : "&System_Object_TypeInfo";
                sb.AppendLine($"cil2cpp::TypeInfo {type.CppName}_TypeInfo = {{ .name = \"{type.Name}\", " +
                    $".namespace_name = \"{type.Namespace}\", .full_name = \"{type.ILFullName}\", " +
                    $".base_type = {baseName} }};");
                continue;
            }
            if (type.IsRuntimeProvided && !IRBuilder.CoreRuntimeTypes.Contains(type.ILFullName))
            {
                // Non-core runtime-provided types (Task, Thread, etc.): struct layout from runtime,
                // but methods compiled from BCL IL — need full TypeInfo with vtable
                GenerateTypeInfo(sb, type);
                continue;
            }
            GenerateTypeInfo(sb, type);
        }
        sb.AppendLine();

        // Static constructor guards — collect all types that SHOULD have ensure_cctor
        // (matches the header declaration loop in GenerateHeader)
        var needsEnsureCctor = new HashSet<string>();
        foreach (var type in _userTypes)
        {
            if (type.HasCctor)
                needsEnsureCctor.Add(type.CppName);
        }
        var emittedEnsureCctor = new HashSet<string>();
        foreach (var type in _userTypes)
        {
            if (type.HasCctor)
            {
                var cctorMethod = type.Methods.FirstOrDefault(m => m.IsStaticConstructor);
                if (cctorMethod != null)
                {
                    // For RuntimeProvided types: emit cctor if the method has a compiled body
                    if (type.IsRuntimeProvided && cctorMethod.BasicBlocks.Count == 0)
                    {
                        sb.AppendLine($"void {type.CppName}_ensure_cctor() {{ }}");
                        emittedEnsureCctor.Add(type.CppName);
                        continue;
                    }
                    sb.AppendLine($"static bool {type.CppName}_cctor_called = false;");
                    sb.AppendLine($"void {type.CppName}_ensure_cctor() {{");
                    sb.AppendLine($"    if (!{type.CppName}_cctor_called) {{");
                    sb.AppendLine($"        {type.CppName}_cctor_called = true;");
                    sb.AppendLine($"        {cctorMethod.CppName}();");
                    sb.AppendLine($"    }}");
                    sb.AppendLine($"}}");
                    emittedEnsureCctor.Add(type.CppName);
                    sb.AppendLine();
                }
                else
                {
                    sb.AppendLine($"void {type.CppName}_ensure_cctor() {{ }}");
                    emittedEnsureCctor.Add(type.CppName);
                }
            }
        }
        // Safety net: emit no-op for any ensure_cctor declared in the header but not generated.
        // This handles cases where CppName dedup in source drops a type with HasCctor.
        foreach (var type in _module.Types)
        {
            if (type.HasCctor && !emittedEnsureCctor.Contains(type.CppName))
            {
                sb.AppendLine($"void {type.CppName}_ensure_cctor() {{ }}");
                emittedEnsureCctor.Add(type.CppName);
            }
        }

        // P/Invoke extern declarations and wrappers
        EmitPInvokeDeclarations(sb, _userTypes, _emittedMethodSignatures);

        return new GeneratedFile
        {
            FileName = $"{_module.Name}_data.cpp",
            Content = sb.ToString()
        };
    }

    /// <summary>
    /// Generate method implementation files, partitioned for parallel compilation.
    /// </summary>
    private List<GeneratedFile> GenerateMethodFiles()
    {
        var files = new List<GeneratedFile>();
        var partitions = PartitionTypes(_userTypes);

        for (int i = 0; i < partitions.Count; i++)
        {
            var sb = new StringBuilder();
            EmitSourceFileHeader(sb, $"Methods (part {i + 1} of {partitions.Count})");

            sb.AppendLine("// ===== Method Implementations =====");
            foreach (var type in partitions[i])
            {
                EmitMethodsForType(sb, type);
            }

            files.Add(new GeneratedFile
            {
                FileName = $"{_module.Name}_methods_{i}.cpp",
                Content = sb.ToString()
            });
        }

        return files;
    }

    /// <summary>
    /// Emit method implementations for a single type.
    /// </summary>
    private void EmitMethodsForType(StringBuilder sb, IRType type)
    {
        if (type.IsDelegate) return;

        // For interfaces, only emit DIM method bodies (non-abstract with converted bodies)
        if (type.IsInterface)
        {
            foreach (var method in type.Methods)
            {
                if (method.IsAbstract || method.BasicBlocks.Count == 0) continue;
                if (!TryEmitMethodThroughGates(sb, method)) continue;
                // Trial render for DIM methods
                var dimTrialSb = new StringBuilder();
                GenerateMethodImpl(dimTrialSb, method);
                var dimRendered = dimTrialSb.ToString();
                if (RenderedBodyHasErrors(dimRendered, method, _knownTypeNames))
                {
                    var renderDetail = _stubAnalyzer != null
                        ? GetRenderedErrorDetail(dimRendered, method)
                        : "trial render error";
                    TrackStubWithAnalysis(method, "rendered body has errors",
                        StubRootCause.RenderedBodyError, renderDetail);
                    GenerateStubForMethod(sb, method);
                    continue;
                }
                sb.Append(dimRendered);
            }
            return;
        }

        // All types (user + BCL) compile from IL — Unity IL2CPP model
        foreach (var method in type.Methods)
        {
            if (method.IsAbstract || method.IsInternalCall || method.IsPInvoke) continue;
            if (method.BasicBlocks.Count == 0) continue;
            if (method.HasICallMapping) continue;
            // Core runtime types (Object, String, Array, etc.): only emit static methods.
            // Non-core RuntimeProvided types (Task, Thread, CancellationToken) emit all methods.
            if (type.IsRuntimeProvided && !method.IsStatic
                && IRBuilder.CoreRuntimeTypes.Contains(type.ILFullName)) continue;
            if (!TryEmitMethodThroughGates(sb, method)) continue;

            // Check known stub implementations before trial render
            var knownBody = GetKnownStubBody(method.CppName);
            if (knownBody != null && IsStubBody(method))
            {
                sb.AppendLine($"{method.GetCppSignature()} {{");
                sb.AppendLine(knownBody);
                sb.AppendLine("}");
                continue;
            }

            // Trial render: render to temp buffer, check for error patterns,
            // emit stub if errors found (avoids C++ compilation failures)
            var trialSb = new StringBuilder();
            GenerateMethodImpl(trialSb, method);
            var rendered = trialSb.ToString();
            if (RenderedBodyHasErrors(rendered, method, _knownTypeNames))
            {
                var renderDetail = _stubAnalyzer != null
                    ? GetRenderedErrorDetail(rendered, method)
                    : "trial render error";
                TrackStubWithAnalysis(method, "rendered body has errors",
                    StubRootCause.RenderedBodyError, renderDetail);
                GenerateStubForMethod(sb, method);
                continue;
            }
            sb.Append(rendered);
        }
    }

    /// <summary>
    /// Run the 4 pre-render gates on a method. Returns true if the method passes all gates
    /// and should proceed to trial render. Returns false if the method was stubbed.
    /// </summary>
    private bool TryEmitMethodThroughGates(StringBuilder sb, IRMethod method)
    {
        if (HasUnknownParameterTypes(method, _knownTypeNames))
        {
            var detail = _stubAnalyzer != null
                ? GetUnknownTypeDetail(method) : "unknown parameter types";
            TrackStubWithAnalysis(method, "unknown parameter types",
                StubRootCause.UnknownParameterTypes, detail);
            return false;
        }
        if (HasUnknownBodyReferences(method, _knownTypeNames))
        {
            var detail = _stubAnalyzer != null
                ? GetUnknownBodyDetail(method) : "unknown body references";
            TrackStubWithAnalysis(method, "unknown body references",
                StubRootCause.UnknownBodyReferences, detail);
            return false;
        }
        if (CallsUndeclaredOrMismatchedFunctions(method))
        {
            var detail = _stubAnalyzer != null
                ? GetUndeclaredFunctionDetail(method) : "undeclared function";
            TrackStubWithAnalysis(method, "undeclared/mismatched function calls",
                StubRootCause.UndeclaredFunction, detail);
            return false;
        }
        if (HasKnownBrokenPatterns(method, _knownTypeNames))
        {
            var detail = _stubAnalyzer != null
                ? GetBrokenPatternDetail(method) : "known broken patterns";
            TrackStubWithAnalysis(method, "known broken patterns",
                StubRootCause.KnownBrokenPattern, detail);
            return false;
        }
        if (!_emittedMethodSignatures.Add(method.GetCppSignature()))
            return false;
        return true;
    }

    /// <summary>
    /// Track stub with optional detailed analysis.
    /// When analyzer is active, records both simple and detailed info.
    /// </summary>
    private void TrackStubWithAnalysis(IRMethod method, string reason,
        StubRootCause rootCause, string detail)
    {
        if (_stubAnalyzer != null)
            TrackStubDetailed(method, reason, rootCause, detail);
        else
            TrackStub(method, reason);
    }

    /// <summary>
    /// Extract the specific unknown type that caused HasUnknownParameterTypes to return true.
    /// </summary>
    private string GetUnknownTypeDetail(IRMethod method)
    {
        foreach (var param in method.Parameters)
        {
            var typeName = param.CppTypeName.TrimEnd('*').Trim();
            if (string.IsNullOrEmpty(typeName) || typeName.StartsWith("cil2cpp::") ||
                IsCppPrimitiveType(typeName)) continue;
            if (IsUnresolvedGenericParam(typeName))
                return $"unresolved generic param '{typeName}'";
            if (!_knownTypeNames.Contains(typeName))
                return $"unknown type '{typeName}'";
        }
        var retType = method.ReturnTypeCpp.TrimEnd('*').Trim();
        if (!string.IsNullOrEmpty(retType) && !retType.StartsWith("cil2cpp::") &&
            !IsCppPrimitiveType(retType) && !_knownTypeNames.Contains(retType))
            return $"unknown return type '{retType}'";
        return "unknown parameter/return type";
    }

    /// <summary>
    /// Extract the specific unknown type from method body that caused HasUnknownBodyReferences.
    /// </summary>
    private string GetUnknownBodyDetail(IRMethod method)
    {
        foreach (var local in method.Locals)
        {
            var baseType = local.CppTypeName.TrimEnd('*').Trim();
            if (string.IsNullOrEmpty(baseType) || baseType.StartsWith("cil2cpp::") ||
                IsCppPrimitiveType(baseType)) continue;
            if (!_knownTypeNames.Contains(baseType))
                return $"unknown local type '{baseType}'";
        }
        return "unknown body reference";
    }

    /// <summary>
    /// Extract the specific undeclared function name.
    /// </summary>
    private string GetUndeclaredFunctionDetail(IRMethod method)
    {
        foreach (var block in method.BasicBlocks)
        {
            foreach (var instr in block.Instructions)
            {
                if (instr is IR.IRCall call && !string.IsNullOrEmpty(call.FunctionName))
                {
                    var funcName = call.FunctionName;
                    if (funcName.Contains('('))
                        funcName = funcName[..funcName.IndexOf('(')];
                    if (!_declaredFunctionNames.Contains(funcName))
                        return funcName;
                    if (_declaredFunctionParamCounts.TryGetValue(funcName, out var counts)
                        && !counts.Contains(call.Arguments.Count))
                        return $"{funcName} (param count mismatch: {call.Arguments.Count})";
                }
            }
        }
        return "undeclared function";
    }

    /// <summary>
    /// Extract the specific broken pattern that matched.
    /// </summary>
    private string GetBrokenPatternDetail(IRMethod method)
    {
        // Match the same order as HasKnownBrokenPatterns in Header.cs
        if (method.DeclaringType?.ILFullName?.Contains("System.Runtime.Intrinsics") == true)
            return "System.Runtime.Intrinsics namespace";

        // SIMD-specific BCL method variants
        if (method.Name.EndsWith("_Sse2") || method.Name.EndsWith("_Sse41") ||
            method.Name.EndsWith("_Sse3") || method.Name.EndsWith("_Avx") ||
            method.Name.EndsWith("_Avx2") || method.Name.EndsWith("_Intrinsified"))
            return "SIMD-specific method variant";

        // SIMD-heavy BCL internal types
        if (method.DeclaringType?.ILFullName is "System.Text.Ascii"
                                              or "System.Text.Latin1Utility"
                                              or "System.Text.Utf16Utility"
                                              or "System.Buffers.IndexOfAnyAsciiSearcher")
            return "SIMD-heavy BCL type";

        // Check self-recursion
        var selfCallPattern = $"{method.CppName}(";
        foreach (var block in method.BasicBlocks)
        {
            foreach (var instr in block.Instructions)
            {
                if (instr is IR.IRCall call && call.FunctionName == method.CppName)
                    return "self-recursive call";
                if (instr.ToCpp().Contains(selfCallPattern))
                    return "self-recursive call";
            }
        }

        // Check specific instruction patterns + undeclared TypeInfo
        foreach (var block in method.BasicBlocks)
        {
            foreach (var instr in block.Instructions)
            {
                var code = instr.ToCpp();
                if (HasUndeclaredTypeInfoRef(code, _knownTypeNames))
                {
                    var tiIdx = code.IndexOf("_TypeInfo");
                    if (tiIdx >= 0)
                    {
                        int start = tiIdx - 1;
                        while (start >= 0 && (char.IsLetterOrDigit(code[start]) || code[start] == '_'))
                            start--;
                        var typeName = code[(start + 1)..tiIdx];
                        return $"undeclared TypeInfo: {typeName}";
                    }
                    return "undeclared TypeInfo reference";
                }
                if (code.Contains("(uintptr_t)(") && code.Contains(".f_"))
                    return "uintptr_t cast + struct field access";
                if (code.Contains("volatile_write((bool*)"))
                    return "volatile_write bool* (no template specialization)";
                if (code.Contains("array_length(0)"))
                    return "array op with null literal";
                if (code.StartsWith("&") && code.Contains(" = &"))
                    return "invalid stind (&param = &local)";
                if (code.Contains("GCFrameRegistration__ctor"))
                    return "GCFrameRegistration void**/intptr_t* mismatch";
                if (code.Contains("(uintptr_t)(") && (code.Contains("->f_") || code.Contains("sizeof(")))
                    return "uintptr_t cast + member/sizeof access";
                if (code.Contains("_1_T*") || code.Contains("_1_T,") || code.Contains("_2_T*")
                    || code.Contains("_1_TKey*") || code.Contains("_1_TValue*")
                    || code.Contains("_1_TResult*")
                    || code.Contains("_1_TFrom") || code.Contains("_1_TTo"))
                    return "unresolved generic type param in instruction";
            }
        }

        return "unknown broken pattern";
    }

    /// <summary>
    /// Identify which rendered error pattern matched.
    /// Only called when analyzer is active (more expensive, does double-check).
    /// </summary>
    private string GetRenderedErrorDetail(string rendered, IRMethod method)
    {
        if (method.IsStatic && rendered.Contains("__this"))
            return "__this in static method";
        if (method.ReturnTypeCpp is "intptr_t" or "uintptr_t" && rendered.Contains("= (void*)"))
            return "void* → intptr_t implicit conversion";
        if (rendered.Contains("gc_allocate_uninitialized_array") && rendered.Contains("CompareExchange"))
            return "gc_allocate_uninitialized_array + CompareExchange type mismatch";
        if (rendered.Contains("Action_1_System_Object_Invoke"))
            return "undeclared Action<Object> delegate specialization";
        if (rendered.Contains("CancellationToken") && rendered.Contains("->f_message = (cil2cpp::String*)"))
            return "CancellationToken → String* cast (BCL IL body bug)";

        // Check for undeclared _statics references
        foreach (var line in rendered.AsSpan().EnumerateLines())
        {
            var s = line.ToString().TrimStart();
            if (s.Length == 0 || s.StartsWith("//") || s.StartsWith("#")) continue;
            var staticsIdx = s.IndexOf("_statics.", StringComparison.Ordinal);
            if (staticsIdx > 0)
            {
                var start = staticsIdx - 1;
                while (start > 0 && (char.IsLetterOrDigit(s[start - 1]) || s[start - 1] == '_'))
                    start--;
                var typeName = s[start..staticsIdx];
                if (typeName.Length > 0 && !_knownTypeNames.Contains(typeName))
                    return $"undeclared statics: {typeName}_statics";
            }
        }

        // Multi-line patterns — just identify the category
        if (rendered.Contains("= *(cil2cpp::Object**)"))
            return "Object* from byref dereference used as typed pointer";
        if (method.Parameters.Any(p => p.CppTypeName == "cil2cpp::Object*"))
            return "unrelated pointer type comparison";
        if (rendered.Contains("cil2cpp::Object* __t") && rendered.Contains("= nullptr;"))
            return "Object* variable assigned non-pointer value";

        return "trial render error (unclassified)";
    }

    /// <summary>
    /// Generate stub file: fallback implementations for declared-but-not-defined methods.
    /// </summary>
    private GeneratedFile GenerateStubFile()
    {
        var sb = new StringBuilder();
        EmitSourceFileHeader(sb, "Stubs: fallback implementations for runtime-provided/unreachable methods");

        GenerateMissingMethodStubImpls(sb, _emittedMethodSignatures, _userTypes);

        return new GeneratedFile
        {
            FileName = $"{_module.Name}_stubs.cpp",
            Content = sb.ToString()
        };
    }

    /// <summary>
    /// Partition types into adaptively-sized buckets using greedy bin-packing.
    /// Partition count is deterministic (based on code size only, not CPU cores)
    /// so the same input always produces the same output on any machine.
    /// Returns non-empty partitions only.
    /// </summary>
    private static List<List<IRType>> PartitionTypes(List<IRType> types)
    {
        // Filter to types with emittable methods, sorted largest-first
        var typesWithMethods = types
            .Select(t => (type: t, size: EstimateMethodSize(t)))
            .Where(x => x.size > 0)
            .OrderByDescending(x => x.size)
            .ToList();

        if (typesWithMethods.Count == 0)
            return new List<List<IRType>> { new() };

        int totalSize = typesWithMethods.Sum(x => x.size);

        // Adaptive partition count: min of two constraints
        // 1. Size-based: each partition should have enough code to amortize header re-parsing
        int fromSize = Math.Max(1, totalSize / MinInstructionsPerPartition);
        // 2. Type-based: can't split finer than per-type
        int fromTypes = typesWithMethods.Count;

        // Note: we do NOT use Environment.ProcessorCount here — generated output must be
        // deterministic (same input → same files on any machine). The build system (cmake --parallel)
        // handles core scheduling.
        int partitionCount = Math.Max(1, Math.Min(fromSize, fromTypes));

        var partitions = new (List<IRType> types, int totalSize)[partitionCount];
        for (int i = 0; i < partitionCount; i++)
            partitions[i] = (new List<IRType>(), 0);

        // Greedy: assign each type to the partition with the smallest total size
        foreach (var (type, size) in typesWithMethods)
        {
            int minIdx = 0;
            for (int i = 1; i < partitionCount; i++)
            {
                if (partitions[i].totalSize < partitions[minIdx].totalSize)
                    minIdx = i;
            }
            partitions[minIdx].types.Add(type);
            partitions[minIdx].totalSize += size;
        }

        return partitions.Select(p => p.types).Where(l => l.Count > 0).ToList();
    }

    /// <summary>
    /// Estimate the total method body size for a type (instruction count across all emittable methods).
    /// </summary>
    private static int EstimateMethodSize(IRType type)
    {
        if (type.IsDelegate) return 0;
        int total = 0;
        foreach (var method in type.Methods)
        {
            if (method.IsAbstract || method.IsInternalCall || method.IsPInvoke) continue;
            if (method.BasicBlocks.Count == 0) continue;
            if (method.HasICallMapping) continue;
            total += method.BasicBlocks.Sum(b => b.Instructions.Count);
        }
        return total;
    }

    /// <summary>
    /// Generate stub implementations for methods on RuntimeProvided types that are called
    /// but don't have generated bodies. Only generates for methods with known, clean signatures.
    /// </summary>
    private void GenerateMissingMethodStubImpls(StringBuilder sb, HashSet<string> emittedSignatures,
        List<IRType> userTypes)
    {
        // Build lookup: method CppName → list of IRMethods (multiple overloads possible)
        var methodLookup = new Dictionary<string, List<IRMethod>>();
        foreach (var type in _module.Types)
        {
            foreach (var method in type.Methods)
            {
                if (!methodLookup.TryGetValue(method.CppName, out var list))
                {
                    list = new List<IRMethod>();
                    methodLookup[method.CppName] = list;
                }
                list.Add(method);
            }
        }

        // Generate stubs for ALL declared-but-not-defined functions.
        // This covers IRCall references, VTable entries, static constructor guards,
        // delegate function pointers, etc.
        var stubs = new List<IRMethod>();
        foreach (var funcName in _declaredFunctionNames)
        {
            if (!methodLookup.TryGetValue(funcName, out var methods)) continue;
            foreach (var irMethod in methods)
            {
                var sig = irMethod.GetCppSignature();
                if (emittedSignatures.Contains(sig)) continue;
                stubs.Add(irMethod);
            }
        }

        if (stubs.Count == 0) return;

        sb.AppendLine();
        sb.AppendLine("// ===== Stub Implementations (RuntimeProvided/unreachable type methods) =====");

        // Collect all by-value types from stub signatures that are forward-declared only.
        // Emit empty struct definitions to make them "complete" types for C++.
        var opaqueTypes = new HashSet<string>();
        foreach (var method in stubs)
        {
            var typesToCheck = method.Parameters.Select(p => p.CppTypeName).ToList();
            if (!string.IsNullOrEmpty(method.ReturnTypeCpp) && method.ReturnTypeCpp != "void")
                typesToCheck.Add(method.ReturnTypeCpp);
            foreach (var typeName in typesToCheck)
            {
                if (typeName.EndsWith("*")) continue; // pointer types don't need full definition
                var baseType = typeName.Trim();
                if (string.IsNullOrEmpty(baseType)) continue;
                if (IsCppPrimitiveType(baseType)) continue;
                if (baseType.StartsWith("cil2cpp::")) continue;
                if (_emittedStructDefs.Contains(baseType)) continue;
                if (!IsValidCppIdentifier(baseType)) continue;
                opaqueTypes.Add(baseType);
            }
        }
        if (opaqueTypes.Count > 0)
        {
            sb.AppendLine("// Opaque type definitions for forward-declared-only types used by value in stubs");
            foreach (var typeName in opaqueTypes.OrderBy(n => n))
                sb.AppendLine($"struct {typeName} {{ }}; // opaque — forward-declared only");
            sb.AppendLine();
        }

        // Track emitted function overloads to avoid return-type-only overloads (C++ doesn't support them).
        // Key: "FuncName(type1,type2,...)" — function name + param TYPES only (no names).
        // Pre-populate from already-emitted method signatures (main body section).
        var emittedOverloads = new HashSet<string>();
        // Helper: extract "FuncName(type1, type2)" from a method
        string GetOverloadKey(IRMethod m) =>
            $"{m.CppName}({string.Join(", ", m.Parameters.Select(p => p.CppTypeName))})";
        // Pre-populate from methods that already have emitted signatures
        foreach (var type in _module.Types)
        {
            foreach (var method in type.Methods)
            {
                if (emittedSignatures.Contains(method.GetCppSignature()))
                    emittedOverloads.Add(GetOverloadKey(method));
            }
        }
        foreach (var method in stubs.OrderBy(m => m.CppName))
        {
            var sig = method.GetCppSignature();
            if (!emittedSignatures.Add(sig)) continue;

            // Skip if same function name + param types already emitted (return-type-only overload)
            if (!emittedOverloads.Add(GetOverloadKey(method))) continue;

            // Skip stubs with unresolved generic params (bare name without underscore: TKey, TOther, etc.)
            bool hasProblematicType = false;
            var stubTypesToCheck = method.Parameters.Select(p => p.CppTypeName).ToList();
            if (!string.IsNullOrEmpty(method.ReturnTypeCpp) && method.ReturnTypeCpp != "void")
                stubTypesToCheck.Add(method.ReturnTypeCpp);
            foreach (var typeName in stubTypesToCheck)
            {
                var baseType = typeName.TrimEnd('*').Trim();
                if (string.IsNullOrEmpty(baseType)) continue;
                if (!baseType.Contains('_') && !baseType.StartsWith("cil2cpp::") &&
                    !IsCppPrimitiveType(baseType))
                {
                    hasProblematicType = true;
                    break;
                }
            }
            if (hasProblematicType) continue;

            var knownBody = GetKnownStubBody(method.CppName);
            if (knownBody != null)
            {
                sb.AppendLine($"{sig} {{");
                sb.AppendLine(knownBody);
                sb.AppendLine("}");
            }
            else
            {
                TrackStubWithAnalysis(method, "missing method body (runtime-provided/unreachable)",
                    StubRootCause.MissingBody,
                    method.IrStubReason ?? "runtime-provided or unreachable");
                sb.AppendLine($"{sig} {{");
                if (method.ReturnTypeCpp == "void" || string.IsNullOrEmpty(method.ReturnTypeCpp))
                    sb.AppendLine("    // TODO: compile from IL");
                else if (method.ReturnTypeCpp.EndsWith("*"))
                    sb.AppendLine("    return nullptr; // TODO: compile from IL");
                else if (method.ReturnTypeCpp == "bool")
                    sb.AppendLine("    return false; // TODO: compile from IL");
                else
                    sb.AppendLine("    return {}; // TODO: compile from IL");
                sb.AppendLine("}");
            }
        }
    }

    /// <summary>
    /// Emit a stub body for a method whose trial-rendered C++ body contained error patterns.
    /// The stub prevents compilation errors while still providing a callable function.
    /// </summary>
    private static void GenerateStubForMethod(StringBuilder sb, IRMethod method)
    {
        var knownBody = GetKnownStubBody(method.CppName);
        if (knownBody != null)
        {
            sb.AppendLine($"{method.GetCppSignature()} {{");
            sb.AppendLine(knownBody);
            sb.AppendLine("}");
            return;
        }
        sb.AppendLine($"// {method.DeclaringType?.ILFullName}::{method.Name} (stub — body has codegen errors)");
        sb.AppendLine($"{method.GetCppSignature()} {{");
        if (method.ReturnTypeCpp == "void" || string.IsNullOrEmpty(method.ReturnTypeCpp))
            sb.AppendLine("    // TODO: fix codegen for this method");
        else if (method.ReturnTypeCpp.EndsWith("*"))
            sb.AppendLine("    return nullptr; // TODO: fix codegen for this method");
        else if (method.ReturnTypeCpp == "bool")
            sb.AppendLine("    return false; // TODO: fix codegen for this method");
        else
            sb.AppendLine("    return {}; // TODO: fix codegen for this method");
        sb.AppendLine("}");
    }

    private void GenerateTypeInfo(StringBuilder sb, IRType type)
    {
        // For enum/delegate types skipped by EmitReflectionMetadata, emit type-level custom attrs
        if ((type.IsEnum || type.IsDelegate) && type.CustomAttributes.Count > 0)
        {
            EmitAttributeInfoArray(sb, $"{type.CppName}_custom_attrs", type.CustomAttributes);
        }

        var baseName = type.BaseType != null ? $"&{type.BaseType.CppName}_TypeInfo" : "nullptr";

        // Interfaces array (EmitInterfaceData skips interfaces themselves, so null for them)
        var interfacesExpr = (!type.IsInterface && type.Interfaces.Count > 0) ? $"{type.CppName}_interfaces" : "nullptr";
        var interfaceCount = type.IsInterface ? 0 : type.Interfaces.Count;

        // VTable (delegates have no vtable)
        var vtableExpr = (!type.IsInterface && !type.IsDelegate && type.VTable.Count > 0) ? $"&{type.CppName}_VTable" : "nullptr";

        // Interface vtables (also skipped for interfaces)
        var ifaceVtablesExpr = (!type.IsInterface && type.InterfaceImpls.Count > 0) ? $"{type.CppName}_interface_vtables" : "nullptr";
        var ifaceVtableCount = type.IsInterface ? 0 : type.InterfaceImpls.Count;

        // Finalizer
        var finalizerExpr = (type.Finalizer != null && !type.IsRuntimeProvided) ? $"{type.CppName}_finalizer_wrapper" : "nullptr";

        // Instance size (interfaces have no struct)
        var instanceSize = type.IsInterface ? "0" : $"sizeof({type.CppName})";

        // Flags
        var flagParts = new List<string>();
        if (type.IsValueType) flagParts.Add("cil2cpp::TypeFlags::ValueType");
        if (type.IsInterface) flagParts.Add("cil2cpp::TypeFlags::Interface");
        if (type.IsAbstract) flagParts.Add("cil2cpp::TypeFlags::Abstract");
        if (type.IsSealed) flagParts.Add("cil2cpp::TypeFlags::Sealed");
        if (type.IsEnum) flagParts.Add("cil2cpp::TypeFlags::Enum");
        var flagsStr = flagParts.Count > 0 ? string.Join(" | ", flagParts) : "cil2cpp::TypeFlags::None";

        sb.AppendLine($"cil2cpp::TypeInfo {type.CppName}_TypeInfo = {{");
        sb.AppendLine($"    .name = \"{type.Name}\",");
        sb.AppendLine($"    .namespace_name = \"{type.Namespace}\",");
        sb.AppendLine($"    .full_name = \"{type.ILFullName}\",");
        sb.AppendLine($"    .base_type = {baseName},");
        sb.AppendLine($"    .interfaces = {interfacesExpr},");
        sb.AppendLine($"    .interface_count = {interfaceCount},");
        sb.AppendLine($"    .instance_size = {instanceSize},");
        sb.AppendLine($"    .element_size = 0,");
        sb.AppendLine($"    .flags = {flagsStr},");
        sb.AppendLine($"    .vtable = {vtableExpr},");
        // Reflection metadata: FieldInfo/MethodInfo arrays
        // Enums and delegates skip EmitReflectionMetadata, so always use nullptr for them
        var allFields = type.Fields.Concat(type.StaticFields).ToList();
        var reflectableMethods = type.Methods.Where(m => !CppNameMapper.IsCompilerGeneratedType(m.Name)).ToList();
        var skipReflection = type.IsEnum || type.IsDelegate || type.IsRuntimeProvided
            || CppNameMapper.IsRuntimeExceptionType(type.ILFullName);
        var fieldsExpr = (!skipReflection && allFields.Count > 0) ? $"{type.CppName}_fields" : "nullptr";
        var methodsExpr = (!skipReflection && reflectableMethods.Count > 0) ? $"{type.CppName}_methods" : "nullptr";
        if (skipReflection) { allFields = new(); reflectableMethods = new(); }
        sb.AppendLine($"    .fields = {fieldsExpr},");
        sb.AppendLine($"    .field_count = {allFields.Count},");
        sb.AppendLine($"    .methods = {methodsExpr},");
        sb.AppendLine($"    .method_count = {reflectableMethods.Count},");
        sb.AppendLine($"    .default_ctor = nullptr,");
        sb.AppendLine($"    .finalizer = {finalizerExpr},");
        sb.AppendLine($"    .interface_vtables = {ifaceVtablesExpr},");
        sb.AppendLine($"    .interface_vtable_count = {ifaceVtableCount},");
        // Custom attributes
        var typeAttrsExpr = (!skipReflection && type.CustomAttributes.Count > 0)
            ? $"{type.CppName}_custom_attrs" : "nullptr";
        var typeAttrCount = skipReflection ? 0 : type.CustomAttributes.Count;
        sb.AppendLine($"    .custom_attributes = {typeAttrsExpr},");
        sb.AppendLine($"    .custom_attribute_count = {typeAttrCount},");
        // Generic variance data (must match EmitGenericVarianceData filter)
        var typeInfoLookup = BuildTypeInfoExprLookup();
        var hasGenericArgs = type.IsGenericInstance && type.GenericArguments.Count > 0
                             && type.GenericParameterVariances.Count > 0
                             && type.GenericArguments.All(arg => typeInfoLookup.ContainsKey(arg));
        var genArgsExpr = hasGenericArgs ? $"{type.CppName}_generic_args" : "nullptr";
        var genVarExpr = hasGenericArgs ? $"{type.CppName}_generic_variances" : "nullptr";
        var genCount = hasGenericArgs ? type.GenericArguments.Count : 0;
        var genDefName = type.GenericDefinitionCppName != null
            ? $"\"{type.GenericDefinitionCppName}\"" : "nullptr";
        sb.AppendLine($"    .generic_arguments = {genArgsExpr},");
        sb.AppendLine($"    .generic_variances = {genVarExpr},");
        sb.AppendLine($"    .generic_argument_count = {genCount},");
        sb.AppendLine($"    .generic_definition_name = {genDefName},");
        sb.AppendLine("};");
    }

    private void GenerateMethodImpl(StringBuilder sb, IRMethod method)
    {
        sb.AppendLine($"// {method.DeclaringType?.ILFullName}::{method.Name}");
        sb.AppendLine($"{method.GetCppSignature()} {{");

        // Declare local variables
        foreach (var local in method.Locals)
        {
            var defaultVal = CppNameMapper.GetDefaultValue(local.CppTypeName);
            sb.AppendLine($"    {local.CppTypeName} {local.CppName} = {defaultVal};");
        }

        // Collect temp variables that need auto declarations
        var declaredTemps = new HashSet<string>();
        string? lastLineDirective = null;

        // Check if method has any labels (branch targets)
        var allInstructions = method.BasicBlocks.SelectMany(b => b.Instructions).ToList();
        bool hasLabels = allInstructions.Any(i => i is IRLabel);

        // Pre-declare temp variables used across label scopes
        // (variables declared inside one { } label scope can't be used in another)
        if (hasLabels)
        {
            var crossScopeVars = FindCrossScopeVariables(allInstructions);
            // Determine actual types from IRCall.ResultTypeCpp for each temp var
            var tempVarTypes = DetermineTempVarTypes(allInstructions);
            foreach (var varName in crossScopeVars)
            {
                var typeName = tempVarTypes.GetValueOrDefault(varName);
                if (typeName == null)
                {
                    // Type unknown: default to Object* (most cross-scope temps are pointer types)
                    sb.AppendLine($"    cil2cpp::Object* {varName} = nullptr;");
                }
                else
                {
                    var initVal = typeName.EndsWith("*") ? "nullptr" : "{}";
                    sb.AppendLine($"    {typeName} {varName} = {initVal};");
                }
                declaredTemps.Add(varName);
            }
        }
        bool inLabelScope = false;
        bool gotoScopeOpen = false;

        // Emit basic blocks
        foreach (var block in method.BasicBlocks)
        {
            foreach (var instr in block.Instructions)
            {
                // When entering a label, close goto scope and label scope
                if (hasLabels && instr is IRLabel)
                {
                    if (gotoScopeOpen)
                    {
                        sb.AppendLine("    }");
                        gotoScopeOpen = false;
                    }
                    if (inLabelScope)
                        sb.AppendLine("    }");
                    // Emit the label at function scope
                    sb.AppendLine($"    {instr.ToCpp()}");
                    sb.AppendLine("    {");
                    inLabelScope = true;
                    continue;
                }

                // Exception handling instructions must be at function scope
                // (CIL2CPP_TRY/CATCH/FINALLY/END_TRY macros expand to { if / } else if / } })
                if (instr is IRTryBegin or IRCatchBegin or IRFinallyBegin or IRFilterBegin or IRTryEnd)
                {
                    if (gotoScopeOpen)
                    {
                        sb.AppendLine("    }");
                        gotoScopeOpen = false;
                    }
                    if (inLabelScope)
                    {
                        sb.AppendLine("    }");
                        inLabelScope = false;
                    }
                }

                // Emit IL offset comment in Debug mode
                if (_config.EmitILOffsetComments && instr.DebugInfo != null && instr.DebugInfo.ILOffset >= 0
                    && instr is not IRComment && instr is not IRLabel)
                {
                    sb.AppendLine($"    /* IL_{instr.DebugInfo.ILOffset:X4} */");
                }

                // Emit #line directive in Debug mode (when source info is available)
                if (_config.EmitLineDirectives && instr.DebugInfo != null
                    && instr.DebugInfo.Line > 0
                    && !string.IsNullOrEmpty(instr.DebugInfo.FilePath)
                    && instr is not IRComment && instr is not IRLabel)
                {
                    // Normalize path separators for C++ (use forward slashes)
                    var filePath = instr.DebugInfo.FilePath.Replace("\\", "/");
                    var directive = $"#line {instr.DebugInfo.Line} \"{filePath}\"";

                    // Only emit if different from the last directive
                    if (directive != lastLineDirective)
                    {
                        sb.AppendLine($"    {directive}");
                        lastLineDirective = directive;
                    }
                }

                var code = instr.ToCpp();

                // Strip embedded 'auto' from IRRawCpp when the variable was already
                // pre-declared by cross-scope analysis. Without this, the pre-declared
                // typed variable (e.g. "cil2cpp::Array* __t0 = nullptr;") conflicts with
                // the embedded "auto __t0 = ..." (MSVC C2040: indirection levels differ).
                if (instr is IRRawCpp && code.StartsWith("auto __t"))
                {
                    var spaceIdx = code.IndexOf(' ');
                    if (spaceIdx >= 0)
                    {
                        // Extract variable name: "auto __t0 = ..." → "__t0"
                        var afterAuto = code[(spaceIdx + 1)..];
                        var eqIdx = afterAuto.IndexOf(' ');
                        var varName = eqIdx >= 0 ? afterAuto[..eqIdx] : afterAuto;
                        if (declaredTemps.Contains(varName))
                            code = afterAuto; // strip "auto " prefix
                    }
                }

                // For instructions that assign to temp vars, add 'auto' on first use
                code = AddAutoDeclarations(code, declaredTemps);

                var indent = (inLabelScope || gotoScopeOpen) ? "        " : "    ";
                sb.AppendLine($"{indent}{code}");

                // After a conditional/unconditional branch in the outer scope,
                // open a scope to prevent goto from crossing auto declarations (C++ C2362)
                if (hasLabels && !inLabelScope && !gotoScopeOpen
                    && (instr is IRConditionalBranch || instr is IRBranch))
                {
                    sb.AppendLine("    {");
                    gotoScopeOpen = true;
                }
            }
        }

        // Close last goto scope
        if (gotoScopeOpen)
            sb.AppendLine("    }");
        // Close last label scope
        if (inLabelScope)
            sb.AppendLine("    }");

        // In C++, there is no "#line default" like in C#.
        // We simply stop emitting #line directives; the compiler continues
        // using the last #line mapping until it encounters a new one.

        // If method doesn't end with return, add one
        var lastInstr = method.BasicBlocks
            .SelectMany(b => b.Instructions)
            .LastOrDefault();
        if (lastInstr is not IRReturn)
        {
            if (method.ReturnTypeCpp == "void")
                sb.AppendLine("    return;");
        }

        sb.AppendLine("}");
        sb.AppendLine();
    }

    /// <summary>
    /// Find temp variables that are referenced across multiple label scopes.
    /// These must be pre-declared at function scope to avoid C++ scoping issues.
    /// </summary>
    private static HashSet<string> FindCrossScopeVariables(List<IRInstruction> instructions)
    {
        var result = new HashSet<string>();
        // Track which scope each variable is first assigned/used in
        // scope 0 = function scope, incrementing for each IRLabel
        int currentScope = 0;
        var varFirstScope = new Dictionary<string, int>();

        foreach (var instr in instructions)
        {
            if (instr is IRLabel)
            {
                currentScope++;
                continue;
            }

            var code = instr.ToCpp();
            // Find all __tN references in the code
            for (int i = 0; i < code.Length - 3; i++)
            {
                if (code[i] == '_' && code[i + 1] == '_' && code[i + 2] == 't'
                    && i + 3 < code.Length && char.IsDigit(code[i + 3]))
                {
                    // Check we're not inside __this, __type_info, etc.
                    if (i > 0 && char.IsLetterOrDigit(code[i - 1])) continue;

                    // Extract full variable name __tN
                    int end = i + 3;
                    while (end < code.Length && char.IsDigit(code[end])) end++;
                    // Make sure it's not followed by more identifier chars
                    if (end < code.Length && (char.IsLetter(code[end]) || code[end] == '_')) continue;

                    var varName = code[i..end];
                    if (varFirstScope.TryGetValue(varName, out var firstScope))
                    {
                        if (firstScope != currentScope)
                            result.Add(varName);
                    }
                    else
                    {
                        varFirstScope[varName] = currentScope;
                    }
                }
            }
        }
        return result;
    }

    /// <summary>
    /// Determine the C++ type of each __tN temp variable by scanning all IR instructions.
    /// Returns a map from variable name to its C++ type (e.g., "__t0" → "System_IO_TextWriter*").
    /// </summary>
    private static Dictionary<string, string> DetermineTempVarTypes(List<IRInstruction> instructions)
    {
        var types = new Dictionary<string, string>();
        foreach (var instr in instructions)
        {
            switch (instr)
            {
                case IRCall call when call.ResultVar != null && call.ResultTypeCpp != null:
                    types.TryAdd(call.ResultVar, call.ResultTypeCpp);
                    break;
                case IRNewObj newObj when newObj.ResultVar != null:
                    types.TryAdd(newObj.ResultVar, newObj.TypeCppName + "*");
                    break;
                case IRFieldAccess fa when !fa.IsStore && fa.ResultVar != null && fa.ResultTypeCpp != null:
                    types.TryAdd(fa.ResultVar, fa.ResultTypeCpp);
                    break;
                case IRStaticFieldAccess sfa when !sfa.IsStore && sfa.ResultVar != null && sfa.ResultTypeCpp != null:
                    types.TryAdd(sfa.ResultVar, sfa.ResultTypeCpp);
                    break;
                case IRCast cast when cast.ResultVar != null:
                    types.TryAdd(cast.ResultVar, cast.TargetTypeCpp);
                    break;
                case IRConversion conv when conv.ResultVar != null:
                    types.TryAdd(conv.ResultVar, conv.TargetType);
                    break;
                case IRBox box when box.ResultVar != null:
                    types.TryAdd(box.ResultVar, "cil2cpp::Object*");
                    break;
                case IRUnbox unbox when unbox.ResultVar != null:
                    types.TryAdd(unbox.ResultVar, unbox.IsUnboxAny ? unbox.ValueTypeCppName : unbox.ValueTypeCppName + "*");
                    break;
                case IRArrayAccess aa when !aa.IsStore && aa.ResultVar != null:
                    types.TryAdd(aa.ResultVar, aa.ElementType);
                    break;
                case IRLoadFunctionPointer lfp when lfp.ResultVar != null:
                    types.TryAdd(lfp.ResultVar, "void*");
                    break;
                case IRDelegateCreate dc when dc.ResultVar != null:
                    types.TryAdd(dc.ResultVar, "cil2cpp::Delegate*");
                    break;
                case IRDelegateInvoke di when di.ResultVar != null:
                    types.TryAdd(di.ResultVar, di.ReturnTypeCpp);
                    break;
                case IRRawCpp raw when raw.ResultVar != null && raw.ResultTypeCpp != null:
                    types.TryAdd(raw.ResultVar, raw.ResultTypeCpp);
                    break;
                // IRBinaryOp: comparisons produce bool, arithmetic produces intptr_t
                case IRBinaryOp binOp when binOp.ResultVar.StartsWith("__t"):
                {
                    var resultType = binOp.Op is "==" or "!=" or "<" or ">" or "<=" or ">="
                        ? "bool" : "intptr_t";
                    types.TryAdd(binOp.ResultVar, resultType);
                    break;
                }
                // Fallback: infer type from IRRawCpp code patterns
                case IRRawCpp raw2 when raw2.ResultVar == null || raw2.ResultTypeCpp == null:
                    InferTypeFromRawCpp(raw2.Code, types);
                    break;
            }
        }
        return types;
    }

    /// <summary>
    /// Infer temp variable types from IRRawCpp code patterns.
    /// Handles cases where ResultVar/ResultTypeCpp aren't set on the instruction.
    /// </summary>
    private static void InferTypeFromRawCpp(string code, Dictionary<string, string> types)
    {
        // Match: __tN = (type)expr; or __tN = (type*)expr;
        if (!code.StartsWith("__t") || code.StartsWith("__this")) return;
        var eqIdx = code.IndexOf(" = ");
        if (eqIdx <= 0) return;
        var varName = code[..eqIdx].Trim();
        if (!varName.StartsWith("__t") || !varName.Skip(3).All(char.IsDigit)) return;
        if (types.ContainsKey(varName)) return;

        var rhs = code[(eqIdx + 3)..].TrimEnd(';').Trim();

        // (type)expr or (type*)expr — extract the cast type
        if (rhs.StartsWith("(") && !rhs.StartsWith("(&"))
        {
            var closeIdx = rhs.IndexOf(')');
            if (closeIdx > 1)
            {
                var castType = rhs[1..closeIdx];
                // Only accept simple type names (no nested parens, no operators)
                if (!castType.Contains("(") && !castType.Contains(" ") || castType.EndsWith("*"))
                {
                    types.TryAdd(varName, castType);
                    return;
                }
            }
        }

        // Comparison operators → bool
        if (rhs.Contains(" == ") || rhs.Contains(" != ") ||
            rhs.Contains(" < ") || rhs.Contains(" > ") ||
            rhs.Contains(" <= ") || rhs.Contains(" >= "))
        {
            types.TryAdd(varName, "bool");
            return;
        }

        // Arithmetic/bitwise operators on non-pointer values → int32_t (safe default)
        if ((rhs.Contains(" + ") || rhs.Contains(" - ") || rhs.Contains(" * ") ||
             rhs.Contains(" / ") || rhs.Contains(" % ") || rhs.Contains(" | ") ||
             rhs.Contains(" & ") || rhs.Contains(" ^ ") || rhs.Contains(" << ") ||
             rhs.Contains(" >> ")) && !rhs.Contains("->") && !rhs.Contains("*)"))
        {
            types.TryAdd(varName, "intptr_t"); // intptr_t is safe for both 32/64-bit arithmetic
            return;
        }

        // Negation: -expr → numeric
        if (rhs.StartsWith("-") && !rhs.Contains("->"))
        {
            types.TryAdd(varName, "intptr_t");
            return;
        }

        // ~expr (bitwise NOT) → numeric
        if (rhs.StartsWith("~"))
        {
            types.TryAdd(varName, "intptr_t");
            return;
        }
    }

    /// <summary>
    /// Replace "__tN = expr" with "auto __tN = expr" on first use of temp vars.
    /// Only matches pure temp variables like __t0, __t1, etc.
    /// </summary>
    private string AddAutoDeclarations(string code, HashSet<string> declaredTemps)
    {
        // Null-check prefix: "cil2cpp::null_check(...); __tN = ..."
        // Split into prefix and assignment, then add 'auto' to the assignment part.
        const string nullCheckPrefix = "cil2cpp::null_check(";
        if (code.StartsWith(nullCheckPrefix))
        {
            var splitIdx = code.IndexOf("; __t");
            if (splitIdx > 0)
            {
                var prefix = code[..(splitIdx + 2)]; // "cil2cpp::null_check(...); "
                var rest = code[(splitIdx + 2)..];    // "__tN = ..."
                var declared = AddAutoDeclarations(rest, declaredTemps);
                return prefix + declared;
            }
            return code;
        }

        // Match patterns like "__t0 = ..." but NOT "__this->..."
        if (code.StartsWith("__t") && !code.StartsWith("__this"))
        {
            var eqIdx = code.IndexOf(" = ");
            if (eqIdx > 0)
            {
                var varName = code[..eqIdx].Trim();
                // Must be a simple temp var name like __t0, __t1, etc.
                if (varName.StartsWith("__t") &&
                    varName.All(c => c == '_' || char.IsLetterOrDigit(c)) &&
                    !declaredTemps.Contains(varName))
                {
                    declaredTemps.Add(varName);
                    return $"auto {code}";
                }
            }
        }
        return code;
    }

    /// <summary>
    /// For runtime-provided reference types (System.String, System.Object), return the
    /// qualified name of the runtime's TypeInfo so we can alias to it instead of emitting a new one.
    /// Returns null for types that should get their own generated TypeInfo.
    /// </summary>
    private static string? GetRuntimeTypeInfoAlias(string ilFullName) => ilFullName switch
    {
        "System.String" => "cil2cpp::System::String_TypeInfo",
        "System.Object" => "cil2cpp::System::Object_TypeInfo",
        _ => null,
    };

    /// <summary>
    /// Generate a typed function pointer cast expression for a method, to resolve overload ambiguity.
    /// E.g., (void*)(void(*)(Foo*, int32_t))&Foo_Bar
    /// </summary>
    private string GetTypedMethodPointerCast(IRMethod method)
    {
        if (method.IsAbstract || method.BasicBlocks.Count == 0)
            return "nullptr";

        // Use actual declared parameter types for the cast so it matches the function
        // declaration — needed for overload resolution with MSVC.
        // Only sanitize IL function pointer types (contain parentheses) to void*.
        var retType = SanitizeFuncPtrType(method.ReturnTypeCpp ?? "void");
        var paramTypes = new List<string>();
        // Instance methods have implicit 'this' parameter
        if (!method.IsStatic && method.DeclaringType != null)
        {
            paramTypes.Add($"{method.DeclaringType.CppName}*");
        }
        foreach (var p in method.Parameters)
            paramTypes.Add(SanitizeFuncPtrType(p.CppTypeName));

        var funcPtrType = $"{retType}(*)({string.Join(", ", paramTypes)})";
        return $"(void*)({funcPtrType})&{method.CppName}";
    }

    /// <summary>
    /// Replace IL function pointer types (containing parentheses) with void*.
    /// These types can't be expressed in C++ function pointer casts.
    /// </summary>
    private static string SanitizeFuncPtrType(string cppType)
    {
        if (cppType.Contains("(") || cppType.Contains(")"))
            return "void*";
        return cppType;
    }

    /// <summary>
    /// Replace pointer-to-unknown-struct types with void* for safe function pointer casts.
    /// Types not defined in the compilation unit (BCL types like System_Type*) cause C++ errors.
    /// </summary>
    private string SafeCppType(string cppType)
    {
        if (cppType.EndsWith("*"))
        {
            var baseType = cppType.TrimEnd('*').Trim();
            if (baseType.StartsWith("cil2cpp::") || IsCppPrimitiveType(baseType))
                return cppType;
            // Check if the struct type is defined in the compilation unit
            if (_knownStructTypes == null) BuildKnownStructTypes();
            if (!_knownStructTypes!.Contains(baseType))
                return "void*";
        }
        return cppType;
    }

    private HashSet<string>? _knownStructTypes;
    private void BuildKnownStructTypes()
    {
        _knownStructTypes = new HashSet<string>();
        foreach (var type in _module.Types)
        {
            if (CppNameMapper.IsCompilerGeneratedType(type.ILFullName)) continue;
            if (type.IsInterface && type.Fields.Count == 0) continue;
            _knownStructTypes.Add(type.CppName);
        }
    }

    private void EmitVTableData(StringBuilder sb, List<IRType> userTypes)
    {
        // Build set of types whose methods are actually generated as C++ functions.
        // Methods from runtime-provided types (Object, ValueType, Enum, etc.) don't exist
        // as generated functions — VTable entries must use fallbacks for them.
        var generatedMethodTypes = new HashSet<string>();
        foreach (var t in userTypes)
        {
            // Non-core runtime-provided types (Task, Thread) have methods generated from BCL IL
            var isCoreRuntime = t.IsRuntimeProvided && IRBuilder.CoreRuntimeTypes.Contains(t.ILFullName);
            if (!isCoreRuntime && !t.IsDelegate)
                generatedMethodTypes.Add(t.CppName);
        }

        bool any = false;
        foreach (var type in userTypes)
        {
            // Skip core runtime types (Object, String) but generate vtables for non-core (Task, Thread)
            var isCoreRuntime = type.IsRuntimeProvided && IRBuilder.CoreRuntimeTypes.Contains(type.ILFullName);
            if (type.IsInterface || type.IsDelegate || isCoreRuntime || type.VTable.Count == 0) continue;
            if (!any)
            {
                sb.AppendLine("// ===== VTable Data =====");
                any = true;
            }

            // Build lookup of parent vtable entries for inheritance fallback
            var parentVTableEntries = new Dictionary<int, string>();
            {
                var baseType = type.BaseType;
                // Walk up the inheritance chain to find valid vtable entries
                while (baseType != null)
                {
                    for (int si = 0; si < baseType.VTable.Count; si++)
                    {
                        if (parentVTableEntries.ContainsKey(si)) continue;
                        var be = baseType.VTable[si];
                        if (be.Method != null && !be.Method.IsAbstract
                            && _declaredFunctionNames.Contains(be.Method.CppName))
                        {
                            parentVTableEntries[si] = GetTypedMethodPointerCast(be.Method);
                        }
                    }
                    baseType = baseType.BaseType;
                }
            }

            // Method pointer array
            var methods = string.Join(", ", type.VTable.Select((e, idx) =>
            {
                if (e.Method != null && !e.Method.IsAbstract)
                {
                    // If the method's declaring type is a core runtime type or not in generated types,
                    // the C++ function won't exist — use fallback
                    var declType = e.Method.DeclaringType;
                    var isDeclCoreRuntime = declType != null && declType.IsRuntimeProvided
                        && IRBuilder.CoreRuntimeTypes.Contains(declType.ILFullName);
                    if (declType != null && (isDeclCoreRuntime || !generatedMethodTypes.Contains(declType.CppName)))
                        return ObjectMethodFallbacks.GetValueOrDefault(e.MethodName, "nullptr");
                    // Check if the function was actually declared in the header
                    if (!_declaredFunctionNames.Contains(e.Method.CppName))
                    {
                        // Fallback: inherit from parent vtable if available
                        if (parentVTableEntries.TryGetValue(idx, out var parentMethod))
                            return parentMethod;
                        return ObjectMethodFallbacks.GetValueOrDefault(e.MethodName, "nullptr");
                    }
                    return GetTypedMethodPointerCast(e.Method);
                }
                // Method not assigned — try parent fallback
                if (parentVTableEntries.TryGetValue(idx, out var inherited))
                    return inherited;
                return ObjectMethodFallbacks.GetValueOrDefault(e.MethodName, "nullptr");
            }));
            sb.AppendLine($"static void* {type.CppName}_vtable_methods[] = {{ {methods} }};");
            sb.AppendLine($"static cil2cpp::VTable {type.CppName}_VTable = {{ &{type.CppName}_TypeInfo, {type.CppName}_vtable_methods, {type.VTable.Count} }};");
        }
        if (any) sb.AppendLine();
    }

    private void EmitInterfaceData(StringBuilder sb, List<IRType> userTypes)
    {
        // Build set of types whose methods are generated (same as EmitVTableData)
        var generatedMethodTypes = new HashSet<string>();
        foreach (var t in userTypes)
        {
            var isCoreRuntime = t.IsRuntimeProvided && IRBuilder.CoreRuntimeTypes.Contains(t.ILFullName);
            if (!isCoreRuntime && !t.IsDelegate)
                generatedMethodTypes.Add(t.CppName);
        }

        bool any = false;
        foreach (var type in userTypes)
        {
            var isCoreRuntime = type.IsRuntimeProvided && IRBuilder.CoreRuntimeTypes.Contains(type.ILFullName);
            if (type.IsInterface || isCoreRuntime || type.Interfaces.Count == 0) continue;
            if (!any)
            {
                sb.AppendLine("// ===== Interface Data =====");
                any = true;
            }

            // Interfaces pointer array
            var ifaces = string.Join(", ", type.Interfaces.Select(i => $"&{i.CppName}_TypeInfo"));
            sb.AppendLine($"static cil2cpp::TypeInfo* {type.CppName}_interfaces[] = {{ {ifaces} }};");
        }

        // Interface vtable method arrays and InterfaceVTable arrays
        foreach (var type in userTypes)
        {
            var isCoreRt = type.IsRuntimeProvided && IRBuilder.CoreRuntimeTypes.Contains(type.ILFullName);
            if (type.IsInterface || isCoreRt || type.InterfaceImpls.Count == 0) continue;

            foreach (var impl in type.InterfaceImpls)
            {
                var methods = string.Join(", ", impl.MethodImpls.Select(m =>
                {
                    if (m == null) return "nullptr";
                    // If the method's declaring type is a core runtime type or not generated, use nullptr
                    var declType = m.DeclaringType;
                    var isDeclCoreRt = declType != null && declType.IsRuntimeProvided
                        && IRBuilder.CoreRuntimeTypes.Contains(declType.ILFullName);
                    if (declType != null && (isDeclCoreRt || !generatedMethodTypes.Contains(declType.CppName)))
                        return "nullptr";
                    // Check if the function was actually declared in the header
                    if (!_declaredFunctionNames.Contains(m.CppName))
                        return "nullptr";
                    return GetTypedMethodPointerCast(m);
                }));
                // MSVC: zero-size arrays are not allowed (C2466)
                if (string.IsNullOrWhiteSpace(methods))
                    methods = "nullptr";
                sb.AppendLine($"static void* {type.CppName}_iface_{impl.Interface.CppName}_methods[] = {{ {methods} }};");
            }

            var entries = type.InterfaceImpls.Select(impl =>
                $"{{ &{impl.Interface.CppName}_TypeInfo, {type.CppName}_iface_{impl.Interface.CppName}_methods, {impl.MethodImpls.Count} }}");
            sb.AppendLine($"static cil2cpp::InterfaceVTable {type.CppName}_interface_vtables[] = {{");
            sb.AppendLine($"    {string.Join(",\n    ", entries)}");
            sb.AppendLine("};");
        }
        if (any) sb.AppendLine();
    }

    private void EmitGenericVarianceData(StringBuilder sb, List<IRType> userTypes)
    {
        var typeInfoLookup = BuildTypeInfoExprLookup();
        bool any = false;
        foreach (var type in userTypes)
        {
            if (type.IsRuntimeProvided) continue;
            if (!type.IsGenericInstance || type.GenericArguments.Count == 0
                || type.GenericParameterVariances.Count == 0) continue;

            // Verify all generic arguments have TypeInfo available
            bool allArgsResolvable = type.GenericArguments.All(arg =>
                typeInfoLookup.ContainsKey(arg));
            if (!allArgsResolvable) continue;

            if (!any)
            {
                sb.AppendLine("// ===== Generic Variance Data =====");
                any = true;
            }

            // Emit TypeInfo pointer array for generic arguments
            var argRefs = type.GenericArguments.Select(arg => typeInfoLookup[arg]);
            sb.AppendLine($"static cil2cpp::TypeInfo* {type.CppName}_generic_args[] = {{ {string.Join(", ", argRefs)} }};");

            // Emit variance array
            var variances = type.GenericParameterVariances.Select(v => ((byte)v).ToString());
            sb.AppendLine($"static uint8_t {type.CppName}_generic_variances[] = {{ {string.Join(", ", variances)} }};");
        }
        if (any) sb.AppendLine();
    }

    private void EmitFinalizerWrappers(StringBuilder sb, List<IRType> userTypes)
    {
        bool any = false;
        foreach (var type in userTypes)
        {
            if (type.Finalizer == null) continue;
            // Skip runtime-provided types — their Finalize method isn't generated
            if (type.IsRuntimeProvided) continue;
            // BCL types have stub finalizers — use System_Object_Finalize as fallback
            var isStubbed = type.SourceKind == AssemblyKind.BCL;
            if (!any)
            {
                sb.AppendLine("// ===== Finalizer Wrappers =====");
                any = true;
            }

            sb.AppendLine($"static void {type.CppName}_finalizer_wrapper(cil2cpp::Object* obj) {{");
            if (isStubbed)
                sb.AppendLine($"    System_Object_Finalize((System_Object*)obj);");
            else
                sb.AppendLine($"    {type.Finalizer.CppName}(({type.CppName}*)obj);");
            sb.AppendLine("}");
        }
        if (any) sb.AppendLine();
    }

    /// <summary>
    /// Build a lookup table mapping IL type full names to TypeInfo pointer expressions.
    /// Only includes types with TypeInfo emitted in generated code (non-runtime-provided user types + primitives).
    /// </summary>
    private Dictionary<string, string> BuildTypeInfoExprLookup()
    {
        var lookup = new Dictionary<string, string>();

        // User types that are not runtime-provided
        foreach (var type in _module.Types)
        {
            if (!type.IsRuntimeProvided && !CppNameMapper.IsCompilerGeneratedType(type.ILFullName))
            {
                lookup[type.ILFullName] = $"&{type.CppName}_TypeInfo";
            }
        }

        // Primitive types (array element types)
        foreach (var entry in _module.PrimitiveTypeInfos.Values)
        {
            lookup[entry.ILFullName] = $"&{entry.CppMangledName}_TypeInfo";
        }

        return lookup;
    }

    private void EmitReflectionMetadata(StringBuilder sb, List<IRType> userTypes)
    {
        var typeInfoLookup = BuildTypeInfoExprLookup();
        bool any = false;
        var emittedReflection = new HashSet<string>();

        foreach (var type in userTypes)
        {
            if (type.IsRuntimeProvided || type.IsEnum || type.IsDelegate) continue;
            // Skip runtime exception types — their C++ struct layout is defined by the runtime
            // and doesn't match the generated field layout (e.g., cil2cpp::ArgumentException has no f_paramName)
            if (CppNameMapper.IsRuntimeExceptionType(type.ILFullName)) continue;
            // Deduplicate — BCL proxies may appear multiple times
            if (!emittedReflection.Add(type.CppName)) continue;

            var allFields = type.Fields.Concat(type.StaticFields).ToList();
            var reflectableMethods = type.Methods
                .Where(m => !CppNameMapper.IsCompilerGeneratedType(m.Name))
                .ToList();

            if (allFields.Count == 0 && reflectableMethods.Count == 0) continue;

            if (!any)
            {
                sb.AppendLine("// ===== Reflection Metadata =====");
                any = true;
            }

            // Emit custom attribute arrays for type and fields
            // Type-level attributes
            if (type.CustomAttributes.Count > 0)
                EmitAttributeInfoArray(sb, $"{type.CppName}_custom_attrs", type.CustomAttributes);

            // Field-level attributes
            foreach (var field in allFields)
            {
                if (field.CustomAttributes.Count > 0)
                    EmitAttributeInfoArray(sb, $"{type.CppName}_{field.CppName}_attrs", field.CustomAttributes);
            }

            // Method-level attributes — use index suffix to disambiguate overloaded methods
            for (int mi = 0; mi < reflectableMethods.Count; mi++)
            {
                var method = reflectableMethods[mi];
                if (method.CustomAttributes.Count > 0)
                    EmitAttributeInfoArray(sb, $"{type.CppName}_m{mi}_attrs", method.CustomAttributes);
            }

            // Emit FieldInfo array
            if (allFields.Count > 0)
            {
                sb.AppendLine($"static cil2cpp::FieldInfo {type.CppName}_fields[] = {{");
                foreach (var field in allFields)
                {
                    var fieldTypeExpr = typeInfoLookup.GetValueOrDefault(field.FieldTypeName, "nullptr");
                    // Primitive types (System_Byte = uint8_t, etc.) don't have struct layout;
                    // their m_value field is at offset 0 by definition.
                    var offsetExpr = field.IsStatic || type.IsPrimitiveType
                        ? "0"
                        : $"offsetof({type.CppName}, {field.CppName})";
                    var fieldAttrsExpr = field.CustomAttributes.Count > 0
                        ? $"{type.CppName}_{field.CppName}_attrs" : "nullptr";
                    sb.AppendLine($"    {{ .name = \"{field.Name}\", " +
                        $".declaring_type = &{type.CppName}_TypeInfo, " +
                        $".field_type = {fieldTypeExpr}, " +
                        $".offset = {offsetExpr}, " +
                        $".flags = 0x{field.Attributes:X4}, " +
                        $".custom_attributes = {fieldAttrsExpr}, " +
                        $".custom_attribute_count = {field.CustomAttributes.Count} }},");
                }
                sb.AppendLine("};");
            }

            // Emit MethodInfo parameter type arrays and MethodInfo array
            if (reflectableMethods.Count > 0)
            {
                // First: parameter type arrays for methods that have parameters
                for (int mi = 0; mi < reflectableMethods.Count; mi++)
                {
                    var method = reflectableMethods[mi];
                    if (method.Parameters.Count == 0) continue;
                    var paramTypeExprs = method.Parameters
                        .Select(p => typeInfoLookup.GetValueOrDefault(p.ILTypeName, "nullptr"))
                        .ToList();
                    sb.AppendLine($"static cil2cpp::TypeInfo* {type.CppName}_m{mi}_param_types[] = {{ {string.Join(", ", paramTypeExprs)} }};");
                }

                // Second: MethodInfo array
                sb.AppendLine($"static cil2cpp::MethodInfo {type.CppName}_methods[] = {{");
                for (int mi = 0; mi < reflectableMethods.Count; mi++)
                {
                    var method = reflectableMethods[mi];
                    var returnTypeExpr = typeInfoLookup.GetValueOrDefault(
                        method.ReturnType?.ILFullName ?? "", "nullptr");
                    var paramTypesExpr = method.Parameters.Count > 0
                        ? $"{type.CppName}_m{mi}_param_types" : "nullptr";
                    // Check if the method was actually declared (not filtered by HasUnknownParameterTypes)
                    var hasValidSignature = !method.IsAbstract && !method.IsInternalCall
                        && method.BasicBlocks.Count > 0
                        && !method.Parameters.Any(p => p.CppTypeName.Contains("(") || p.CppTypeName.Contains(")"))
                        && !(method.ReturnTypeCpp?.Contains("(") == true)
                        && _declaredFunctionNames.Contains(method.CppName);
                    var methodPtrExpr = hasValidSignature
                        ? GetTypedMethodPointerCast(method)
                        : "nullptr";
                    var methodAttrsExpr = method.CustomAttributes.Count > 0
                        ? $"{type.CppName}_m{mi}_attrs" : "nullptr";

                    sb.AppendLine($"    {{ .name = \"{method.Name}\", " +
                        $".declaring_type = &{type.CppName}_TypeInfo, " +
                        $".return_type = {returnTypeExpr}, " +
                        $".parameter_types = {paramTypesExpr}, " +
                        $".parameter_count = {method.Parameters.Count}, " +
                        $".method_pointer = {methodPtrExpr}, " +
                        $".flags = 0x{method.Attributes:X4}, " +
                        $".vtable_slot = {method.VTableSlot}, " +
                        $".custom_attributes = {methodAttrsExpr}, " +
                        $".custom_attribute_count = {method.CustomAttributes.Count} }},");
                }
                sb.AppendLine("};");
            }
        }
        if (any) sb.AppendLine();
    }

    /// <summary>
    /// Emit a single CustomAttributeInfo array and its argument arrays.
    /// </summary>
    private void EmitAttributeInfoArray(StringBuilder sb, string arrayName, List<IRCustomAttribute> attrs)
    {
        // First, emit argument arrays (including nested array element arrays)
        for (int i = 0; i < attrs.Count; i++)
        {
            var attr = attrs[i];
            if (attr.ConstructorArgs.Count > 0)
            {
                // Emit nested array element arrays first
                for (int j = 0; j < attr.ConstructorArgs.Count; j++)
                {
                    var arg = attr.ConstructorArgs[j];
                    if (arg.Kind == AttributeArgKind.Array && arg.ArrayElements is { Count: > 0 })
                    {
                        EmitAttributeArgArray(sb, $"{arrayName}_{i}_a{j}_elems", arg.ArrayElements);
                    }
                }

                sb.AppendLine($"static cil2cpp::CustomAttributeArg {arrayName}_{i}_args[] = {{");
                for (int j = 0; j < attr.ConstructorArgs.Count; j++)
                {
                    var arg = attr.ConstructorArgs[j];
                    var valueInit = FormatAttributeArgValue(arg);
                    var arrayInit = FormatAttributeArgArrayFields(arg, $"{arrayName}_{i}_a{j}_elems");
                    sb.AppendLine($"    {{ .type_name = \"{EscapeCppString(arg.TypeName)}\", {valueInit}{arrayInit} }},");
                }
                sb.AppendLine("};");
            }
        }

        // Then emit the CustomAttributeInfo array
        sb.AppendLine($"static cil2cpp::CustomAttributeInfo {arrayName}[] = {{");
        for (int i = 0; i < attrs.Count; i++)
        {
            var attr = attrs[i];
            var argsExpr = attr.ConstructorArgs.Count > 0
                ? $"{arrayName}_{i}_args" : "nullptr";
            sb.AppendLine($"    {{ .attribute_type_name = \"{attr.AttributeTypeName}\", " +
                $".args = {argsExpr}, " +
                $".arg_count = {attr.ConstructorArgs.Count} }},");
        }
        sb.AppendLine("};");
    }

    /// <summary>
    /// Emit a static array of CustomAttributeArg for array-typed attribute arguments.
    /// </summary>
    private void EmitAttributeArgArray(StringBuilder sb, string varName, List<IRAttributeArg> elements)
    {
        sb.AppendLine($"static cil2cpp::CustomAttributeArg {varName}[] = {{");
        foreach (var elem in elements)
        {
            var valueInit = FormatAttributeArgValue(elem);
            sb.AppendLine($"    {{ .type_name = \"{EscapeCppString(elem.TypeName)}\", {valueInit}, .array_elements = nullptr, .array_count = 0 }},");
        }
        sb.AppendLine("};");
    }

    /// <summary>
    /// Format the array_elements and array_count fields for a CustomAttributeArg initializer.
    /// </summary>
    private static string FormatAttributeArgArrayFields(IRAttributeArg arg, string elemVarName)
    {
        if (arg.Kind == AttributeArgKind.Array && arg.ArrayElements is { Count: > 0 })
            return $", .array_elements = {elemVarName}, .array_count = {arg.ArrayElements.Count}";
        return ", .array_elements = nullptr, .array_count = 0";
    }

    /// <summary>
    /// Format a custom attribute argument value for C++ designated initializer.
    /// </summary>
    private static string FormatAttributeArgValue(IRAttributeArg arg)
    {
        if (arg.Value == null && arg.Kind != AttributeArgKind.Array)
            return ".string_val = nullptr";

        return arg.Kind switch
        {
            AttributeArgKind.String => $".string_val = \"{EscapeCppString(arg.Value?.ToString() ?? "")}\"",
            AttributeArgKind.Type => $".string_val = \"{EscapeCppString(arg.Value?.ToString() ?? "")}\"",
            AttributeArgKind.Float when arg.TypeName == "System.Single" => $".float_val = {FormatFloat(arg.Value!)}",
            AttributeArgKind.Float => $".float_val = {FormatDouble(arg.Value!)}",
            AttributeArgKind.Enum => $".int_val = {Convert.ToInt64(arg.Value)}",
            AttributeArgKind.Array => ".int_val = 0",  // value union unused for arrays
            AttributeArgKind.Int when arg.TypeName == "System.Boolean" => $".int_val = {((bool)arg.Value! ? 1 : 0)}",
            AttributeArgKind.Int when arg.TypeName == "System.Char" => $".int_val = {(int)(char)arg.Value!}",
            _ => $".int_val = {Convert.ToInt64(arg.Value)}",
        };
    }

    private static string EscapeCppString(string s) =>
        s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "\\r");

    private static string FormatFloat(object val) =>
        ((float)val).ToString("G9", System.Globalization.CultureInfo.InvariantCulture);

    private static string FormatDouble(object val) =>
        ((double)val).ToString("G17", System.Globalization.CultureInfo.InvariantCulture);

    /// <summary>
    /// Emit extern "C" declarations and managed wrapper functions for P/Invoke methods.
    /// </summary>
    // C stdlib functions that are already declared via standard headers — don't re-declare
    private static readonly HashSet<string> CStdlibFunctions = new()
    {
        "strlen", "strcpy", "strncpy", "strcat", "strncat", "strcmp", "strncmp",
        "memcpy", "memmove", "memset", "memcmp", "malloc", "calloc", "realloc", "free",
        "printf", "sprintf", "snprintf", "fprintf", "puts", "putchar", "getchar",
        "abs", "atoi", "atof", "atol", "rand", "srand", "exit", "abort",
        "qsort", "bsearch", "time", "clock", "sin", "cos", "tan", "sqrt", "pow",
        "fopen", "fclose", "fread", "fwrite", "fseek", "ftell"
    };

    // .NET internal P/Invoke modules — no extern declarations needed
    // (QCall = CLR-internal; libSystem.* = Unix-only native shims; ucrtbase = C runtime)
    private static readonly HashSet<string> InternalPInvokeModules = new(StringComparer.OrdinalIgnoreCase)
    {
        "QCall", "QCall.dll", "libSystem.Native", "libSystem.Globalization.Native",
        "System.Globalization.Native", "System.Native", "System.IO.Compression.Native",
        "System.Security.Cryptography.Native.OpenSsl", "System.Net.Security.Native",
        "ucrtbase", "ucrtbase.dll"
    };

    private void EmitPInvokeDeclarations(StringBuilder sb, List<IRType> userTypes,
        HashSet<string> emittedMethodSignatures)
    {
        // Scan ALL module types (not just deduplicated userTypes) — partial classes like
        // Interop.Kernel32 span multiple assemblies, and deduplication drops P/Invoke methods
        var pinvokeMethods = _module.Types
            .Where(t => !t.IsInterface && !t.IsDelegate && !t.IsRuntimeProvided)
            .SelectMany(t => t.Methods)
            .Where(m => m.IsPInvoke
                        && !string.IsNullOrEmpty(m.PInvokeModule)
                        && !InternalPInvokeModules.Contains(m.PInvokeModule!))
            .ToList();

        if (pinvokeMethods.Count == 0) return;

        // Filter out C stdlib functions and methods with delegate/function pointer parameters
        // (our codegen doesn't produce valid C function pointer types for extern "C" declarations)
        var needsExternDecl = pinvokeMethods
            .Where(m => !CStdlibFunctions.Contains(m.PInvokeEntryPoint ?? m.Name))
            .Where(m => !m.Parameters.Any(p =>
                IsDelegateType(p.ParameterType) || p.CppTypeName.StartsWith("method")))
            .ToList();

        // Track which entry points have valid extern "C" declarations
        // C stdlib functions are always available via standard headers
        var declaredEntryPoints = new HashSet<string>(CStdlibFunctions);
        // Track the declared parameter types for each entry point (for wrapper compatibility check)
        var declaredParamTypes = new Dictionary<string, List<string>>();
        if (needsExternDecl.Count > 0)
        {
            sb.AppendLine("// ===== P/Invoke Declarations =====");
            sb.AppendLine("extern \"C\" {");

            // Deduplicate extern declarations by entry point name only
            // (C doesn't support function overloading — same entry point = same function)
            // Multiple __PInvoke methods may share an entry point but have different param types
            // (e.g., ReadFile with int32_t* vs NativeOverlapped*). We pick the best candidate:
            // prefer methods with only C-primitive params (no struct pointers like NativeOverlapped*).
            var bestExternCandidate = new Dictionary<string, (IRMethod method, int score)>();
            foreach (var method in needsExternDecl)
            {
                var entryPoint = method.PInvokeEntryPoint ?? method.Name;
                var charSet = method.PInvokeCharSet;
                var retType = GetPInvokeNativeType(method.ReturnTypeCpp, null, charSet);
                if (!IsValidExternCType(retType)) continue;

                bool hasInvalidType = false;
                int structPointerCount = 0;
                foreach (var p in method.Parameters)
                {
                    var nt = GetPInvokeNativeType(p.CppTypeName, p.ParameterType, charSet);
                    if (!IsValidExternCType(nt)) { hasInvalidType = true; break; }
                    // Count struct pointers (pointer to non-primitive type)
                    if (nt.EndsWith("*"))
                    {
                        var baseType = nt.TrimEnd('*').Trim();
                        if (!IsCppPrimitiveType(baseType) && baseType != "void")
                            structPointerCount++;
                    }
                }
                if (hasInvalidType) continue;

                // Lower score = better candidate (fewer struct pointers)
                if (!bestExternCandidate.TryGetValue(entryPoint, out var existing) ||
                    structPointerCount < existing.score)
                {
                    bestExternCandidate[entryPoint] = (method, structPointerCount);
                }
            }

            // Emit extern declarations from the best candidates
            foreach (var (entryPoint, (method, _)) in bestExternCandidate.OrderBy(kv => kv.Key))
            {
                var cs = method.PInvokeCharSet;
                var retType = GetPInvokeNativeType(method.ReturnTypeCpp, null, cs);
                var nativeParamTypes = new List<string>();
                foreach (var p in method.Parameters)
                    nativeParamTypes.Add(GetPInvokeNativeType(p.CppTypeName, p.ParameterType, cs));

                var paramParts = new List<string>();
                for (int i = 0; i < method.Parameters.Count; i++)
                    paramParts.Add($"{nativeParamTypes[i]} p{i}");
                var paramDecl = string.Join(", ", paramParts);
                // ECMA-335 II.15.5.1 — Emit calling convention for x86 correctness.
                // On x64, MSVC silently ignores __stdcall/__cdecl/__fastcall.
                var callingConv = method.PInvokeCallingConvention switch
                {
                    PInvokeCallingConvention.StdCall  => "__stdcall ",
                    PInvokeCallingConvention.FastCall => "__fastcall ",
                    PInvokeCallingConvention.ThisCall => "__thiscall ",
                    _ => "" // Cdecl is the default for extern "C", no annotation needed
                };
                sb.AppendLine($"    {retType} {callingConv}{entryPoint}({paramDecl});");
                declaredEntryPoints.Add(entryPoint);
                declaredParamTypes[entryPoint] = nativeParamTypes;
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }

        // Generate managed wrappers (deduplicate by C++ signature)
        // Only generate wrappers for entry points that have a valid extern "C" declaration
        // AND whose parameter types match the declared extern (to avoid type mismatches).
        // Multiple __PInvoke inner methods with the same entry point and compatible types
        // each get their own wrapper (they may have different C++ names).
        sb.AppendLine("// ===== P/Invoke Wrappers =====");
        foreach (var method in pinvokeMethods)
        {
            var entryPoint = method.PInvokeEntryPoint ?? method.Name;
            if (!declaredEntryPoints.Contains(entryPoint)) continue;
            var sig = method.GetCppSignature();
            if (!emittedMethodSignatures.Add(sig)) continue; // skip exact duplicates

            // Check parameter type compatibility with the declared extern
            var wrapperCharSet = method.PInvokeCharSet;
            if (declaredParamTypes.TryGetValue(entryPoint, out var externParamTypes))
            {
                if (method.Parameters.Count != externParamTypes.Count) continue;
                bool compatible = true;
                for (int i = 0; i < method.Parameters.Count; i++)
                {
                    var methodType = GetPInvokeNativeType(method.Parameters[i].CppTypeName,
                        method.Parameters[i].ParameterType, wrapperCharSet);
                    if (methodType != externParamTypes[i]) { compatible = false; break; }
                }
                if (!compatible) continue;
            }
            var retType = method.ReturnTypeCpp;

            sb.AppendLine($"// P/Invoke: {method.PInvokeModule}!{entryPoint}");
            sb.AppendLine($"{sig} {{");

            // Marshal arguments per ECMA-335 II.15.5.4
            var callArgs = new List<string>();
            for (int i = 0; i < method.Parameters.Count; i++)
            {
                var param = method.Parameters[i];
                if (IsStringType(param.CppTypeName))
                {
                    if (wrapperCharSet == IR.PInvokeCharSet.Unicode
                        || wrapperCharSet == IR.PInvokeCharSet.Auto)
                    {
                        // Unicode: pass UTF-16 pointer directly (zero-copy)
                        sb.AppendLine($"    auto __p{i} = {param.CppName} ? cil2cpp::string_get_raw_data({param.CppName}) : (const char16_t*)nullptr;");
                    }
                    else
                    {
                        // Ansi: convert to UTF-8
                        sb.AppendLine($"    auto __p{i} = cil2cpp::string_to_utf8({param.CppName});");
                    }
                    callArgs.Add($"__p{i}");
                }
                else if (IsDelegateType(param.ParameterType))
                {
                    var fnPtrType = GetDelegateFunctionPointerType(param.ParameterType);
                    sb.AppendLine($"    auto __p{i} = reinterpret_cast<{fnPtrType}>(reinterpret_cast<cil2cpp::Delegate*>({param.CppName})->method_ptr);");
                    callArgs.Add($"__p{i}");
                }
                else if (param.CppTypeName is "intptr_t" or "uintptr_t")
                {
                    // ECMA-335: native int → void* for native calls
                    sb.AppendLine($"    auto __p{i} = reinterpret_cast<void*>({param.CppName});");
                    callArgs.Add($"__p{i}");
                }
                else if (param.CppTypeName == "bool")
                {
                    // ECMA-335: Boolean → Win32 BOOL (int32_t)
                    sb.AppendLine($"    auto __p{i} = static_cast<int32_t>({param.CppName});");
                    callArgs.Add($"__p{i}");
                }
                else
                {
                    callArgs.Add(param.CppName);
                }
            }

            var argStr = string.Join(", ", callArgs);

            // SetLastError support (ECMA-335 II.15.5)
            if (method.PInvokeSetLastError)
                sb.AppendLine("    cil2cpp::set_last_pinvoke_error(0);");

            if (retType == "void")
            {
                sb.AppendLine($"    {entryPoint}({argStr});");
                if (method.PInvokeSetLastError)
                    sb.AppendLine("    cil2cpp::capture_last_pinvoke_error();");
            }
            else if (IsStringType(retType))
            {
                sb.AppendLine($"    auto __ret = {entryPoint}({argStr});");
                if (method.PInvokeSetLastError)
                    sb.AppendLine("    cil2cpp::capture_last_pinvoke_error();");
                if (wrapperCharSet == IR.PInvokeCharSet.Unicode
                    || wrapperCharSet == IR.PInvokeCharSet.Auto)
                {
                    // Unicode return: null-terminated wchar_t*/char16_t* → managed String
                    sb.AppendLine("    if (!__ret) return nullptr;");
                    sb.AppendLine("    int32_t __retlen = 0;");
                    sb.AppendLine("    while (reinterpret_cast<const char16_t*>(__ret)[__retlen]) ++__retlen;");
                    sb.AppendLine("    return cil2cpp::string_create_utf16(reinterpret_cast<const cil2cpp::Char*>(__ret), __retlen);");
                }
                else
                {
                    sb.AppendLine("    return cil2cpp::string_literal(__ret);");
                }
            }
            else if (retType is "intptr_t" or "uintptr_t")
            {
                // void* from native → intptr_t/uintptr_t in managed
                sb.AppendLine($"    auto __ret = {entryPoint}({argStr});");
                if (method.PInvokeSetLastError)
                    sb.AppendLine("    cil2cpp::capture_last_pinvoke_error();");
                sb.AppendLine($"    return reinterpret_cast<{retType}>(__ret);");
            }
            else if (retType == "bool")
            {
                // Win32 BOOL (int32_t) → C++ bool
                sb.AppendLine($"    auto __ret = {entryPoint}({argStr});");
                if (method.PInvokeSetLastError)
                    sb.AppendLine("    cil2cpp::capture_last_pinvoke_error();");
                sb.AppendLine("    return __ret != 0;");
            }
            else
            {
                if (method.PInvokeSetLastError)
                {
                    sb.AppendLine($"    auto __ret = {entryPoint}({argStr});");
                    sb.AppendLine("    cil2cpp::capture_last_pinvoke_error();");
                    sb.AppendLine("    return __ret;");
                }
                else
                {
                    sb.AppendLine($"    return {entryPoint}({argStr});");
                }
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }
    }

    /// <summary>
    /// Convert C++ managed type to native P/Invoke type per ECMA-335 II.15.5.4.
    /// </summary>
    private string GetPInvokeNativeType(string cppType, IRType? paramType,
        IR.PInvokeCharSet charSet = IR.PInvokeCharSet.Ansi)
    {
        // String marshaling depends on CharSet (ECMA-335 II.15.5.2)
        if (IsStringType(cppType))
        {
            // TODO: ECMA-335 II.15.5.2 — CharSet.Auto maps to Unicode on Windows, Ansi on Unix.
            // Current: Unicode on all platforms (correct for Windows-only builds).
            // Full fix requires cross-platform build target detection.
            return charSet == IR.PInvokeCharSet.Unicode ? "const char16_t*"
                : charSet == IR.PInvokeCharSet.Auto ? "const char16_t*"
                : "const char*"; // Ansi = UTF-8
        }

        if (cppType == "void") return "void";

        // Delegate → C function pointer
        if (IsDelegateType(paramType)) return GetDelegateFunctionPointerType(paramType!);

        // ECMA-335: native int/uint are pointer-sized → void* in native code
        if (cppType is "intptr_t" or "uintptr_t") return "void*";

        // ECMA-335: System.Boolean marshals as Win32 BOOL (4-byte int)
        if (cppType == "bool") return "int32_t";

        return cppType;
    }

    /// <summary>
    /// Check if a C++ type is valid for an extern "C" declaration.
    /// Accepts primitives, pointers, void, and struct types defined in the compilation unit.
    /// </summary>
    private bool IsValidExternCType(string cppType)
    {
        if (cppType.EndsWith("*")) return true;
        if (IsCppPrimitiveType(cppType)) return true;
        if (cppType is "void" or "int32_t") return true; // int32_t from bool→BOOL marshaling
        // Struct types defined in the compilation unit are valid extern "C" types
        if (_knownStructTypes == null) BuildKnownStructTypes();
        return _knownStructTypes!.Contains(cppType);
    }

    /// <summary>
    /// Check if a type is a delegate type.
    /// </summary>
    private static bool IsDelegateType(IRType? type) =>
        type is { IsDelegate: true };

    /// <summary>
    /// Get the C function pointer type for a delegate type.
    /// Looks up the delegate's Invoke method to determine the signature.
    /// Returns "RetType(*)(ParamTypes...)" syntax.
    /// </summary>
    private static string GetDelegateFunctionPointerType(IRType? delegateType)
    {
        if (delegateType == null) return "void(*)()";

        var invoke = delegateType.Methods.FirstOrDefault(m => m.Name == "Invoke");
        if (invoke == null) return "void(*)()";

        var retType = invoke.ReturnTypeCpp == "void" ? "void"
            : invoke.ReturnTypeCpp == "cil2cpp::String*" ? "const char*"
            : invoke.ReturnTypeCpp;
        var paramTypes = invoke.Parameters
            .Select(p => p.CppTypeName == "cil2cpp::String*" ? "const char*" : p.CppTypeName)
            .ToList();

        return $"{retType}(*)({string.Join(", ", paramTypes)})";
    }

    private static bool IsStringType(string cppType) =>
        cppType is "cil2cpp::String*";
}
