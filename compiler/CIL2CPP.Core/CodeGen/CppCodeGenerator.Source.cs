using System.Text;
using CIL2CPP.Core.IL;
using CIL2CPP.Core.IR;

namespace CIL2CPP.Core.CodeGen;

public partial class CppCodeGenerator
{
    private GeneratedFile GenerateSource()
    {
        var sb = new StringBuilder();

        sb.AppendLine("// Generated by CIL2CPP - DO NOT EDIT");
        sb.AppendLine($"// Source assembly: {_module.Name}");
        if (_config.IsDebug)
        {
            sb.AppendLine("// DEBUG BUILD - contains #line directives and IL offset comments");
        }
        sb.AppendLine();
        sb.AppendLine($"#include \"{_module.Name}.h\"");
        sb.AppendLine();
        sb.AppendLine("#include <cstdio>");
        sb.AppendLine("#include <cmath>");
        sb.AppendLine("#include <cstring>");
        sb.AppendLine("#include <algorithm>");
        sb.AppendLine("#include <limits>");
        sb.AppendLine("#include <atomic>");
        sb.AppendLine();

        // String literals
        if (_module.StringLiterals.Count > 0)
        {
            sb.AppendLine("// ===== String Literals =====");
            foreach (var (value, literal) in _module.StringLiterals)
            {
                // Escape string for C++
                var escaped = EscapeString(value);
                sb.AppendLine($"static cil2cpp::String* {literal.Id} = nullptr;");
            }
            sb.AppendLine();

            sb.AppendLine("void __init_string_literals() {");
            foreach (var (value, literal) in _module.StringLiterals)
            {
                var escaped = EscapeString(value);
                sb.AppendLine($"    {literal.Id} = cil2cpp::string_literal(\"{escaped}\");");
            }
            sb.AppendLine("}");
            sb.AppendLine();
        }

        // Array initializer data blobs
        if (_module.ArrayInitDataBlobs.Count > 0)
        {
            sb.AppendLine("// ===== Array Initializer Data =====");
            foreach (var blob in _module.ArrayInitDataBlobs)
            {
                var bytes = string.Join(", ", blob.Data.Select(b => $"0x{b:X2}"));
                sb.AppendLine($"static const unsigned char {blob.Id}[] = {{ {bytes} }};");
            }
            sb.AppendLine();
        }

        // Filter out compiler-generated types, open generic types, and deduplicate by CppName
        var seenTypeNames = new HashSet<string>();
        var userTypes = _module.Types
            .Where(t => !CppNameMapper.IsCompilerGeneratedType(t.ILFullName))
            .Where(t => !HasUnresolvedGenericParams(t))
            .Where(t => seenTypeNames.Add(t.CppName)) // Deduplicate by CppName
            .ToList();

        // Static field storage (include RuntimeProvided types — BCL code uses their statics)
        foreach (var type in userTypes)
        {
            if (type.IsEnum || type.IsDelegate) continue;
            if (type.StaticFields.Count > 0)
            {
                sb.AppendLine($"{type.CppName}_Statics {type.CppName}_statics = {{}};");
            }
        }
        if (userTypes.Any(t => !t.IsEnum && !t.IsDelegate && t.StaticFields.Count > 0))
        {
            sb.AppendLine();
        }

        // Primitive type TypeInfo definitions (for array element types)
        // Runtime-provided reference types get aliases to runtime TypeInfo instead of new definitions.
        if (_module.PrimitiveTypeInfos.Count > 0)
        {
            sb.AppendLine("// ===== Primitive Type Info (array element types) =====");
            foreach (var entry in _module.PrimitiveTypeInfos.Values)
            {
                // Runtime-provided reference types: alias to runtime's TypeInfo (e.g., cil2cpp::System::Object_TypeInfo)
                var runtimeAlias = GetRuntimeTypeInfoAlias(entry.ILFullName);
                if (runtimeAlias != null)
                {
                    sb.AppendLine($"cil2cpp::TypeInfo& {entry.CppMangledName}_TypeInfo = {runtimeAlias};");
                    continue;
                }

                sb.AppendLine($"cil2cpp::TypeInfo {entry.CppMangledName}_TypeInfo = {{");
                sb.AppendLine($"    .name = \"{entry.ILFullName.Split('.').Last()}\",");
                sb.AppendLine($"    .namespace_name = \"{entry.ILFullName[..entry.ILFullName.LastIndexOf('.')]}\",");
                sb.AppendLine($"    .full_name = \"{entry.ILFullName}\",");
                sb.AppendLine($"    .base_type = nullptr,");
                sb.AppendLine($"    .interfaces = nullptr,");
                sb.AppendLine($"    .interface_count = 0,");
                sb.AppendLine($"    .instance_size = sizeof({entry.CppTypeName}),");
                sb.AppendLine($"    .element_size = sizeof({entry.CppTypeName}),");
                // Primitive types get both ValueType and Primitive flags (ECMA-335)
                sb.AppendLine($"    .flags = cil2cpp::TypeFlags::ValueType | cil2cpp::TypeFlags::Primitive,");
                sb.AppendLine($"    .vtable = nullptr,");
                sb.AppendLine($"    .fields = nullptr,");
                sb.AppendLine($"    .field_count = 0,");
                sb.AppendLine($"    .methods = nullptr,");
                sb.AppendLine($"    .method_count = 0,");
                sb.AppendLine($"    .default_ctor = nullptr,");
                sb.AppendLine($"    .finalizer = nullptr,");
                sb.AppendLine($"    .interface_vtables = nullptr,");
                sb.AppendLine($"    .interface_vtable_count = 0,");
                sb.AppendLine($"    .custom_attributes = nullptr,");
                sb.AppendLine($"    .custom_attribute_count = 0,");
                sb.AppendLine($"}};");
            }
            sb.AppendLine();
        }

        // Exception TypeInfo reference aliases — define references to runtime-declared TypeInfos
        // so that generated catch/cast code can use mangled names (System_Exception_TypeInfo)
        sb.AppendLine("// ===== Exception TypeInfo Aliases =====");
        foreach (var (mangledName, runtimeTypeInfoName) in GetExceptionTypeInfoAliases())
        {
            sb.AppendLine($"cil2cpp::TypeInfo& {mangledName}_TypeInfo = {runtimeTypeInfoName};");
        }
        sb.AppendLine();

        // Ensure System_Object_TypeInfo and System_String_TypeInfo exist at global scope
        // (normally defined by PrimitiveTypeInfos; alias as fallback if missing)
        var needsObjectAlias = !_module.PrimitiveTypeInfos.Values.Any(e => e.ILFullName == "System.Object");
        var needsStringAlias = !_module.PrimitiveTypeInfos.Values.Any(e => e.ILFullName == "System.String");
        if (needsObjectAlias || needsStringAlias)
        {
            sb.AppendLine("// ===== Runtime TypeInfo Aliases =====");
            if (needsObjectAlias)
                sb.AppendLine("static cil2cpp::TypeInfo& System_Object_TypeInfo = cil2cpp::System_Object_TypeInfo;");
            if (needsStringAlias)
                sb.AppendLine("static cil2cpp::TypeInfo& System_String_TypeInfo = cil2cpp::System_String_TypeInfo;");
            sb.AppendLine();
        }

        // Stub TypeInfos for runtime-provided base types not declared in the runtime library
        // These are referenced as .base_type in TypeInfo initialization for value types, enums, delegates
        sb.AppendLine("// ===== Runtime Base Type TypeInfo Stubs =====");
        foreach (var (mangledName, ilName) in GetRuntimeBaseTypeInfoStubs())
        {
            sb.AppendLine($"static cil2cpp::TypeInfo {mangledName}_TypeInfo = {{ " +
                $".name = \"{ilName.Split('.').Last()}\", " +
                $".namespace_name = \"{string.Join(".", ilName.Split('.').SkipLast(1))}\", " +
                $".full_name = \"{ilName}\", " +
                $".base_type = &System_Object_TypeInfo }};");
        }
        sb.AppendLine();

        // VTable data
        EmitVTableData(sb, userTypes);

        // Interface data
        EmitInterfaceData(sb, userTypes);

        // Finalizer wrappers
        EmitFinalizerWrappers(sb, userTypes);

        // Reflection metadata (FieldInfo/MethodInfo arrays)
        EmitReflectionMetadata(sb, userTypes);

        // Generic variance data arrays (for variance-aware type checking)
        EmitGenericVarianceData(sb, userTypes);

        // Type info definitions (skip runtime-provided types — already defined in runtime)
        sb.AppendLine("// ===== Type Info =====");
        var emittedTypeInfo = new HashSet<string>();
        // Collect types that already have TypeInfo definitions (primitives, exceptions, base type stubs)
        foreach (var entry in _module.PrimitiveTypeInfos.Values)
            emittedTypeInfo.Add(entry.CppMangledName);
        foreach (var (mangledName, _) in GetExceptionTypeInfoAliases())
            emittedTypeInfo.Add(mangledName);
        foreach (var (mangledName, _) in GetRuntimeBaseTypeInfoStubs())
            emittedTypeInfo.Add(mangledName);
        foreach (var type in userTypes)
        {
            if (emittedTypeInfo.Contains(type.CppName)) continue;
            if (!IsValidCppIdentifier(type.CppName)) continue;
            if (!emittedTypeInfo.Add(type.CppName)) continue;
            if (type.IsRuntimeProvided && IRBuilder.CoreRuntimeTypes.Contains(type.ILFullName))
            {
                // Emit minimal TypeInfo stub for core runtime types (Object, String, etc.)
                // (other types may reference these as base_type)
                var baseName = type.BaseType != null && emittedTypeInfo.Contains(type.BaseType.CppName)
                    ? $"&{type.BaseType.CppName}_TypeInfo" : "&System_Object_TypeInfo";
                sb.AppendLine($"cil2cpp::TypeInfo {type.CppName}_TypeInfo = {{ .name = \"{type.Name}\", " +
                    $".namespace_name = \"{type.Namespace}\", .full_name = \"{type.ILFullName}\", " +
                    $".base_type = {baseName} }};");
                continue;
            }
            if (type.IsRuntimeProvided && !IRBuilder.CoreRuntimeTypes.Contains(type.ILFullName))
            {
                // Non-core runtime-provided types (Task, Thread, etc.): struct layout from runtime,
                // but methods compiled from BCL IL — need full TypeInfo with vtable
                GenerateTypeInfo(sb, type);
                continue;
            }
            GenerateTypeInfo(sb, type);
        }
        sb.AppendLine();

        // Static constructor guards — collect all types that SHOULD have ensure_cctor
        // (matches the header declaration loop in GenerateHeader)
        var needsEnsureCctor = new HashSet<string>();
        foreach (var type in userTypes)
        {
            if (type.HasCctor)
                needsEnsureCctor.Add(type.CppName);
        }
        var emittedEnsureCctor = new HashSet<string>();
        foreach (var type in userTypes)
        {
            if (type.HasCctor)
            {
                var cctorMethod = type.Methods.FirstOrDefault(m => m.IsStaticConstructor);
                if (cctorMethod != null)
                {
                    // For RuntimeProvided types: emit cctor if the method has a compiled body
                    if (type.IsRuntimeProvided && cctorMethod.BasicBlocks.Count == 0)
                    {
                        sb.AppendLine($"void {type.CppName}_ensure_cctor() {{ }}");
                        emittedEnsureCctor.Add(type.CppName);
                        continue;
                    }
                    sb.AppendLine($"static bool {type.CppName}_cctor_called = false;");
                    sb.AppendLine($"void {type.CppName}_ensure_cctor() {{");
                    sb.AppendLine($"    if (!{type.CppName}_cctor_called) {{");
                    sb.AppendLine($"        {type.CppName}_cctor_called = true;");
                    sb.AppendLine($"        {cctorMethod.CppName}();");
                    sb.AppendLine($"    }}");
                    sb.AppendLine($"}}");
                    emittedEnsureCctor.Add(type.CppName);
                    sb.AppendLine();
                }
                else
                {
                    sb.AppendLine($"void {type.CppName}_ensure_cctor() {{ }}");
                    emittedEnsureCctor.Add(type.CppName);
                }
            }
        }
        // Safety net: emit no-op for any ensure_cctor declared in the header but not generated.
        // This handles cases where CppName dedup in source drops a type with HasCctor.
        foreach (var type in _module.Types)
        {
            if (type.HasCctor && !emittedEnsureCctor.Contains(type.CppName))
            {
                sb.AppendLine($"void {type.CppName}_ensure_cctor() {{ }}");
                emittedEnsureCctor.Add(type.CppName);
            }
        }

        // P/Invoke extern declarations and wrappers
        var emittedMethodSignatures = new HashSet<string>();
        EmitPInvokeDeclarations(sb, userTypes, emittedMethodSignatures);

        // Build known type set (includes all defined types, aliases, enums, forward-declared)
        var knownTypeNames = new HashSet<string>();
        foreach (var t in userTypes)
            knownTypeNames.Add(t.CppName);
        foreach (var ilName in IRBuilder.RuntimeProvidedTypes)
            knownTypeNames.Add(CppNameMapper.MangleTypeName(ilName));
        foreach (var (mangled, _) in GetRuntimeProvidedTypeAliases())
            knownTypeNames.Add(mangled);

        // Method implementations (skip delegates and InternalCall methods)
        // RuntimeProvided types: only emit methods that have compiled IL bodies
        sb.AppendLine("// ===== Method Implementations =====");
        foreach (var type in userTypes)
        {
            if (type.IsDelegate) continue;

            // For interfaces, only emit DIM method bodies (non-abstract with converted bodies)
            if (type.IsInterface)
            {
                foreach (var method in type.Methods)
                {
                    if (method.IsAbstract || method.BasicBlocks.Count == 0) continue;
                    if (HasUnknownParameterTypes(method, knownTypeNames)) continue;
                    if (HasUnknownBodyReferences(method, knownTypeNames)) continue;
                    if (CallsUndeclaredOrMismatchedFunctions(method)) continue;
                    if (HasKnownBrokenPatterns(method, knownTypeNames)) continue;
                    if (!emittedMethodSignatures.Add(method.GetCppSignature())) continue;
                    // Trial render for DIM methods too
                    var dimTrialSb = new StringBuilder();
                    GenerateMethodImpl(dimTrialSb, method);
                    var dimRendered = dimTrialSb.ToString();
                    if (RenderedBodyHasErrors(dimRendered, method, knownTypeNames))
                    {
                        GenerateStubForMethod(sb, method);
                        continue;
                    }
                    sb.Append(dimRendered);
                }
                continue;
            }

            // All types (user + BCL) compile from IL — Unity IL2CPP model
            foreach (var method in type.Methods)
            {
                if (method.IsAbstract || method.IsInternalCall || method.IsPInvoke) continue;
                if (method.BasicBlocks.Count == 0) continue;
                if (method.HasICallMapping) continue;
                // Core runtime types (Object, String, Array, etc.): only emit static methods.
                // Non-core RuntimeProvided types (Task, Thread, CancellationToken) emit all methods.
                if (type.IsRuntimeProvided && !method.IsStatic
                    && IRBuilder.CoreRuntimeTypes.Contains(type.ILFullName)) continue;
                if (HasUnknownParameterTypes(method, knownTypeNames)) continue;
                if (HasUnknownBodyReferences(method, knownTypeNames)) continue;
                if (CallsUndeclaredOrMismatchedFunctions(method)) continue;
                if (HasKnownBrokenPatterns(method, knownTypeNames)) continue;
                if (!emittedMethodSignatures.Add(method.GetCppSignature())) continue;

                // Check known stub implementations before trial render
                var knownBody = GetKnownStubBody(method.CppName);
                if (knownBody != null && IsStubBody(method))
                {
                    sb.AppendLine($"{method.GetCppSignature()} {{");
                    sb.AppendLine(knownBody);
                    sb.AppendLine("}");
                    continue;
                }

                // Trial render: render to temp buffer, check for error patterns,
                // emit stub if errors found (avoids C++ compilation failures)
                var trialSb = new StringBuilder();
                GenerateMethodImpl(trialSb, method);
                var rendered = trialSb.ToString();
                if (RenderedBodyHasErrors(rendered, method, knownTypeNames))
                {
                    GenerateStubForMethod(sb, method);
                    continue;
                }
                sb.Append(rendered);
            }
        }

        // Generate stub implementations for methods on RuntimeProvided or unreachable types.
        GenerateMissingMethodStubImpls(sb, emittedMethodSignatures, userTypes);

        return new GeneratedFile
        {
            FileName = $"{_module.Name}.cpp",
            Content = sb.ToString()
        };
    }

    /// <summary>
    /// Generate stub implementations for methods on RuntimeProvided types that are called
    /// but don't have generated bodies. Only generates for methods with known, clean signatures.
    /// </summary>
    private void GenerateMissingMethodStubImpls(StringBuilder sb, HashSet<string> emittedSignatures,
        List<IRType> userTypes)
    {
        // Build lookup: method CppName → list of IRMethods (multiple overloads possible)
        var methodLookup = new Dictionary<string, List<IRMethod>>();
        foreach (var type in _module.Types)
        {
            foreach (var method in type.Methods)
            {
                if (!methodLookup.TryGetValue(method.CppName, out var list))
                {
                    list = new List<IRMethod>();
                    methodLookup[method.CppName] = list;
                }
                list.Add(method);
            }
        }

        // Generate stubs for ALL declared-but-not-defined functions.
        // This covers IRCall references, VTable entries, static constructor guards,
        // delegate function pointers, etc.
        var stubs = new List<IRMethod>();
        foreach (var funcName in _declaredFunctionNames)
        {
            if (!methodLookup.TryGetValue(funcName, out var methods)) continue;
            foreach (var irMethod in methods)
            {
                var sig = irMethod.GetCppSignature();
                if (emittedSignatures.Contains(sig)) continue;
                stubs.Add(irMethod);
            }
        }

        if (stubs.Count == 0) return;

        sb.AppendLine();
        sb.AppendLine("// ===== Stub Implementations (RuntimeProvided/unreachable type methods) =====");

        // Collect all by-value types from stub signatures that are forward-declared only.
        // Emit empty struct definitions to make them "complete" types for C++.
        var opaqueTypes = new HashSet<string>();
        foreach (var method in stubs)
        {
            var typesToCheck = method.Parameters.Select(p => p.CppTypeName).ToList();
            if (!string.IsNullOrEmpty(method.ReturnTypeCpp) && method.ReturnTypeCpp != "void")
                typesToCheck.Add(method.ReturnTypeCpp);
            foreach (var typeName in typesToCheck)
            {
                if (typeName.EndsWith("*")) continue; // pointer types don't need full definition
                var baseType = typeName.Trim();
                if (string.IsNullOrEmpty(baseType)) continue;
                if (IsCppPrimitiveType(baseType)) continue;
                if (baseType.StartsWith("cil2cpp::")) continue;
                if (_emittedStructDefs.Contains(baseType)) continue;
                if (!IsValidCppIdentifier(baseType)) continue;
                opaqueTypes.Add(baseType);
            }
        }
        if (opaqueTypes.Count > 0)
        {
            sb.AppendLine("// Opaque type definitions for forward-declared-only types used by value in stubs");
            foreach (var typeName in opaqueTypes.OrderBy(n => n))
                sb.AppendLine($"struct {typeName} {{ }}; // opaque — forward-declared only");
            sb.AppendLine();
        }

        // Track emitted function overloads to avoid return-type-only overloads (C++ doesn't support them).
        // Key: "FuncName(type1,type2,...)" — function name + param TYPES only (no names).
        // Pre-populate from already-emitted method signatures (main body section).
        var emittedOverloads = new HashSet<string>();
        // Helper: extract "FuncName(type1, type2)" from a method
        string GetOverloadKey(IRMethod m) =>
            $"{m.CppName}({string.Join(", ", m.Parameters.Select(p => p.CppTypeName))})";
        // Pre-populate from methods that already have emitted signatures
        foreach (var type in _module.Types)
        {
            foreach (var method in type.Methods)
            {
                if (emittedSignatures.Contains(method.GetCppSignature()))
                    emittedOverloads.Add(GetOverloadKey(method));
            }
        }
        foreach (var method in stubs.OrderBy(m => m.CppName))
        {
            var sig = method.GetCppSignature();
            if (!emittedSignatures.Add(sig)) continue;

            // Skip if same function name + param types already emitted (return-type-only overload)
            if (!emittedOverloads.Add(GetOverloadKey(method))) continue;

            // Skip stubs with unresolved generic params (bare name without underscore: TKey, TOther, etc.)
            bool hasProblematicType = false;
            var stubTypesToCheck = method.Parameters.Select(p => p.CppTypeName).ToList();
            if (!string.IsNullOrEmpty(method.ReturnTypeCpp) && method.ReturnTypeCpp != "void")
                stubTypesToCheck.Add(method.ReturnTypeCpp);
            foreach (var typeName in stubTypesToCheck)
            {
                var baseType = typeName.TrimEnd('*').Trim();
                if (string.IsNullOrEmpty(baseType)) continue;
                if (!baseType.Contains('_') && !baseType.StartsWith("cil2cpp::") &&
                    !IsCppPrimitiveType(baseType))
                {
                    hasProblematicType = true;
                    break;
                }
            }
            if (hasProblematicType) continue;

            var knownBody = GetKnownStubBody(method.CppName);
            if (knownBody != null)
            {
                sb.AppendLine($"{sig} {{");
                sb.AppendLine(knownBody);
                sb.AppendLine("}");
            }
            else
            {
                sb.AppendLine($"{sig} {{");
                if (method.ReturnTypeCpp == "void" || string.IsNullOrEmpty(method.ReturnTypeCpp))
                    sb.AppendLine("    // TODO: compile from IL");
                else if (method.ReturnTypeCpp.EndsWith("*"))
                    sb.AppendLine("    return nullptr; // TODO: compile from IL");
                else if (method.ReturnTypeCpp == "bool")
                    sb.AppendLine("    return false; // TODO: compile from IL");
                else
                    sb.AppendLine("    return {}; // TODO: compile from IL");
                sb.AppendLine("}");
            }
        }
    }

    /// <summary>
    /// Emit a stub body for a method whose trial-rendered C++ body contained error patterns.
    /// The stub prevents compilation errors while still providing a callable function.
    /// </summary>
    private static void GenerateStubForMethod(StringBuilder sb, IRMethod method)
    {
        var knownBody = GetKnownStubBody(method.CppName);
        if (knownBody != null)
        {
            sb.AppendLine($"{method.GetCppSignature()} {{");
            sb.AppendLine(knownBody);
            sb.AppendLine("}");
            return;
        }
        sb.AppendLine($"// {method.DeclaringType?.ILFullName}::{method.Name} (stub — body has codegen errors)");
        sb.AppendLine($"{method.GetCppSignature()} {{");
        if (method.ReturnTypeCpp == "void" || string.IsNullOrEmpty(method.ReturnTypeCpp))
            sb.AppendLine("    // TODO: fix codegen for this method");
        else if (method.ReturnTypeCpp.EndsWith("*"))
            sb.AppendLine("    return nullptr; // TODO: fix codegen for this method");
        else if (method.ReturnTypeCpp == "bool")
            sb.AppendLine("    return false; // TODO: fix codegen for this method");
        else
            sb.AppendLine("    return {}; // TODO: fix codegen for this method");
        sb.AppendLine("}");
    }

    private void GenerateTypeInfo(StringBuilder sb, IRType type)
    {
        // For enum/delegate types skipped by EmitReflectionMetadata, emit type-level custom attrs
        if ((type.IsEnum || type.IsDelegate) && type.CustomAttributes.Count > 0)
        {
            EmitAttributeInfoArray(sb, $"{type.CppName}_custom_attrs", type.CustomAttributes);
        }

        var baseName = type.BaseType != null ? $"&{type.BaseType.CppName}_TypeInfo" : "nullptr";

        // Interfaces array (EmitInterfaceData skips interfaces themselves, so null for them)
        var interfacesExpr = (!type.IsInterface && type.Interfaces.Count > 0) ? $"{type.CppName}_interfaces" : "nullptr";
        var interfaceCount = type.IsInterface ? 0 : type.Interfaces.Count;

        // VTable (delegates have no vtable)
        var vtableExpr = (!type.IsInterface && !type.IsDelegate && type.VTable.Count > 0) ? $"&{type.CppName}_VTable" : "nullptr";

        // Interface vtables (also skipped for interfaces)
        var ifaceVtablesExpr = (!type.IsInterface && type.InterfaceImpls.Count > 0) ? $"{type.CppName}_interface_vtables" : "nullptr";
        var ifaceVtableCount = type.IsInterface ? 0 : type.InterfaceImpls.Count;

        // Finalizer
        var finalizerExpr = (type.Finalizer != null && !type.IsRuntimeProvided) ? $"{type.CppName}_finalizer_wrapper" : "nullptr";

        // Instance size (interfaces have no struct)
        var instanceSize = type.IsInterface ? "0" : $"sizeof({type.CppName})";

        // Flags
        var flagParts = new List<string>();
        if (type.IsValueType) flagParts.Add("cil2cpp::TypeFlags::ValueType");
        if (type.IsInterface) flagParts.Add("cil2cpp::TypeFlags::Interface");
        if (type.IsAbstract) flagParts.Add("cil2cpp::TypeFlags::Abstract");
        if (type.IsSealed) flagParts.Add("cil2cpp::TypeFlags::Sealed");
        if (type.IsEnum) flagParts.Add("cil2cpp::TypeFlags::Enum");
        var flagsStr = flagParts.Count > 0 ? string.Join(" | ", flagParts) : "cil2cpp::TypeFlags::None";

        sb.AppendLine($"cil2cpp::TypeInfo {type.CppName}_TypeInfo = {{");
        sb.AppendLine($"    .name = \"{type.Name}\",");
        sb.AppendLine($"    .namespace_name = \"{type.Namespace}\",");
        sb.AppendLine($"    .full_name = \"{type.ILFullName}\",");
        sb.AppendLine($"    .base_type = {baseName},");
        sb.AppendLine($"    .interfaces = {interfacesExpr},");
        sb.AppendLine($"    .interface_count = {interfaceCount},");
        sb.AppendLine($"    .instance_size = {instanceSize},");
        sb.AppendLine($"    .element_size = 0,");
        sb.AppendLine($"    .flags = {flagsStr},");
        sb.AppendLine($"    .vtable = {vtableExpr},");
        // Reflection metadata: FieldInfo/MethodInfo arrays
        // Enums and delegates skip EmitReflectionMetadata, so always use nullptr for them
        var allFields = type.Fields.Concat(type.StaticFields).ToList();
        var reflectableMethods = type.Methods.Where(m => !CppNameMapper.IsCompilerGeneratedType(m.Name)).ToList();
        var skipReflection = type.IsEnum || type.IsDelegate || type.IsRuntimeProvided
            || CppNameMapper.IsRuntimeExceptionType(type.ILFullName);
        var fieldsExpr = (!skipReflection && allFields.Count > 0) ? $"{type.CppName}_fields" : "nullptr";
        var methodsExpr = (!skipReflection && reflectableMethods.Count > 0) ? $"{type.CppName}_methods" : "nullptr";
        if (skipReflection) { allFields = new(); reflectableMethods = new(); }
        sb.AppendLine($"    .fields = {fieldsExpr},");
        sb.AppendLine($"    .field_count = {allFields.Count},");
        sb.AppendLine($"    .methods = {methodsExpr},");
        sb.AppendLine($"    .method_count = {reflectableMethods.Count},");
        sb.AppendLine($"    .default_ctor = nullptr,");
        sb.AppendLine($"    .finalizer = {finalizerExpr},");
        sb.AppendLine($"    .interface_vtables = {ifaceVtablesExpr},");
        sb.AppendLine($"    .interface_vtable_count = {ifaceVtableCount},");
        // Custom attributes
        var typeAttrsExpr = (!skipReflection && type.CustomAttributes.Count > 0)
            ? $"{type.CppName}_custom_attrs" : "nullptr";
        var typeAttrCount = skipReflection ? 0 : type.CustomAttributes.Count;
        sb.AppendLine($"    .custom_attributes = {typeAttrsExpr},");
        sb.AppendLine($"    .custom_attribute_count = {typeAttrCount},");
        // Generic variance data (must match EmitGenericVarianceData filter)
        var typeInfoLookup = BuildTypeInfoExprLookup();
        var hasGenericArgs = type.IsGenericInstance && type.GenericArguments.Count > 0
                             && type.GenericParameterVariances.Count > 0
                             && type.GenericArguments.All(arg => typeInfoLookup.ContainsKey(arg));
        var genArgsExpr = hasGenericArgs ? $"{type.CppName}_generic_args" : "nullptr";
        var genVarExpr = hasGenericArgs ? $"{type.CppName}_generic_variances" : "nullptr";
        var genCount = hasGenericArgs ? type.GenericArguments.Count : 0;
        var genDefName = type.GenericDefinitionCppName != null
            ? $"\"{type.GenericDefinitionCppName}\"" : "nullptr";
        sb.AppendLine($"    .generic_arguments = {genArgsExpr},");
        sb.AppendLine($"    .generic_variances = {genVarExpr},");
        sb.AppendLine($"    .generic_argument_count = {genCount},");
        sb.AppendLine($"    .generic_definition_name = {genDefName},");
        sb.AppendLine("};");
    }

    private void GenerateMethodImpl(StringBuilder sb, IRMethod method)
    {
        sb.AppendLine($"// {method.DeclaringType?.ILFullName}::{method.Name}");
        sb.AppendLine($"{method.GetCppSignature()} {{");

        // Declare local variables
        foreach (var local in method.Locals)
        {
            var defaultVal = CppNameMapper.GetDefaultValue(local.CppTypeName);
            sb.AppendLine($"    {local.CppTypeName} {local.CppName} = {defaultVal};");
        }

        // Collect temp variables that need auto declarations
        var declaredTemps = new HashSet<string>();
        string? lastLineDirective = null;

        // Check if method has any labels (branch targets)
        var allInstructions = method.BasicBlocks.SelectMany(b => b.Instructions).ToList();
        bool hasLabels = allInstructions.Any(i => i is IRLabel);

        // Pre-declare temp variables used across label scopes
        // (variables declared inside one { } label scope can't be used in another)
        if (hasLabels)
        {
            var crossScopeVars = FindCrossScopeVariables(allInstructions);
            // Determine actual types from IRCall.ResultTypeCpp for each temp var
            var tempVarTypes = DetermineTempVarTypes(allInstructions);
            foreach (var varName in crossScopeVars)
            {
                var typeName = tempVarTypes.GetValueOrDefault(varName);
                if (typeName == null)
                {
                    // Type unknown: default to Object* (most cross-scope temps are pointer types)
                    sb.AppendLine($"    cil2cpp::Object* {varName} = nullptr;");
                }
                else
                {
                    var initVal = typeName.EndsWith("*") ? "nullptr" : "{}";
                    sb.AppendLine($"    {typeName} {varName} = {initVal};");
                }
                declaredTemps.Add(varName);
            }
        }
        bool inLabelScope = false;
        bool gotoScopeOpen = false;

        // Emit basic blocks
        foreach (var block in method.BasicBlocks)
        {
            foreach (var instr in block.Instructions)
            {
                // When entering a label, close goto scope and label scope
                if (hasLabels && instr is IRLabel)
                {
                    if (gotoScopeOpen)
                    {
                        sb.AppendLine("    }");
                        gotoScopeOpen = false;
                    }
                    if (inLabelScope)
                        sb.AppendLine("    }");
                    // Emit the label at function scope
                    sb.AppendLine($"    {instr.ToCpp()}");
                    sb.AppendLine("    {");
                    inLabelScope = true;
                    continue;
                }

                // Exception handling instructions must be at function scope
                // (CIL2CPP_TRY/CATCH/FINALLY/END_TRY macros expand to { if / } else if / } })
                if (instr is IRTryBegin or IRCatchBegin or IRFinallyBegin or IRFilterBegin or IRTryEnd)
                {
                    if (gotoScopeOpen)
                    {
                        sb.AppendLine("    }");
                        gotoScopeOpen = false;
                    }
                    if (inLabelScope)
                    {
                        sb.AppendLine("    }");
                        inLabelScope = false;
                    }
                }

                // Emit IL offset comment in Debug mode
                if (_config.EmitILOffsetComments && instr.DebugInfo != null && instr.DebugInfo.ILOffset >= 0
                    && instr is not IRComment && instr is not IRLabel)
                {
                    sb.AppendLine($"    /* IL_{instr.DebugInfo.ILOffset:X4} */");
                }

                // Emit #line directive in Debug mode (when source info is available)
                if (_config.EmitLineDirectives && instr.DebugInfo != null
                    && instr.DebugInfo.Line > 0
                    && !string.IsNullOrEmpty(instr.DebugInfo.FilePath)
                    && instr is not IRComment && instr is not IRLabel)
                {
                    // Normalize path separators for C++ (use forward slashes)
                    var filePath = instr.DebugInfo.FilePath.Replace("\\", "/");
                    var directive = $"#line {instr.DebugInfo.Line} \"{filePath}\"";

                    // Only emit if different from the last directive
                    if (directive != lastLineDirective)
                    {
                        sb.AppendLine($"    {directive}");
                        lastLineDirective = directive;
                    }
                }

                var code = instr.ToCpp();

                // For instructions that assign to temp vars, add 'auto' on first use
                code = AddAutoDeclarations(code, declaredTemps);

                var indent = (inLabelScope || gotoScopeOpen) ? "        " : "    ";
                sb.AppendLine($"{indent}{code}");

                // After a conditional/unconditional branch in the outer scope,
                // open a scope to prevent goto from crossing auto declarations (C++ C2362)
                if (hasLabels && !inLabelScope && !gotoScopeOpen
                    && (instr is IRConditionalBranch || instr is IRBranch))
                {
                    sb.AppendLine("    {");
                    gotoScopeOpen = true;
                }
            }
        }

        // Close last goto scope
        if (gotoScopeOpen)
            sb.AppendLine("    }");
        // Close last label scope
        if (inLabelScope)
            sb.AppendLine("    }");

        // In C++, there is no "#line default" like in C#.
        // We simply stop emitting #line directives; the compiler continues
        // using the last #line mapping until it encounters a new one.

        // If method doesn't end with return, add one
        var lastInstr = method.BasicBlocks
            .SelectMany(b => b.Instructions)
            .LastOrDefault();
        if (lastInstr is not IRReturn)
        {
            if (method.ReturnTypeCpp == "void")
                sb.AppendLine("    return;");
        }

        sb.AppendLine("}");
        sb.AppendLine();
    }

    /// <summary>
    /// Find temp variables that are referenced across multiple label scopes.
    /// These must be pre-declared at function scope to avoid C++ scoping issues.
    /// </summary>
    private static HashSet<string> FindCrossScopeVariables(List<IRInstruction> instructions)
    {
        var result = new HashSet<string>();
        // Track which scope each variable is first assigned/used in
        // scope 0 = function scope, incrementing for each IRLabel
        int currentScope = 0;
        var varFirstScope = new Dictionary<string, int>();

        foreach (var instr in instructions)
        {
            if (instr is IRLabel)
            {
                currentScope++;
                continue;
            }

            var code = instr.ToCpp();
            // Find all __tN references in the code
            for (int i = 0; i < code.Length - 3; i++)
            {
                if (code[i] == '_' && code[i + 1] == '_' && code[i + 2] == 't'
                    && i + 3 < code.Length && char.IsDigit(code[i + 3]))
                {
                    // Check we're not inside __this, __type_info, etc.
                    if (i > 0 && char.IsLetterOrDigit(code[i - 1])) continue;

                    // Extract full variable name __tN
                    int end = i + 3;
                    while (end < code.Length && char.IsDigit(code[end])) end++;
                    // Make sure it's not followed by more identifier chars
                    if (end < code.Length && (char.IsLetter(code[end]) || code[end] == '_')) continue;

                    var varName = code[i..end];
                    if (varFirstScope.TryGetValue(varName, out var firstScope))
                    {
                        if (firstScope != currentScope)
                            result.Add(varName);
                    }
                    else
                    {
                        varFirstScope[varName] = currentScope;
                    }
                }
            }
        }
        return result;
    }

    /// <summary>
    /// Determine the C++ type of each __tN temp variable by scanning all IR instructions.
    /// Returns a map from variable name to its C++ type (e.g., "__t0" → "System_IO_TextWriter*").
    /// </summary>
    private static Dictionary<string, string> DetermineTempVarTypes(List<IRInstruction> instructions)
    {
        var types = new Dictionary<string, string>();
        foreach (var instr in instructions)
        {
            switch (instr)
            {
                case IRCall call when call.ResultVar != null && call.ResultTypeCpp != null:
                    types.TryAdd(call.ResultVar, call.ResultTypeCpp);
                    break;
                case IRNewObj newObj when newObj.ResultVar != null:
                    types.TryAdd(newObj.ResultVar, newObj.TypeCppName + "*");
                    break;
                case IRFieldAccess fa when !fa.IsStore && fa.ResultVar != null && fa.ResultTypeCpp != null:
                    types.TryAdd(fa.ResultVar, fa.ResultTypeCpp);
                    break;
                case IRStaticFieldAccess sfa when !sfa.IsStore && sfa.ResultVar != null && sfa.ResultTypeCpp != null:
                    types.TryAdd(sfa.ResultVar, sfa.ResultTypeCpp);
                    break;
                case IRCast cast when cast.ResultVar != null:
                    types.TryAdd(cast.ResultVar, cast.TargetTypeCpp);
                    break;
                case IRConversion conv when conv.ResultVar != null:
                    types.TryAdd(conv.ResultVar, conv.TargetType);
                    break;
                case IRBox box when box.ResultVar != null:
                    types.TryAdd(box.ResultVar, "cil2cpp::Object*");
                    break;
                case IRUnbox unbox when unbox.ResultVar != null:
                    types.TryAdd(unbox.ResultVar, unbox.IsUnboxAny ? unbox.ValueTypeCppName : unbox.ValueTypeCppName + "*");
                    break;
                case IRArrayAccess aa when !aa.IsStore && aa.ResultVar != null:
                    types.TryAdd(aa.ResultVar, aa.ElementType);
                    break;
                case IRLoadFunctionPointer lfp when lfp.ResultVar != null:
                    types.TryAdd(lfp.ResultVar, "void*");
                    break;
                case IRDelegateCreate dc when dc.ResultVar != null:
                    types.TryAdd(dc.ResultVar, "cil2cpp::Delegate*");
                    break;
                case IRDelegateInvoke di when di.ResultVar != null:
                    types.TryAdd(di.ResultVar, di.ReturnTypeCpp);
                    break;
                case IRRawCpp raw when raw.ResultVar != null && raw.ResultTypeCpp != null:
                    types.TryAdd(raw.ResultVar, raw.ResultTypeCpp);
                    break;
            }
        }
        return types;
    }

    /// <summary>
    /// Replace "__tN = expr" with "auto __tN = expr" on first use of temp vars.
    /// Only matches pure temp variables like __t0, __t1, etc.
    /// </summary>
    private string AddAutoDeclarations(string code, HashSet<string> declaredTemps)
    {
        // Null-check prefix: "cil2cpp::null_check(...); __tN = ..."
        // Split into prefix and assignment, then add 'auto' to the assignment part.
        const string nullCheckPrefix = "cil2cpp::null_check(";
        if (code.StartsWith(nullCheckPrefix))
        {
            var splitIdx = code.IndexOf("; __t");
            if (splitIdx > 0)
            {
                var prefix = code[..(splitIdx + 2)]; // "cil2cpp::null_check(...); "
                var rest = code[(splitIdx + 2)..];    // "__tN = ..."
                var declared = AddAutoDeclarations(rest, declaredTemps);
                return prefix + declared;
            }
            return code;
        }

        // Match patterns like "__t0 = ..." but NOT "__this->..."
        if (code.StartsWith("__t") && !code.StartsWith("__this"))
        {
            var eqIdx = code.IndexOf(" = ");
            if (eqIdx > 0)
            {
                var varName = code[..eqIdx].Trim();
                // Must be a simple temp var name like __t0, __t1, etc.
                if (varName.StartsWith("__t") &&
                    varName.All(c => c == '_' || char.IsLetterOrDigit(c)) &&
                    !declaredTemps.Contains(varName))
                {
                    declaredTemps.Add(varName);
                    return $"auto {code}";
                }
            }
        }
        return code;
    }

    /// <summary>
    /// For runtime-provided reference types (System.String, System.Object), return the
    /// qualified name of the runtime's TypeInfo so we can alias to it instead of emitting a new one.
    /// Returns null for types that should get their own generated TypeInfo.
    /// </summary>
    private static string? GetRuntimeTypeInfoAlias(string ilFullName) => ilFullName switch
    {
        "System.String" => "cil2cpp::System::String_TypeInfo",
        "System.Object" => "cil2cpp::System::Object_TypeInfo",
        _ => null,
    };

    /// <summary>
    /// Generate a typed function pointer cast expression for a method, to resolve overload ambiguity.
    /// E.g., (void*)(void(*)(Foo*, int32_t))&Foo_Bar
    /// </summary>
    private string GetTypedMethodPointerCast(IRMethod method)
    {
        if (method.IsAbstract || method.BasicBlocks.Count == 0)
            return "nullptr";

        // Use actual declared parameter types for the cast so it matches the function
        // declaration — needed for overload resolution with MSVC.
        // Only sanitize IL function pointer types (contain parentheses) to void*.
        var retType = SanitizeFuncPtrType(method.ReturnTypeCpp ?? "void");
        var paramTypes = new List<string>();
        // Instance methods have implicit 'this' parameter
        if (!method.IsStatic && method.DeclaringType != null)
        {
            paramTypes.Add($"{method.DeclaringType.CppName}*");
        }
        foreach (var p in method.Parameters)
            paramTypes.Add(SanitizeFuncPtrType(p.CppTypeName));

        var funcPtrType = $"{retType}(*)({string.Join(", ", paramTypes)})";
        return $"(void*)({funcPtrType})&{method.CppName}";
    }

    /// <summary>
    /// Replace IL function pointer types (containing parentheses) with void*.
    /// These types can't be expressed in C++ function pointer casts.
    /// </summary>
    private static string SanitizeFuncPtrType(string cppType)
    {
        if (cppType.Contains("(") || cppType.Contains(")"))
            return "void*";
        return cppType;
    }

    /// <summary>
    /// Replace pointer-to-unknown-struct types with void* for safe function pointer casts.
    /// Types not defined in the compilation unit (BCL types like System_Type*) cause C++ errors.
    /// </summary>
    private string SafeCppType(string cppType)
    {
        if (cppType.EndsWith("*"))
        {
            var baseType = cppType.TrimEnd('*').Trim();
            if (baseType.StartsWith("cil2cpp::") || IsCppPrimitiveType(baseType))
                return cppType;
            // Check if the struct type is defined in the compilation unit
            if (_knownStructTypes == null) BuildKnownStructTypes();
            if (!_knownStructTypes!.Contains(baseType))
                return "void*";
        }
        return cppType;
    }

    private HashSet<string>? _knownStructTypes;
    private void BuildKnownStructTypes()
    {
        _knownStructTypes = new HashSet<string>();
        foreach (var type in _module.Types)
        {
            if (CppNameMapper.IsCompilerGeneratedType(type.ILFullName)) continue;
            if (type.IsInterface && type.Fields.Count == 0) continue;
            _knownStructTypes.Add(type.CppName);
        }
    }

    private void EmitVTableData(StringBuilder sb, List<IRType> userTypes)
    {
        // Build set of types whose methods are actually generated as C++ functions.
        // Methods from runtime-provided types (Object, ValueType, Enum, etc.) don't exist
        // as generated functions — VTable entries must use fallbacks for them.
        var generatedMethodTypes = new HashSet<string>();
        foreach (var t in userTypes)
        {
            // Non-core runtime-provided types (Task, Thread) have methods generated from BCL IL
            var isCoreRuntime = t.IsRuntimeProvided && IRBuilder.CoreRuntimeTypes.Contains(t.ILFullName);
            if (!isCoreRuntime && !t.IsDelegate)
                generatedMethodTypes.Add(t.CppName);
        }

        bool any = false;
        foreach (var type in userTypes)
        {
            // Skip core runtime types (Object, String) but generate vtables for non-core (Task, Thread)
            var isCoreRuntime = type.IsRuntimeProvided && IRBuilder.CoreRuntimeTypes.Contains(type.ILFullName);
            if (type.IsInterface || type.IsDelegate || isCoreRuntime || type.VTable.Count == 0) continue;
            if (!any)
            {
                sb.AppendLine("// ===== VTable Data =====");
                any = true;
            }

            // Build lookup of parent vtable entries for inheritance fallback
            var parentVTableEntries = new Dictionary<int, string>();
            {
                var baseType = type.BaseType;
                // Walk up the inheritance chain to find valid vtable entries
                while (baseType != null)
                {
                    for (int si = 0; si < baseType.VTable.Count; si++)
                    {
                        if (parentVTableEntries.ContainsKey(si)) continue;
                        var be = baseType.VTable[si];
                        if (be.Method != null && !be.Method.IsAbstract
                            && _declaredFunctionNames.Contains(be.Method.CppName))
                        {
                            parentVTableEntries[si] = GetTypedMethodPointerCast(be.Method);
                        }
                    }
                    baseType = baseType.BaseType;
                }
            }

            // Method pointer array
            var methods = string.Join(", ", type.VTable.Select((e, idx) =>
            {
                if (e.Method != null && !e.Method.IsAbstract)
                {
                    // If the method's declaring type is a core runtime type or not in generated types,
                    // the C++ function won't exist — use fallback
                    var declType = e.Method.DeclaringType;
                    var isDeclCoreRuntime = declType != null && declType.IsRuntimeProvided
                        && IRBuilder.CoreRuntimeTypes.Contains(declType.ILFullName);
                    if (declType != null && (isDeclCoreRuntime || !generatedMethodTypes.Contains(declType.CppName)))
                        return ObjectMethodFallbacks.GetValueOrDefault(e.MethodName, "nullptr");
                    // Check if the function was actually declared in the header
                    if (!_declaredFunctionNames.Contains(e.Method.CppName))
                    {
                        // Fallback: inherit from parent vtable if available
                        if (parentVTableEntries.TryGetValue(idx, out var parentMethod))
                            return parentMethod;
                        return ObjectMethodFallbacks.GetValueOrDefault(e.MethodName, "nullptr");
                    }
                    return GetTypedMethodPointerCast(e.Method);
                }
                // Method not assigned — try parent fallback
                if (parentVTableEntries.TryGetValue(idx, out var inherited))
                    return inherited;
                return ObjectMethodFallbacks.GetValueOrDefault(e.MethodName, "nullptr");
            }));
            sb.AppendLine($"static void* {type.CppName}_vtable_methods[] = {{ {methods} }};");
            sb.AppendLine($"static cil2cpp::VTable {type.CppName}_VTable = {{ &{type.CppName}_TypeInfo, {type.CppName}_vtable_methods, {type.VTable.Count} }};");
        }
        if (any) sb.AppendLine();
    }

    private void EmitInterfaceData(StringBuilder sb, List<IRType> userTypes)
    {
        // Build set of types whose methods are generated (same as EmitVTableData)
        var generatedMethodTypes = new HashSet<string>();
        foreach (var t in userTypes)
        {
            var isCoreRuntime = t.IsRuntimeProvided && IRBuilder.CoreRuntimeTypes.Contains(t.ILFullName);
            if (!isCoreRuntime && !t.IsDelegate)
                generatedMethodTypes.Add(t.CppName);
        }

        bool any = false;
        foreach (var type in userTypes)
        {
            var isCoreRuntime = type.IsRuntimeProvided && IRBuilder.CoreRuntimeTypes.Contains(type.ILFullName);
            if (type.IsInterface || isCoreRuntime || type.Interfaces.Count == 0) continue;
            if (!any)
            {
                sb.AppendLine("// ===== Interface Data =====");
                any = true;
            }

            // Interfaces pointer array
            var ifaces = string.Join(", ", type.Interfaces.Select(i => $"&{i.CppName}_TypeInfo"));
            sb.AppendLine($"static cil2cpp::TypeInfo* {type.CppName}_interfaces[] = {{ {ifaces} }};");
        }

        // Interface vtable method arrays and InterfaceVTable arrays
        foreach (var type in userTypes)
        {
            var isCoreRt = type.IsRuntimeProvided && IRBuilder.CoreRuntimeTypes.Contains(type.ILFullName);
            if (type.IsInterface || isCoreRt || type.InterfaceImpls.Count == 0) continue;

            foreach (var impl in type.InterfaceImpls)
            {
                var methods = string.Join(", ", impl.MethodImpls.Select(m =>
                {
                    if (m == null) return "nullptr";
                    // If the method's declaring type is a core runtime type or not generated, use nullptr
                    var declType = m.DeclaringType;
                    var isDeclCoreRt = declType != null && declType.IsRuntimeProvided
                        && IRBuilder.CoreRuntimeTypes.Contains(declType.ILFullName);
                    if (declType != null && (isDeclCoreRt || !generatedMethodTypes.Contains(declType.CppName)))
                        return "nullptr";
                    // Check if the function was actually declared in the header
                    if (!_declaredFunctionNames.Contains(m.CppName))
                        return "nullptr";
                    return GetTypedMethodPointerCast(m);
                }));
                // MSVC: zero-size arrays are not allowed (C2466)
                if (string.IsNullOrWhiteSpace(methods))
                    methods = "nullptr";
                sb.AppendLine($"static void* {type.CppName}_iface_{impl.Interface.CppName}_methods[] = {{ {methods} }};");
            }

            var entries = type.InterfaceImpls.Select(impl =>
                $"{{ &{impl.Interface.CppName}_TypeInfo, {type.CppName}_iface_{impl.Interface.CppName}_methods, {impl.MethodImpls.Count} }}");
            sb.AppendLine($"static cil2cpp::InterfaceVTable {type.CppName}_interface_vtables[] = {{");
            sb.AppendLine($"    {string.Join(",\n    ", entries)}");
            sb.AppendLine("};");
        }
        if (any) sb.AppendLine();
    }

    private void EmitGenericVarianceData(StringBuilder sb, List<IRType> userTypes)
    {
        var typeInfoLookup = BuildTypeInfoExprLookup();
        bool any = false;
        foreach (var type in userTypes)
        {
            if (type.IsRuntimeProvided) continue;
            if (!type.IsGenericInstance || type.GenericArguments.Count == 0
                || type.GenericParameterVariances.Count == 0) continue;

            // Verify all generic arguments have TypeInfo available
            bool allArgsResolvable = type.GenericArguments.All(arg =>
                typeInfoLookup.ContainsKey(arg));
            if (!allArgsResolvable) continue;

            if (!any)
            {
                sb.AppendLine("// ===== Generic Variance Data =====");
                any = true;
            }

            // Emit TypeInfo pointer array for generic arguments
            var argRefs = type.GenericArguments.Select(arg => typeInfoLookup[arg]);
            sb.AppendLine($"static cil2cpp::TypeInfo* {type.CppName}_generic_args[] = {{ {string.Join(", ", argRefs)} }};");

            // Emit variance array
            var variances = type.GenericParameterVariances.Select(v => ((byte)v).ToString());
            sb.AppendLine($"static uint8_t {type.CppName}_generic_variances[] = {{ {string.Join(", ", variances)} }};");
        }
        if (any) sb.AppendLine();
    }

    private void EmitFinalizerWrappers(StringBuilder sb, List<IRType> userTypes)
    {
        bool any = false;
        foreach (var type in userTypes)
        {
            if (type.Finalizer == null) continue;
            // Skip runtime-provided types — their Finalize method isn't generated
            if (type.IsRuntimeProvided) continue;
            // BCL types have stub finalizers — use System_Object_Finalize as fallback
            var isStubbed = type.SourceKind == AssemblyKind.BCL;
            if (!any)
            {
                sb.AppendLine("// ===== Finalizer Wrappers =====");
                any = true;
            }

            sb.AppendLine($"static void {type.CppName}_finalizer_wrapper(cil2cpp::Object* obj) {{");
            if (isStubbed)
                sb.AppendLine($"    System_Object_Finalize((System_Object*)obj);");
            else
                sb.AppendLine($"    {type.Finalizer.CppName}(({type.CppName}*)obj);");
            sb.AppendLine("}");
        }
        if (any) sb.AppendLine();
    }

    /// <summary>
    /// Build a lookup table mapping IL type full names to TypeInfo pointer expressions.
    /// Only includes types with TypeInfo emitted in generated code (non-runtime-provided user types + primitives).
    /// </summary>
    private Dictionary<string, string> BuildTypeInfoExprLookup()
    {
        var lookup = new Dictionary<string, string>();

        // User types that are not runtime-provided
        foreach (var type in _module.Types)
        {
            if (!type.IsRuntimeProvided && !CppNameMapper.IsCompilerGeneratedType(type.ILFullName))
            {
                lookup[type.ILFullName] = $"&{type.CppName}_TypeInfo";
            }
        }

        // Primitive types (array element types)
        foreach (var entry in _module.PrimitiveTypeInfos.Values)
        {
            lookup[entry.ILFullName] = $"&{entry.CppMangledName}_TypeInfo";
        }

        return lookup;
    }

    private void EmitReflectionMetadata(StringBuilder sb, List<IRType> userTypes)
    {
        var typeInfoLookup = BuildTypeInfoExprLookup();
        bool any = false;
        var emittedReflection = new HashSet<string>();

        foreach (var type in userTypes)
        {
            if (type.IsRuntimeProvided || type.IsEnum || type.IsDelegate) continue;
            // Skip runtime exception types — their C++ struct layout is defined by the runtime
            // and doesn't match the generated field layout (e.g., cil2cpp::ArgumentException has no f_paramName)
            if (CppNameMapper.IsRuntimeExceptionType(type.ILFullName)) continue;
            // Deduplicate — BCL proxies may appear multiple times
            if (!emittedReflection.Add(type.CppName)) continue;

            var allFields = type.Fields.Concat(type.StaticFields).ToList();
            var reflectableMethods = type.Methods
                .Where(m => !CppNameMapper.IsCompilerGeneratedType(m.Name))
                .ToList();

            if (allFields.Count == 0 && reflectableMethods.Count == 0) continue;

            if (!any)
            {
                sb.AppendLine("// ===== Reflection Metadata =====");
                any = true;
            }

            // Emit custom attribute arrays for type and fields
            // Type-level attributes
            if (type.CustomAttributes.Count > 0)
                EmitAttributeInfoArray(sb, $"{type.CppName}_custom_attrs", type.CustomAttributes);

            // Field-level attributes
            foreach (var field in allFields)
            {
                if (field.CustomAttributes.Count > 0)
                    EmitAttributeInfoArray(sb, $"{type.CppName}_{field.CppName}_attrs", field.CustomAttributes);
            }

            // Method-level attributes — use index suffix to disambiguate overloaded methods
            for (int mi = 0; mi < reflectableMethods.Count; mi++)
            {
                var method = reflectableMethods[mi];
                if (method.CustomAttributes.Count > 0)
                    EmitAttributeInfoArray(sb, $"{type.CppName}_m{mi}_attrs", method.CustomAttributes);
            }

            // Emit FieldInfo array
            if (allFields.Count > 0)
            {
                sb.AppendLine($"static cil2cpp::FieldInfo {type.CppName}_fields[] = {{");
                foreach (var field in allFields)
                {
                    var fieldTypeExpr = typeInfoLookup.GetValueOrDefault(field.FieldTypeName, "nullptr");
                    // Primitive types (System_Byte = uint8_t, etc.) don't have struct layout;
                    // their m_value field is at offset 0 by definition.
                    var offsetExpr = field.IsStatic || type.IsPrimitiveType
                        ? "0"
                        : $"offsetof({type.CppName}, {field.CppName})";
                    var fieldAttrsExpr = field.CustomAttributes.Count > 0
                        ? $"{type.CppName}_{field.CppName}_attrs" : "nullptr";
                    sb.AppendLine($"    {{ .name = \"{field.Name}\", " +
                        $".declaring_type = &{type.CppName}_TypeInfo, " +
                        $".field_type = {fieldTypeExpr}, " +
                        $".offset = {offsetExpr}, " +
                        $".flags = 0x{field.Attributes:X4}, " +
                        $".custom_attributes = {fieldAttrsExpr}, " +
                        $".custom_attribute_count = {field.CustomAttributes.Count} }},");
                }
                sb.AppendLine("};");
            }

            // Emit MethodInfo parameter type arrays and MethodInfo array
            if (reflectableMethods.Count > 0)
            {
                // First: parameter type arrays for methods that have parameters
                for (int mi = 0; mi < reflectableMethods.Count; mi++)
                {
                    var method = reflectableMethods[mi];
                    if (method.Parameters.Count == 0) continue;
                    var paramTypeExprs = method.Parameters
                        .Select(p => typeInfoLookup.GetValueOrDefault(p.ILTypeName, "nullptr"))
                        .ToList();
                    sb.AppendLine($"static cil2cpp::TypeInfo* {type.CppName}_m{mi}_param_types[] = {{ {string.Join(", ", paramTypeExprs)} }};");
                }

                // Second: MethodInfo array
                sb.AppendLine($"static cil2cpp::MethodInfo {type.CppName}_methods[] = {{");
                for (int mi = 0; mi < reflectableMethods.Count; mi++)
                {
                    var method = reflectableMethods[mi];
                    var returnTypeExpr = typeInfoLookup.GetValueOrDefault(
                        method.ReturnType?.ILFullName ?? "", "nullptr");
                    var paramTypesExpr = method.Parameters.Count > 0
                        ? $"{type.CppName}_m{mi}_param_types" : "nullptr";
                    // Check if the method was actually declared (not filtered by HasUnknownParameterTypes)
                    var hasValidSignature = !method.IsAbstract && !method.IsInternalCall
                        && method.BasicBlocks.Count > 0
                        && !method.Parameters.Any(p => p.CppTypeName.Contains("(") || p.CppTypeName.Contains(")"))
                        && !(method.ReturnTypeCpp?.Contains("(") == true)
                        && _declaredFunctionNames.Contains(method.CppName);
                    var methodPtrExpr = hasValidSignature
                        ? GetTypedMethodPointerCast(method)
                        : "nullptr";
                    var methodAttrsExpr = method.CustomAttributes.Count > 0
                        ? $"{type.CppName}_m{mi}_attrs" : "nullptr";

                    sb.AppendLine($"    {{ .name = \"{method.Name}\", " +
                        $".declaring_type = &{type.CppName}_TypeInfo, " +
                        $".return_type = {returnTypeExpr}, " +
                        $".parameter_types = {paramTypesExpr}, " +
                        $".parameter_count = {method.Parameters.Count}, " +
                        $".method_pointer = {methodPtrExpr}, " +
                        $".flags = 0x{method.Attributes:X4}, " +
                        $".vtable_slot = {method.VTableSlot}, " +
                        $".custom_attributes = {methodAttrsExpr}, " +
                        $".custom_attribute_count = {method.CustomAttributes.Count} }},");
                }
                sb.AppendLine("};");
            }
        }
        if (any) sb.AppendLine();
    }

    /// <summary>
    /// Emit a single CustomAttributeInfo array and its argument arrays.
    /// </summary>
    private void EmitAttributeInfoArray(StringBuilder sb, string arrayName, List<IRCustomAttribute> attrs)
    {
        // First, emit argument arrays (including nested array element arrays)
        for (int i = 0; i < attrs.Count; i++)
        {
            var attr = attrs[i];
            if (attr.ConstructorArgs.Count > 0)
            {
                // Emit nested array element arrays first
                for (int j = 0; j < attr.ConstructorArgs.Count; j++)
                {
                    var arg = attr.ConstructorArgs[j];
                    if (arg.Kind == AttributeArgKind.Array && arg.ArrayElements is { Count: > 0 })
                    {
                        EmitAttributeArgArray(sb, $"{arrayName}_{i}_a{j}_elems", arg.ArrayElements);
                    }
                }

                sb.AppendLine($"static cil2cpp::CustomAttributeArg {arrayName}_{i}_args[] = {{");
                for (int j = 0; j < attr.ConstructorArgs.Count; j++)
                {
                    var arg = attr.ConstructorArgs[j];
                    var valueInit = FormatAttributeArgValue(arg);
                    var arrayInit = FormatAttributeArgArrayFields(arg, $"{arrayName}_{i}_a{j}_elems");
                    sb.AppendLine($"    {{ .type_name = \"{EscapeCppString(arg.TypeName)}\", {valueInit}{arrayInit} }},");
                }
                sb.AppendLine("};");
            }
        }

        // Then emit the CustomAttributeInfo array
        sb.AppendLine($"static cil2cpp::CustomAttributeInfo {arrayName}[] = {{");
        for (int i = 0; i < attrs.Count; i++)
        {
            var attr = attrs[i];
            var argsExpr = attr.ConstructorArgs.Count > 0
                ? $"{arrayName}_{i}_args" : "nullptr";
            sb.AppendLine($"    {{ .attribute_type_name = \"{attr.AttributeTypeName}\", " +
                $".args = {argsExpr}, " +
                $".arg_count = {attr.ConstructorArgs.Count} }},");
        }
        sb.AppendLine("};");
    }

    /// <summary>
    /// Emit a static array of CustomAttributeArg for array-typed attribute arguments.
    /// </summary>
    private void EmitAttributeArgArray(StringBuilder sb, string varName, List<IRAttributeArg> elements)
    {
        sb.AppendLine($"static cil2cpp::CustomAttributeArg {varName}[] = {{");
        foreach (var elem in elements)
        {
            var valueInit = FormatAttributeArgValue(elem);
            sb.AppendLine($"    {{ .type_name = \"{EscapeCppString(elem.TypeName)}\", {valueInit}, .array_elements = nullptr, .array_count = 0 }},");
        }
        sb.AppendLine("};");
    }

    /// <summary>
    /// Format the array_elements and array_count fields for a CustomAttributeArg initializer.
    /// </summary>
    private static string FormatAttributeArgArrayFields(IRAttributeArg arg, string elemVarName)
    {
        if (arg.Kind == AttributeArgKind.Array && arg.ArrayElements is { Count: > 0 })
            return $", .array_elements = {elemVarName}, .array_count = {arg.ArrayElements.Count}";
        return ", .array_elements = nullptr, .array_count = 0";
    }

    /// <summary>
    /// Format a custom attribute argument value for C++ designated initializer.
    /// </summary>
    private static string FormatAttributeArgValue(IRAttributeArg arg)
    {
        if (arg.Value == null && arg.Kind != AttributeArgKind.Array)
            return ".string_val = nullptr";

        return arg.Kind switch
        {
            AttributeArgKind.String => $".string_val = \"{EscapeCppString(arg.Value?.ToString() ?? "")}\"",
            AttributeArgKind.Type => $".string_val = \"{EscapeCppString(arg.Value?.ToString() ?? "")}\"",
            AttributeArgKind.Float when arg.TypeName == "System.Single" => $".float_val = {FormatFloat(arg.Value!)}",
            AttributeArgKind.Float => $".float_val = {FormatDouble(arg.Value!)}",
            AttributeArgKind.Enum => $".int_val = {Convert.ToInt64(arg.Value)}",
            AttributeArgKind.Array => ".int_val = 0",  // value union unused for arrays
            AttributeArgKind.Int when arg.TypeName == "System.Boolean" => $".int_val = {((bool)arg.Value! ? 1 : 0)}",
            AttributeArgKind.Int when arg.TypeName == "System.Char" => $".int_val = {(int)(char)arg.Value!}",
            _ => $".int_val = {Convert.ToInt64(arg.Value)}",
        };
    }

    private static string EscapeCppString(string s) =>
        s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "\\r");

    private static string FormatFloat(object val) =>
        ((float)val).ToString("G9", System.Globalization.CultureInfo.InvariantCulture);

    private static string FormatDouble(object val) =>
        ((double)val).ToString("G17", System.Globalization.CultureInfo.InvariantCulture);

    /// <summary>
    /// Emit extern "C" declarations and managed wrapper functions for P/Invoke methods.
    /// </summary>
    // C stdlib functions that are already declared via standard headers — don't re-declare
    private static readonly HashSet<string> CStdlibFunctions = new()
    {
        "strlen", "strcpy", "strncpy", "strcat", "strncat", "strcmp", "strncmp",
        "memcpy", "memmove", "memset", "memcmp", "malloc", "calloc", "realloc", "free",
        "printf", "sprintf", "snprintf", "fprintf", "puts", "putchar", "getchar",
        "abs", "atoi", "atof", "atol", "rand", "srand", "exit", "abort",
        "qsort", "bsearch", "time", "clock", "sin", "cos", "tan", "sqrt", "pow",
        "fopen", "fclose", "fread", "fwrite", "fseek", "ftell"
    };

    // .NET internal P/Invoke modules — no extern declarations needed
    // (QCall = CLR-internal; libSystem.* = Unix-only native shims; ucrtbase = C runtime)
    private static readonly HashSet<string> InternalPInvokeModules = new(StringComparer.OrdinalIgnoreCase)
    {
        "QCall", "QCall.dll", "libSystem.Native", "libSystem.Globalization.Native",
        "System.Globalization.Native", "System.Native", "System.IO.Compression.Native",
        "System.Security.Cryptography.Native.OpenSsl", "System.Net.Security.Native",
        "ucrtbase", "ucrtbase.dll"
    };

    private void EmitPInvokeDeclarations(StringBuilder sb, List<IRType> userTypes,
        HashSet<string> emittedMethodSignatures)
    {
        // Scan ALL module types (not just deduplicated userTypes) — partial classes like
        // Interop.Kernel32 span multiple assemblies, and deduplication drops P/Invoke methods
        var pinvokeMethods = _module.Types
            .Where(t => !t.IsInterface && !t.IsDelegate && !t.IsRuntimeProvided)
            .SelectMany(t => t.Methods)
            .Where(m => m.IsPInvoke
                        && !string.IsNullOrEmpty(m.PInvokeModule)
                        && !InternalPInvokeModules.Contains(m.PInvokeModule!))
            .ToList();

        if (pinvokeMethods.Count == 0) return;

        // Filter out C stdlib functions and methods with delegate/function pointer parameters
        // (our codegen doesn't produce valid C function pointer types for extern "C" declarations)
        var needsExternDecl = pinvokeMethods
            .Where(m => !CStdlibFunctions.Contains(m.PInvokeEntryPoint ?? m.Name))
            .Where(m => !m.Parameters.Any(p =>
                IsDelegateType(p.ParameterType) || p.CppTypeName.StartsWith("method")))
            .ToList();

        // Track which entry points have valid extern "C" declarations
        // C stdlib functions are always available via standard headers
        var declaredEntryPoints = new HashSet<string>(CStdlibFunctions);
        // Track the declared parameter types for each entry point (for wrapper compatibility check)
        var declaredParamTypes = new Dictionary<string, List<string>>();
        if (needsExternDecl.Count > 0)
        {
            sb.AppendLine("// ===== P/Invoke Declarations =====");
            sb.AppendLine("extern \"C\" {");

            // Deduplicate extern declarations by entry point name only
            // (C doesn't support function overloading — same entry point = same function)
            // Multiple __PInvoke methods may share an entry point but have different param types
            // (e.g., ReadFile with int32_t* vs NativeOverlapped*). We pick the best candidate:
            // prefer methods with only C-primitive params (no struct pointers like NativeOverlapped*).
            var bestExternCandidate = new Dictionary<string, (IRMethod method, int score)>();
            foreach (var method in needsExternDecl)
            {
                var entryPoint = method.PInvokeEntryPoint ?? method.Name;
                var retType = GetPInvokeNativeType(method.ReturnTypeCpp, null);
                if (!IsCppPrimitiveOrPointerType(retType)) continue;

                bool hasNonPointerType = false;
                int structPointerCount = 0;
                foreach (var p in method.Parameters)
                {
                    var nt = GetPInvokeNativeType(p.CppTypeName, p.ParameterType);
                    if (!IsCppPrimitiveOrPointerType(nt)) { hasNonPointerType = true; break; }
                    // Count struct pointers (pointer to non-primitive type)
                    if (nt.EndsWith("*"))
                    {
                        var baseType = nt.TrimEnd('*').Trim();
                        if (!IsCppPrimitiveType(baseType) && baseType != "void")
                            structPointerCount++;
                    }
                }
                if (hasNonPointerType) continue;

                // Lower score = better candidate (fewer struct pointers)
                if (!bestExternCandidate.TryGetValue(entryPoint, out var existing) ||
                    structPointerCount < existing.score)
                {
                    bestExternCandidate[entryPoint] = (method, structPointerCount);
                }
            }

            // Emit extern declarations from the best candidates
            foreach (var (entryPoint, (method, _)) in bestExternCandidate.OrderBy(kv => kv.Key))
            {
                var retType = GetPInvokeNativeType(method.ReturnTypeCpp, null);
                var nativeParamTypes = new List<string>();
                foreach (var p in method.Parameters)
                    nativeParamTypes.Add(GetPInvokeNativeType(p.CppTypeName, p.ParameterType));

                var paramParts = new List<string>();
                for (int i = 0; i < method.Parameters.Count; i++)
                    paramParts.Add($"{nativeParamTypes[i]} p{i}");
                var paramDecl = string.Join(", ", paramParts);
                sb.AppendLine($"    {retType} {entryPoint}({paramDecl});");
                declaredEntryPoints.Add(entryPoint);
                declaredParamTypes[entryPoint] = nativeParamTypes;
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }

        // Generate managed wrappers (deduplicate by C++ signature)
        // Only generate wrappers for entry points that have a valid extern "C" declaration
        // AND whose parameter types match the declared extern (to avoid type mismatches).
        // Multiple __PInvoke inner methods with the same entry point and compatible types
        // each get their own wrapper (they may have different C++ names).
        sb.AppendLine("// ===== P/Invoke Wrappers =====");
        foreach (var method in pinvokeMethods)
        {
            var entryPoint = method.PInvokeEntryPoint ?? method.Name;
            if (!declaredEntryPoints.Contains(entryPoint)) continue;
            var sig = method.GetCppSignature();
            if (!emittedMethodSignatures.Add(sig)) continue; // skip exact duplicates

            // Check parameter type compatibility with the declared extern
            if (declaredParamTypes.TryGetValue(entryPoint, out var externParamTypes))
            {
                if (method.Parameters.Count != externParamTypes.Count) continue;
                bool compatible = true;
                for (int i = 0; i < method.Parameters.Count; i++)
                {
                    var methodType = GetPInvokeNativeType(method.Parameters[i].CppTypeName,
                        method.Parameters[i].ParameterType);
                    if (methodType != externParamTypes[i]) { compatible = false; break; }
                }
                if (!compatible) continue;
            }
            var retType = method.ReturnTypeCpp;

            sb.AppendLine($"// P/Invoke: {method.PInvokeModule}!{entryPoint}");
            sb.AppendLine($"{sig} {{");

            // Marshal arguments
            var callArgs = new List<string>();
            for (int i = 0; i < method.Parameters.Count; i++)
            {
                var param = method.Parameters[i];
                if (IsStringType(param.CppTypeName))
                {
                    sb.AppendLine($"    auto __p{i} = cil2cpp::string_to_utf8({param.CppName});");
                    callArgs.Add($"__p{i}");
                }
                else if (IsDelegateType(param.ParameterType))
                {
                    var fnPtrType = GetDelegateFunctionPointerType(param.ParameterType);
                    sb.AppendLine($"    auto __p{i} = reinterpret_cast<{fnPtrType}>(reinterpret_cast<cil2cpp::Delegate*>({param.CppName})->method_ptr);");
                    callArgs.Add($"__p{i}");
                }
                else
                {
                    callArgs.Add(param.CppName);
                }
            }

            var argStr = string.Join(", ", callArgs);
            if (retType == "void")
            {
                sb.AppendLine($"    {entryPoint}({argStr});");
            }
            else if (IsStringType(retType))
            {
                sb.AppendLine($"    auto __ret = {entryPoint}({argStr});");
                sb.AppendLine($"    return cil2cpp::string_literal(__ret);");
            }
            else
            {
                sb.AppendLine($"    return {entryPoint}({argStr});");
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }
    }

    /// <summary>
    /// Convert C++ managed type to native P/Invoke type.
    /// </summary>
    private string GetPInvokeNativeType(string cppType, IRType? paramType)
    {
        if (cppType == "cil2cpp::String*") return "const char*";
        if (cppType == "void") return "void";
        if (IsDelegateType(paramType)) return GetDelegateFunctionPointerType(paramType!);
        return cppType;
    }

    /// <summary>
    /// Check if a C++ type is a primitive, pointer, or void (valid for extern "C" return types).
    /// </summary>
    private static bool IsCppPrimitiveOrPointerType(string cppType)
    {
        if (cppType.EndsWith("*")) return true;
        return cppType is "void" or "bool" or "int8_t" or "uint8_t" or "int16_t" or "uint16_t"
            or "int32_t" or "uint32_t" or "int64_t" or "uint64_t" or "float" or "double"
            or "char16_t" or "intptr_t" or "uintptr_t";
    }

    /// <summary>
    /// Check if a type is a delegate type.
    /// </summary>
    private static bool IsDelegateType(IRType? type) =>
        type is { IsDelegate: true };

    /// <summary>
    /// Get the C function pointer type for a delegate type.
    /// Looks up the delegate's Invoke method to determine the signature.
    /// Returns "RetType(*)(ParamTypes...)" syntax.
    /// </summary>
    private static string GetDelegateFunctionPointerType(IRType? delegateType)
    {
        if (delegateType == null) return "void(*)()";

        var invoke = delegateType.Methods.FirstOrDefault(m => m.Name == "Invoke");
        if (invoke == null) return "void(*)()";

        var retType = invoke.ReturnTypeCpp == "void" ? "void"
            : invoke.ReturnTypeCpp == "cil2cpp::String*" ? "const char*"
            : invoke.ReturnTypeCpp;
        var paramTypes = invoke.Parameters
            .Select(p => p.CppTypeName == "cil2cpp::String*" ? "const char*" : p.CppTypeName)
            .ToList();

        return $"{retType}(*)({string.Join(", ", paramTypes)})";
    }

    private static bool IsStringType(string cppType) =>
        cppType is "cil2cpp::String*";
}
